(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.lumo = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';module.exports=earcut;module.exports.default=earcut;function earcut(data,holeIndices,dim){dim=dim||2;var hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length,outerNode=linkedList(data,0,outerLen,dim,true),triangles=[];if(!outerNode)return triangles;var minX,minY,maxX,maxY,x,y,invSize;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var i=dim;i<outerLen;i+=dim){x=data[i];y=data[i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and invSize are later used to transform coords into integers for z-order calculation
invSize=Math.max(maxX-minX,maxY-minY);invSize=invSize!==0?1/invSize:0;}earcutLinked(outerNode,triangles,dim,minX,minY,invSize);return triangles;}// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data,start,end,dim,clockwise){var i,last;if(clockwise===signedArea(data,start,end,dim)>0){for(i=start;i<end;i+=dim){last=insertNode(i,data[i],data[i+1],last);}}else{for(i=end-dim;i>=start;i-=dim){last=insertNode(i,data[i],data[i+1],last);}}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}// eliminate colinear or duplicate points
function filterPoints(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)break;again=true;}else{p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;// interlink polygon nodes in z-order
if(!pass&&invSize)indexCurve(ear,minX,minY,invSize);var stop=ear,prev,next;// iterate through ears, slicing them one by one
while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){// cut off the triangle
triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);// skipping the next vertice leads to less sliver triangles
ear=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears
if(ear===stop){// try filtering points and slicing again
if(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);// if this didn't work, try curing all small self-intersections locally
}else if(pass===1){ear=cureLocalIntersections(ear,triangles,dim);earcutLinked(ear,triangles,dim,minX,minY,invSize,2);// as a last resort, try splitting the remaining polygon into two
}else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,invSize);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// now make sure we don't have other points inside the potential ear
var p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed(ear,minX,minY,invSize){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// triangle bbox; min & max are calculated like this for speed
var minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;
var minZ=zOrder(minTX,minTY,minX,minY,invSize),maxZ=zOrder(maxTX,maxTY,minX,minY,invSize);// first look for points inside the triangle in increasing z-order
var p=ear.nextZ;while(p&&p.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.nextZ;}// then look for points in decreasing z-order
p=ear.prevZ;while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}return true;}// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved
removeNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return p;}// try splitting polygon into two and triangulate them independently
function splitEarcut(start,triangles,dim,minX,minY,invSize){// look for a valid diagonal that divides the polygon into two
var a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){// split the polygon in two by the diagonal
var c=splitPolygon(a,b);// filter colinear points around the cuts
a=filterPoints(a,a.next);c=filterPoints(c,c.next);// run earcut on each half
earcutLinked(a,triangles,dim,minX,minY,invSize);earcutLinked(c,triangles,dim,minX,minY,invSize);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data,holeIndices,outerNode,dim){var queue=[],i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);// process holes from left to right
for(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function compareX(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole,outerNode){outerNode=findHoleBridge(hole,outerNode);if(outerNode){var b=splitPolygon(outerNode,hole);filterPoints(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole,outerNode){var p=outerNode,hx=hole.x,hy=hole.y,qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m.prev;// hole touches outer segment; pick lower endpoint
// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
var stop=m,mx=m.x,my=m.y,tanMin=Infinity,tan;p=m.next;while(p!==stop){if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential
if((tan<tanMin||tan===tanMin&&p.x>m.x)&&locallyInside(p,hole)){m=p;tanMin=tan;}}p=p.next;}return m;}// interlink polygon nodes in z-order
function indexCurve(start,minX,minY,invSize){var p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,invSize);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){e=p;p=p.nextZ;pSize--;}else{e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x,y,minX,minY,invSize){// coords are transformed into non-negative 15-bit integer range
x=32767*(x-minX)*invSize;y=32767*(y-minY)*invSize;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring
function getLeftmost(start){var p=start,leftmost=start;do{if(p.x<leftmost.x)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle
function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b);}// signed area of a triangle
function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal
function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect
function intersects(p1,q1,p2,q2){if(equals(p1,q1)&&equals(p2,q2)||equals(p1,q2)&&equals(p2,q1))return true;return area(p1,q1,p2)>0!==area(p1,q1,q2)>0&&area(p2,q2,p1)>0!==area(p2,q2,q1)>0;}// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon
function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a,b){var p=a,inside=false,px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x)inside=!inside;p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a,b){var a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i,x,y,last){var p=new Node(i,x,y);if(!last){p.prev=p;p.next=p;}else{p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node(i,x,y){// vertice index in coordinates array
this.i=i;// vertex coordinates
this.x=x;this.y=y;// previous and next vertice nodes in a polygon ring
this.prev=null;this.next=null;// z-order curve value
this.z=null;// previous and next nodes in z-order
this.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point
this.steiner=false;}// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation=function(data,holeIndices,dim,triangles){var hasHoles=holeIndices&&holeIndices.length;var outerLen=hasHoles?holeIndices[0]*dim:data.length;var polygonArea=Math.abs(signedArea(data,0,outerLen,dim));if(hasHoles){for(var i=0,len=holeIndices.length;i<len;i++){var start=holeIndices[i]*dim;var end=i<len-1?holeIndices[i+1]*dim:data.length;polygonArea-=Math.abs(signedArea(data,start,end,dim));}}var trianglesArea=0;for(i=0;i<triangles.length;i+=3){var a=triangles[i]*dim;var b=triangles[i+1]*dim;var c=triangles[i+2]*dim;trianglesArea+=Math.abs((data[a]-data[c])*(data[b+1]-data[a+1])-(data[a]-data[b])*(data[c+1]-data[a+1]));}return polygonArea===0&&trianglesArea===0?0:Math.abs((trianglesArea-polygonArea)/polygonArea);};function signedArea(data,start,end,dim){var sum=0;for(var i=start,j=end-dim;i<end;i+=dim){sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);j=i;}return sum;}// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten=function(data){var dim=data[0][0].length,result={vertices:[],holes:[],dimensions:dim},holeIndex=0;for(var i=0;i<data.length;i++){for(var j=0;j<data[i].length;j++){for(var d=0;d<dim;d++){result.vertices.push(data[i][j][d]);}}if(i>0){holeIndex+=data[i-1].length;result.holes.push(holeIndex);}}return result;};

},{}],2:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
function EventEmitter(){this._events=this._events||{};this._maxListeners=this._maxListeners||undefined;}module.exports=EventEmitter;// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners=10;// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||n<0||isNaN(n))throw TypeError('n must be a positive number');this._maxListeners=n;return this;};EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(!this._events)this._events={};// If there is no 'error' event listener then throw.
if(type==='error'){if(!this._events.error||isObject(this._events.error)&&!this._events.error.length){er=arguments[1];if(er instanceof Error){throw er;// Unhandled 'error' event
}else{// At least give some kind of context to the user
var err=new Error('Uncaught, unspecified "error" event. ('+er+')');err.context=er;throw err;}}}handler=this._events[type];if(isUndefined(handler))return false;if(isFunction(handler)){switch(arguments.length){// fast cases
case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;// slower
default:args=Array.prototype.slice.call(arguments,1);handler.apply(this,args);}}else if(isObject(handler)){args=Array.prototype.slice.call(arguments,1);listeners=handler.slice();len=listeners.length;for(i=0;i<len;i++){listeners[i].apply(this,args);}}return true;};EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError('listener must be a function');if(!this._events)this._events={};// To avoid recursion in the case that type === "newListener"! Before
// adding it to the listeners, first emit "newListener".
if(this._events.newListener)this.emit('newListener',type,isFunction(listener.listener)?listener.listener:listener);if(!this._events[type])// Optimize the case of one listener. Don't need the extra array object.
this._events[type]=listener;else if(isObject(this._events[type]))// If we've already got an array, just append.
this._events[type].push(listener);else// Adding the second element, need to change to array.
this._events[type]=[this._events[type],listener];// Check for listener leak
if(isObject(this._events[type])&&!this._events[type].warned){if(!isUndefined(this._maxListeners)){m=this._maxListeners;}else{m=EventEmitter.defaultMaxListeners;}if(m&&m>0&&this._events[type].length>m){this._events[type].warned=true;console.error('(node) warning: possible EventEmitter memory '+'leak detected. %d listeners added. '+'Use emitter.setMaxListeners() to increase limit.',this._events[type].length);if(typeof console.trace==='function'){// not supported in IE 10
console.trace();}}}return this;};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.once=function(type,listener){if(!isFunction(listener))throw TypeError('listener must be a function');var fired=false;function g(){this.removeListener(type,g);if(!fired){fired=true;listener.apply(this,arguments);}}g.listener=listener;this.on(type,g);return this;};// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError('listener must be a function');if(!this._events||!this._events[type])return this;list=this._events[type];length=list.length;position=-1;if(list===listener||isFunction(list.listener)&&list.listener===listener){delete this._events[type];if(this._events.removeListener)this.emit('removeListener',type,listener);}else if(isObject(list)){for(i=length;i-->0;){if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break;}}if(position<0)return this;if(list.length===1){list.length=0;delete this._events[type];}else{list.splice(position,1);}if(this._events.removeListener)this.emit('removeListener',type,listener);}return this;};EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;// not listening for removeListener, no need to emit
if(!this._events.removeListener){if(arguments.length===0)this._events={};else if(this._events[type])delete this._events[type];return this;}// emit removeListener for all listeners on all events
if(arguments.length===0){for(key in this._events){if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events={};return this;}listeners=this._events[type];if(isFunction(listeners)){this.removeListener(type,listeners);}else if(listeners){// LIFO order
while(listeners.length){this.removeListener(type,listeners[listeners.length-1]);}}delete this._events[type];return this;};EventEmitter.prototype.listeners=function(type){var ret;if(!this._events||!this._events[type])ret=[];else if(isFunction(this._events[type]))ret=[this._events[type]];else ret=this._events[type].slice();return ret;};EventEmitter.prototype.listenerCount=function(type){if(this._events){var evlistener=this._events[type];if(isFunction(evlistener))return 1;else if(evlistener)return evlistener.length;}return 0;};EventEmitter.listenerCount=function(emitter,type){return emitter.listenerCount(type);};function isFunction(arg){return typeof arg==='function';}function isNumber(arg){return typeof arg==='number';}function isObject(arg){return(typeof arg==='undefined'?'undefined':_typeof(arg))==='object'&&arg!==null;}function isUndefined(arg){return arg===void 0;}

},{}],3:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var DataView=getNative(root,'DataView');module.exports=DataView;

},{"./_getNative":59,"./_root":95}],4:[function(require,module,exports){
'use strict';var hashClear=require('./_hashClear'),hashDelete=require('./_hashDelete'),hashGet=require('./_hashGet'),hashHas=require('./_hashHas'),hashSet=require('./_hashSet');/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;module.exports=Hash;

},{"./_hashClear":65,"./_hashDelete":66,"./_hashGet":67,"./_hashHas":68,"./_hashSet":69}],5:[function(require,module,exports){
'use strict';var listCacheClear=require('./_listCacheClear'),listCacheDelete=require('./_listCacheDelete'),listCacheGet=require('./_listCacheGet'),listCacheHas=require('./_listCacheHas'),listCacheSet=require('./_listCacheSet');/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;module.exports=ListCache;

},{"./_listCacheClear":76,"./_listCacheDelete":77,"./_listCacheGet":78,"./_listCacheHas":79,"./_listCacheSet":80}],6:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var Map=getNative(root,'Map');module.exports=Map;

},{"./_getNative":59,"./_root":95}],7:[function(require,module,exports){
'use strict';var mapCacheClear=require('./_mapCacheClear'),mapCacheDelete=require('./_mapCacheDelete'),mapCacheGet=require('./_mapCacheGet'),mapCacheHas=require('./_mapCacheHas'),mapCacheSet=require('./_mapCacheSet');/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;module.exports=MapCache;

},{"./_mapCacheClear":81,"./_mapCacheDelete":82,"./_mapCacheGet":83,"./_mapCacheHas":84,"./_mapCacheSet":85}],8:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var Promise=getNative(root,'Promise');module.exports=Promise;

},{"./_getNative":59,"./_root":95}],9:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var Set=getNative(root,'Set');module.exports=Set;

},{"./_getNative":59,"./_root":95}],10:[function(require,module,exports){
'use strict';var MapCache=require('./_MapCache'),setCacheAdd=require('./_setCacheAdd'),setCacheHas=require('./_setCacheHas');/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;module.exports=SetCache;

},{"./_MapCache":7,"./_setCacheAdd":96,"./_setCacheHas":97}],11:[function(require,module,exports){
'use strict';var ListCache=require('./_ListCache'),stackClear=require('./_stackClear'),stackDelete=require('./_stackDelete'),stackGet=require('./_stackGet'),stackHas=require('./_stackHas'),stackSet=require('./_stackSet');/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;module.exports=Stack;

},{"./_ListCache":5,"./_stackClear":99,"./_stackDelete":100,"./_stackGet":101,"./_stackHas":102,"./_stackSet":103}],12:[function(require,module,exports){
'use strict';var root=require('./_root');/** Built-in value references. */var _Symbol=root.Symbol;module.exports=_Symbol;

},{"./_root":95}],13:[function(require,module,exports){
'use strict';var root=require('./_root');/** Built-in value references. */var Uint8Array=root.Uint8Array;module.exports=Uint8Array;

},{"./_root":95}],14:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var WeakMap=getNative(root,'WeakMap');module.exports=WeakMap;

},{"./_getNative":59,"./_root":95}],15:[function(require,module,exports){
"use strict";/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}module.exports=arrayFilter;

},{}],16:[function(require,module,exports){
'use strict';var baseTimes=require('./_baseTimes'),isArguments=require('./isArguments'),isArray=require('./isArray'),isBuffer=require('./isBuffer'),isIndex=require('./_isIndex'),isTypedArray=require('./isTypedArray');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}module.exports=arrayLikeKeys;

},{"./_baseTimes":43,"./_isIndex":70,"./isArguments":115,"./isArray":116,"./isBuffer":118,"./isTypedArray":124}],17:[function(require,module,exports){
"use strict";/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}module.exports=arrayMap;

},{}],18:[function(require,module,exports){
"use strict";/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}module.exports=arrayPush;

},{}],19:[function(require,module,exports){
"use strict";/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}module.exports=arraySome;

},{}],20:[function(require,module,exports){
'use strict';var eq=require('./eq');/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}module.exports=assocIndexOf;

},{"./eq":110}],21:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}module.exports=baseClamp;

},{}],22:[function(require,module,exports){
'use strict';var baseForOwn=require('./_baseForOwn'),createBaseEach=require('./_createBaseEach');/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */var baseEach=createBaseEach(baseForOwn);module.exports=baseEach;

},{"./_baseForOwn":24,"./_createBaseEach":50}],23:[function(require,module,exports){
'use strict';var createBaseFor=require('./_createBaseFor');/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */var baseFor=createBaseFor();module.exports=baseFor;

},{"./_createBaseFor":51}],24:[function(require,module,exports){
'use strict';var baseFor=require('./_baseFor'),keys=require('./keys');/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}module.exports=baseForOwn;

},{"./_baseFor":23,"./keys":125}],25:[function(require,module,exports){
'use strict';var castPath=require('./_castPath'),toKey=require('./_toKey');/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}module.exports=baseGet;

},{"./_castPath":48,"./_toKey":105}],26:[function(require,module,exports){
'use strict';var arrayPush=require('./_arrayPush'),isArray=require('./isArray');/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}module.exports=baseGetAllKeys;

},{"./_arrayPush":18,"./isArray":116}],27:[function(require,module,exports){
'use strict';var _Symbol=require('./_Symbol'),getRawTag=require('./_getRawTag'),objectToString=require('./_objectToString');/** `Object#toString` result references. */var nullTag='[object Null]',undefinedTag='[object Undefined]';/** Built-in value references. */var symToStringTag=_Symbol?_Symbol.toStringTag:undefined;/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}module.exports=baseGetTag;

},{"./_Symbol":12,"./_getRawTag":60,"./_objectToString":93}],28:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */function baseHasIn(object,key){return object!=null&&key in Object(object);}module.exports=baseHasIn;

},{}],29:[function(require,module,exports){
'use strict';var baseGetTag=require('./_baseGetTag'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var argsTag='[object Arguments]';/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}module.exports=baseIsArguments;

},{"./_baseGetTag":27,"./isObjectLike":122}],30:[function(require,module,exports){
'use strict';var baseIsEqualDeep=require('./_baseIsEqualDeep'),isObjectLike=require('./isObjectLike');/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}module.exports=baseIsEqual;

},{"./_baseIsEqualDeep":31,"./isObjectLike":122}],31:[function(require,module,exports){
'use strict';var Stack=require('./_Stack'),equalArrays=require('./_equalArrays'),equalByTag=require('./_equalByTag'),equalObjects=require('./_equalObjects'),getTag=require('./_getTag'),isArray=require('./isArray'),isBuffer=require('./isBuffer'),isTypedArray=require('./isTypedArray');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1;/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',objectTag='[object Object]';/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}module.exports=baseIsEqualDeep;

},{"./_Stack":11,"./_equalArrays":52,"./_equalByTag":53,"./_equalObjects":54,"./_getTag":62,"./isArray":116,"./isBuffer":118,"./isTypedArray":124}],32:[function(require,module,exports){
'use strict';var Stack=require('./_Stack'),baseIsEqual=require('./_baseIsEqual');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}module.exports=baseIsMatch;

},{"./_Stack":11,"./_baseIsEqual":30}],33:[function(require,module,exports){
'use strict';var isFunction=require('./isFunction'),isMasked=require('./_isMasked'),isObject=require('./isObject'),toSource=require('./_toSource');/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used for built-in method references. */var funcProto=Function.prototype,objectProto=Object.prototype;/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}module.exports=baseIsNative;

},{"./_isMasked":73,"./_toSource":106,"./isFunction":119,"./isObject":121}],34:[function(require,module,exports){
'use strict';var baseGetTag=require('./_baseGetTag'),isLength=require('./isLength'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',mapTag='[object Map]',numberTag='[object Number]',objectTag='[object Object]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',weakMapTag='[object WeakMap]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}module.exports=baseIsTypedArray;

},{"./_baseGetTag":27,"./isLength":120,"./isObjectLike":122}],35:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var baseMatches=require('./_baseMatches'),baseMatchesProperty=require('./_baseMatchesProperty'),identity=require('./identity'),isArray=require('./isArray'),property=require('./property');/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if((typeof value==='undefined'?'undefined':_typeof(value))=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}module.exports=baseIteratee;

},{"./_baseMatches":39,"./_baseMatchesProperty":40,"./identity":114,"./isArray":116,"./property":130}],36:[function(require,module,exports){
'use strict';var isPrototype=require('./_isPrototype'),nativeKeys=require('./_nativeKeys');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}module.exports=baseKeys;

},{"./_isPrototype":74,"./_nativeKeys":90}],37:[function(require,module,exports){
'use strict';var isObject=require('./isObject'),isPrototype=require('./_isPrototype'),nativeKeysIn=require('./_nativeKeysIn');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}module.exports=baseKeysIn;

},{"./_isPrototype":74,"./_nativeKeysIn":91,"./isObject":121}],38:[function(require,module,exports){
'use strict';var baseEach=require('./_baseEach'),isArrayLike=require('./isArrayLike');/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}module.exports=baseMap;

},{"./_baseEach":22,"./isArrayLike":117}],39:[function(require,module,exports){
'use strict';var baseIsMatch=require('./_baseIsMatch'),getMatchData=require('./_getMatchData'),matchesStrictComparable=require('./_matchesStrictComparable');/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}module.exports=baseMatches;

},{"./_baseIsMatch":32,"./_getMatchData":58,"./_matchesStrictComparable":87}],40:[function(require,module,exports){
'use strict';var baseIsEqual=require('./_baseIsEqual'),get=require('./get'),hasIn=require('./hasIn'),isKey=require('./_isKey'),isStrictComparable=require('./_isStrictComparable'),matchesStrictComparable=require('./_matchesStrictComparable'),toKey=require('./_toKey');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}module.exports=baseMatchesProperty;

},{"./_baseIsEqual":30,"./_isKey":71,"./_isStrictComparable":75,"./_matchesStrictComparable":87,"./_toKey":105,"./get":112,"./hasIn":113}],41:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}module.exports=baseProperty;

},{}],42:[function(require,module,exports){
'use strict';var baseGet=require('./_baseGet');/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}module.exports=basePropertyDeep;

},{"./_baseGet":25}],43:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}module.exports=baseTimes;

},{}],44:[function(require,module,exports){
'use strict';var _Symbol=require('./_Symbol'),arrayMap=require('./_arrayMap'),isArray=require('./isArray'),isSymbol=require('./isSymbol');/** Used as references for various `Number` constants. */var INFINITY=1/0;/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}module.exports=baseToString;

},{"./_Symbol":12,"./_arrayMap":17,"./isArray":116,"./isSymbol":123}],45:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */function baseUnary(func){return function(value){return func(value);};}module.exports=baseUnary;

},{}],46:[function(require,module,exports){
"use strict";/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function cacheHas(cache,key){return cache.has(key);}module.exports=cacheHas;

},{}],47:[function(require,module,exports){
'use strict';var identity=require('./identity');/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */function castFunction(value){return typeof value=='function'?value:identity;}module.exports=castFunction;

},{"./identity":114}],48:[function(require,module,exports){
'use strict';var isArray=require('./isArray'),isKey=require('./_isKey'),stringToPath=require('./_stringToPath'),toString=require('./toString');/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}module.exports=castPath;

},{"./_isKey":71,"./_stringToPath":104,"./isArray":116,"./toString":135}],49:[function(require,module,exports){
'use strict';var root=require('./_root');/** Used to detect overreaching core-js shims. */var coreJsData=root['__core-js_shared__'];module.exports=coreJsData;

},{"./_root":95}],50:[function(require,module,exports){
'use strict';var isArrayLike=require('./isArrayLike');/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}module.exports=createBaseEach;

},{"./isArrayLike":117}],51:[function(require,module,exports){
"use strict";/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}module.exports=createBaseFor;

},{}],52:[function(require,module,exports){
'use strict';var SetCache=require('./_SetCache'),arraySome=require('./_arraySome'),cacheHas=require('./_cacheHas');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}module.exports=equalArrays;

},{"./_SetCache":10,"./_arraySome":19,"./_cacheHas":46}],53:[function(require,module,exports){
'use strict';var _Symbol=require('./_Symbol'),Uint8Array=require('./_Uint8Array'),eq=require('./eq'),equalArrays=require('./_equalArrays'),mapToArray=require('./_mapToArray'),setToArray=require('./_setToArray');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** `Object#toString` result references. */var boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',mapTag='[object Map]',numberTag='[object Number]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]';/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined;/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}module.exports=equalByTag;

},{"./_Symbol":12,"./_Uint8Array":13,"./_equalArrays":52,"./_mapToArray":86,"./_setToArray":98,"./eq":110}],54:[function(require,module,exports){
'use strict';var getAllKeys=require('./_getAllKeys');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1;/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}module.exports=equalObjects;

},{"./_getAllKeys":56}],55:[function(require,module,exports){
(function (global){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/** Detect free variable `global` from Node.js. */var freeGlobal=(typeof global==='undefined'?'undefined':_typeof(global))=='object'&&global&&global.Object===Object&&global;module.exports=freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],56:[function(require,module,exports){
'use strict';var baseGetAllKeys=require('./_baseGetAllKeys'),getSymbols=require('./_getSymbols'),keys=require('./keys');/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}module.exports=getAllKeys;

},{"./_baseGetAllKeys":26,"./_getSymbols":61,"./keys":125}],57:[function(require,module,exports){
'use strict';var isKeyable=require('./_isKeyable');/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}module.exports=getMapData;

},{"./_isKeyable":72}],58:[function(require,module,exports){
'use strict';var isStrictComparable=require('./_isStrictComparable'),keys=require('./keys');/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}module.exports=getMatchData;

},{"./_isStrictComparable":75,"./keys":125}],59:[function(require,module,exports){
'use strict';var baseIsNative=require('./_baseIsNative'),getValue=require('./_getValue');/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}module.exports=getNative;

},{"./_baseIsNative":33,"./_getValue":63}],60:[function(require,module,exports){
'use strict';var _Symbol=require('./_Symbol');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var nativeObjectToString=objectProto.toString;/** Built-in value references. */var symToStringTag=_Symbol?_Symbol.toStringTag:undefined;/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}module.exports=getRawTag;

},{"./_Symbol":12}],61:[function(require,module,exports){
'use strict';var arrayFilter=require('./_arrayFilter'),stubArray=require('./stubArray');/** Used for built-in method references. */var objectProto=Object.prototype;/** Built-in value references. */var propertyIsEnumerable=objectProto.propertyIsEnumerable;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeGetSymbols=Object.getOwnPropertySymbols;/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};module.exports=getSymbols;

},{"./_arrayFilter":15,"./stubArray":131}],62:[function(require,module,exports){
'use strict';var DataView=require('./_DataView'),Map=require('./_Map'),Promise=require('./_Promise'),Set=require('./_Set'),WeakMap=require('./_WeakMap'),baseGetTag=require('./_baseGetTag'),toSource=require('./_toSource');/** `Object#toString` result references. */var mapTag='[object Map]',objectTag='[object Object]',promiseTag='[object Promise]',setTag='[object Set]',weakMapTag='[object WeakMap]';var dataViewTag='[object DataView]';/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}module.exports=getTag;

},{"./_DataView":3,"./_Map":6,"./_Promise":8,"./_Set":9,"./_WeakMap":14,"./_baseGetTag":27,"./_toSource":106}],63:[function(require,module,exports){
"use strict";/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function getValue(object,key){return object==null?undefined:object[key];}module.exports=getValue;

},{}],64:[function(require,module,exports){
'use strict';var castPath=require('./_castPath'),isArguments=require('./isArguments'),isArray=require('./isArray'),isIndex=require('./_isIndex'),isLength=require('./isLength'),toKey=require('./_toKey');/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}module.exports=hasPath;

},{"./_castPath":48,"./_isIndex":70,"./_toKey":105,"./isArguments":115,"./isArray":116,"./isLength":120}],65:[function(require,module,exports){
'use strict';var nativeCreate=require('./_nativeCreate');/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}module.exports=hashClear;

},{"./_nativeCreate":89}],66:[function(require,module,exports){
"use strict";/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}module.exports=hashDelete;

},{}],67:[function(require,module,exports){
'use strict';var nativeCreate=require('./_nativeCreate');/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}module.exports=hashGet;

},{"./_nativeCreate":89}],68:[function(require,module,exports){
'use strict';var nativeCreate=require('./_nativeCreate');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}module.exports=hashHas;

},{"./_nativeCreate":89}],69:[function(require,module,exports){
'use strict';var nativeCreate=require('./_nativeCreate');/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}module.exports=hashSet;

},{"./_nativeCreate":89}],70:[function(require,module,exports){
'use strict';/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */function isIndex(value,length){length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(typeof value=='number'||reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}module.exports=isIndex;

},{}],71:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var isArray=require('./isArray'),isSymbol=require('./isSymbol');/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/;/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value==='undefined'?'undefined':_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}module.exports=isKey;

},{"./isArray":116,"./isSymbol":123}],72:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */function isKeyable(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}module.exports=isKeyable;

},{}],73:[function(require,module,exports){
'use strict';var coreJsData=require('./_coreJsData');/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}module.exports=isMasked;

},{"./_coreJsData":49}],74:[function(require,module,exports){
'use strict';/** Used for built-in method references. */var objectProto=Object.prototype;/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}module.exports=isPrototype;

},{}],75:[function(require,module,exports){
'use strict';var isObject=require('./isObject');/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */function isStrictComparable(value){return value===value&&!isObject(value);}module.exports=isStrictComparable;

},{"./isObject":121}],76:[function(require,module,exports){
"use strict";/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */function listCacheClear(){this.__data__=[];this.size=0;}module.exports=listCacheClear;

},{}],77:[function(require,module,exports){
'use strict';var assocIndexOf=require('./_assocIndexOf');/** Used for built-in method references. */var arrayProto=Array.prototype;/** Built-in value references. */var splice=arrayProto.splice;/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}module.exports=listCacheDelete;

},{"./_assocIndexOf":20}],78:[function(require,module,exports){
'use strict';var assocIndexOf=require('./_assocIndexOf');/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}module.exports=listCacheGet;

},{"./_assocIndexOf":20}],79:[function(require,module,exports){
'use strict';var assocIndexOf=require('./_assocIndexOf');/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}module.exports=listCacheHas;

},{"./_assocIndexOf":20}],80:[function(require,module,exports){
'use strict';var assocIndexOf=require('./_assocIndexOf');/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}module.exports=listCacheSet;

},{"./_assocIndexOf":20}],81:[function(require,module,exports){
'use strict';var Hash=require('./_Hash'),ListCache=require('./_ListCache'),Map=require('./_Map');/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}module.exports=mapCacheClear;

},{"./_Hash":4,"./_ListCache":5,"./_Map":6}],82:[function(require,module,exports){
'use strict';var getMapData=require('./_getMapData');/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}module.exports=mapCacheDelete;

},{"./_getMapData":57}],83:[function(require,module,exports){
'use strict';var getMapData=require('./_getMapData');/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function mapCacheGet(key){return getMapData(this,key).get(key);}module.exports=mapCacheGet;

},{"./_getMapData":57}],84:[function(require,module,exports){
'use strict';var getMapData=require('./_getMapData');/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function mapCacheHas(key){return getMapData(this,key).has(key);}module.exports=mapCacheHas;

},{"./_getMapData":57}],85:[function(require,module,exports){
'use strict';var getMapData=require('./_getMapData');/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}module.exports=mapCacheSet;

},{"./_getMapData":57}],86:[function(require,module,exports){
"use strict";/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}module.exports=mapToArray;

},{}],87:[function(require,module,exports){
"use strict";/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}module.exports=matchesStrictComparable;

},{}],88:[function(require,module,exports){
'use strict';var memoize=require('./memoize');/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}module.exports=memoizeCapped;

},{"./memoize":128}],89:[function(require,module,exports){
'use strict';var getNative=require('./_getNative');/* Built-in method references that are verified to be native. */var nativeCreate=getNative(Object,'create');module.exports=nativeCreate;

},{"./_getNative":59}],90:[function(require,module,exports){
'use strict';var overArg=require('./_overArg');/* Built-in method references for those with the same name as other `lodash` methods. */var nativeKeys=overArg(Object.keys,Object);module.exports=nativeKeys;

},{"./_overArg":94}],91:[function(require,module,exports){
"use strict";/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}module.exports=nativeKeysIn;

},{}],92:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var freeGlobal=require('./_freeGlobal');/** Detect free variable `exports`. */var freeExports=(typeof exports==='undefined'?'undefined':_typeof(exports))=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&(typeof module==='undefined'?'undefined':_typeof(module))=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();module.exports=nodeUtil;

},{"./_freeGlobal":55}],93:[function(require,module,exports){
"use strict";/** Used for built-in method references. */var objectProto=Object.prototype;/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var nativeObjectToString=objectProto.toString;/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */function objectToString(value){return nativeObjectToString.call(value);}module.exports=objectToString;

},{}],94:[function(require,module,exports){
"use strict";/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */function overArg(func,transform){return function(arg){return func(transform(arg));};}module.exports=overArg;

},{}],95:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var freeGlobal=require('./_freeGlobal');/** Detect free variable `self`. */var freeSelf=(typeof self==='undefined'?'undefined':_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();module.exports=root;

},{"./_freeGlobal":55}],96:[function(require,module,exports){
'use strict';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}module.exports=setCacheAdd;

},{}],97:[function(require,module,exports){
"use strict";/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */function setCacheHas(value){return this.__data__.has(value);}module.exports=setCacheHas;

},{}],98:[function(require,module,exports){
"use strict";/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}module.exports=setToArray;

},{}],99:[function(require,module,exports){
'use strict';var ListCache=require('./_ListCache');/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */function stackClear(){this.__data__=new ListCache();this.size=0;}module.exports=stackClear;

},{"./_ListCache":5}],100:[function(require,module,exports){
'use strict';/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}module.exports=stackDelete;

},{}],101:[function(require,module,exports){
"use strict";/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function stackGet(key){return this.__data__.get(key);}module.exports=stackGet;

},{}],102:[function(require,module,exports){
"use strict";/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function stackHas(key){return this.__data__.has(key);}module.exports=stackHas;

},{}],103:[function(require,module,exports){
'use strict';var ListCache=require('./_ListCache'),Map=require('./_Map'),MapCache=require('./_MapCache');/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}module.exports=stackSet;

},{"./_ListCache":5,"./_Map":6,"./_MapCache":7}],104:[function(require,module,exports){
'use strict';var memoizeCapped=require('./_memoizeCapped');/** Used to match property names within property paths. */var reLeadingDot=/^\./,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */var stringToPath=memoizeCapped(function(string){var result=[];if(reLeadingDot.test(string)){result.push('');}string.replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,'$1'):number||match);});return result;});module.exports=stringToPath;

},{"./_memoizeCapped":88}],105:[function(require,module,exports){
'use strict';var isSymbol=require('./isSymbol');/** Used as references for various `Number` constants. */var INFINITY=1/0;/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}module.exports=toKey;

},{"./isSymbol":123}],106:[function(require,module,exports){
'use strict';/** Used for built-in method references. */var funcProto=Function.prototype;/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}module.exports=toSource;

},{}],107:[function(require,module,exports){
'use strict';var baseClamp=require('./_baseClamp'),toNumber=require('./toNumber');/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}module.exports=clamp;

},{"./_baseClamp":21,"./toNumber":134}],108:[function(require,module,exports){
'use strict';var isObject=require('./isObject'),now=require('./now'),toNumber=require('./toNumber');/** Error message constants. */var FUNC_ERROR_TEXT='Expected a function';/* Built-in method references for those with the same name as other `lodash` methods. */var nativeMax=Math.max,nativeMin=Math.min;/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,result=wait-timeSinceLastCall;return maxing?nativeMin(result,maxWait-timeSinceLastInvoke):result;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}module.exports=debounce;

},{"./isObject":121,"./now":129,"./toNumber":134}],109:[function(require,module,exports){
"use strict";/**
 * Checks `value` to determine whether a default value should be returned in
 * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
 * or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.14.0
 * @category Util
 * @param {*} value The value to check.
 * @param {*} defaultValue The default value.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * _.defaultTo(1, 10);
 * // => 1
 *
 * _.defaultTo(undefined, 10);
 * // => 10
 */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}module.exports=defaultTo;

},{}],110:[function(require,module,exports){
"use strict";/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */function eq(value,other){return value===other||value!==value&&other!==other;}module.exports=eq;

},{}],111:[function(require,module,exports){
'use strict';var baseFor=require('./_baseFor'),castFunction=require('./_castFunction'),keysIn=require('./keysIn');/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */function forIn(object,iteratee){return object==null?object:baseFor(object,castFunction(iteratee),keysIn);}module.exports=forIn;

},{"./_baseFor":23,"./_castFunction":47,"./keysIn":126}],112:[function(require,module,exports){
'use strict';var baseGet=require('./_baseGet');/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}module.exports=get;

},{"./_baseGet":25}],113:[function(require,module,exports){
'use strict';var baseHasIn=require('./_baseHasIn'),hasPath=require('./_hasPath');/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}module.exports=hasIn;

},{"./_baseHasIn":28,"./_hasPath":64}],114:[function(require,module,exports){
"use strict";/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */function identity(value){return value;}module.exports=identity;

},{}],115:[function(require,module,exports){
'use strict';var baseIsArguments=require('./_baseIsArguments'),isObjectLike=require('./isObjectLike');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Built-in value references. */var propertyIsEnumerable=objectProto.propertyIsEnumerable;/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};module.exports=isArguments;

},{"./_baseIsArguments":29,"./isObjectLike":122}],116:[function(require,module,exports){
"use strict";/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;module.exports=isArray;

},{}],117:[function(require,module,exports){
'use strict';var isFunction=require('./isFunction'),isLength=require('./isLength');/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}module.exports=isArrayLike;

},{"./isFunction":119,"./isLength":120}],118:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var root=require('./_root'),stubFalse=require('./stubFalse');/** Detect free variable `exports`. */var freeExports=(typeof exports==='undefined'?'undefined':_typeof(exports))=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&(typeof module==='undefined'?'undefined':_typeof(module))=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Built-in value references. */var Buffer=moduleExports?root.Buffer:undefined;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeIsBuffer=Buffer?Buffer.isBuffer:undefined;/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */var isBuffer=nativeIsBuffer||stubFalse;module.exports=isBuffer;

},{"./_root":95,"./stubFalse":132}],119:[function(require,module,exports){
'use strict';var baseGetTag=require('./_baseGetTag'),isObject=require('./isObject');/** `Object#toString` result references. */var asyncTag='[object AsyncFunction]',funcTag='[object Function]',genTag='[object GeneratorFunction]',proxyTag='[object Proxy]';/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}module.exports=isFunction;

},{"./_baseGetTag":27,"./isObject":121}],120:[function(require,module,exports){
'use strict';/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}module.exports=isLength;

},{}],121:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */function isObject(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return value!=null&&(type=='object'||type=='function');}module.exports=isObject;

},{}],122:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return value!=null&&(typeof value==='undefined'?'undefined':_typeof(value))=='object';}module.exports=isObjectLike;

},{}],123:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var baseGetTag=require('./_baseGetTag'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var symbolTag='[object Symbol]';/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */function isSymbol(value){return(typeof value==='undefined'?'undefined':_typeof(value))=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}module.exports=isSymbol;

},{"./_baseGetTag":27,"./isObjectLike":122}],124:[function(require,module,exports){
'use strict';var baseIsTypedArray=require('./_baseIsTypedArray'),baseUnary=require('./_baseUnary'),nodeUtil=require('./_nodeUtil');/* Node.js helper references. */var nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;module.exports=isTypedArray;

},{"./_baseIsTypedArray":34,"./_baseUnary":45,"./_nodeUtil":92}],125:[function(require,module,exports){
'use strict';var arrayLikeKeys=require('./_arrayLikeKeys'),baseKeys=require('./_baseKeys'),isArrayLike=require('./isArrayLike');/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}module.exports=keys;

},{"./_arrayLikeKeys":16,"./_baseKeys":36,"./isArrayLike":117}],126:[function(require,module,exports){
'use strict';var arrayLikeKeys=require('./_arrayLikeKeys'),baseKeysIn=require('./_baseKeysIn'),isArrayLike=require('./isArrayLike');/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}module.exports=keysIn;

},{"./_arrayLikeKeys":16,"./_baseKeysIn":37,"./isArrayLike":117}],127:[function(require,module,exports){
'use strict';var arrayMap=require('./_arrayMap'),baseIteratee=require('./_baseIteratee'),baseMap=require('./_baseMap'),isArray=require('./isArray');/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,baseIteratee(iteratee,3));}module.exports=map;

},{"./_arrayMap":17,"./_baseIteratee":35,"./_baseMap":38,"./isArray":116}],128:[function(require,module,exports){
'use strict';var MapCache=require('./_MapCache');/** Error message constants. */var FUNC_ERROR_TEXT='Expected a function';/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;module.exports=memoize;

},{"./_MapCache":7}],129:[function(require,module,exports){
'use strict';var root=require('./_root');/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */var now=function now(){return root.Date.now();};module.exports=now;

},{"./_root":95}],130:[function(require,module,exports){
'use strict';var baseProperty=require('./_baseProperty'),basePropertyDeep=require('./_basePropertyDeep'),isKey=require('./_isKey'),toKey=require('./_toKey');/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}module.exports=property;

},{"./_baseProperty":41,"./_basePropertyDeep":42,"./_isKey":71,"./_toKey":105}],131:[function(require,module,exports){
"use strict";/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */function stubArray(){return[];}module.exports=stubArray;

},{}],132:[function(require,module,exports){
"use strict";/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */function stubFalse(){return false;}module.exports=stubFalse;

},{}],133:[function(require,module,exports){
'use strict';var debounce=require('./debounce'),isObject=require('./isObject');/** Error message constants. */var FUNC_ERROR_TEXT='Expected a function';/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}module.exports=throttle;

},{"./debounce":108,"./isObject":121}],134:[function(require,module,exports){
'use strict';var isObject=require('./isObject'),isSymbol=require('./isSymbol');/** Used as references for various `Number` constants. */var NAN=0/0;/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Built-in method references without a dependency on `root`. */var freeParseInt=parseInt;/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}module.exports=toNumber;

},{"./isObject":121,"./isSymbol":123}],135:[function(require,module,exports){
'use strict';var baseToString=require('./_baseToString');/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */function toString(value){return value==null?'':baseToString(value);}module.exports=toString;

},{"./_baseToString":44}],136:[function(require,module,exports){
'use strict';module.exports=partialSort;// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]
function partialSort(arr,k,left,right,compare){left=left||0;right=right||arr.length-1;compare=compare||defaultCompare;while(right>left){if(right-left>600){var n=right-left+1;var m=k-left+1;var z=Math.log(n);var s=0.5*Math.exp(2*z/3);var sd=0.5*Math.sqrt(z*s*(n-s)/n)*(m-n/2<0?-1:1);var newLeft=Math.max(left,Math.floor(k-m*s/n+sd));var newRight=Math.min(right,Math.floor(k+(n-m)*s/n+sd));partialSort(arr,k,newLeft,newRight,compare);}var t=arr[k];var i=left;var j=right;swap(arr,left,k);if(compare(arr[right],t)>0)swap(arr,left,right);while(i<j){swap(arr,i,j);i++;j--;while(compare(arr[i],t)<0){i++;}while(compare(arr[j],t)>0){j--;}}if(compare(arr[left],t)===0)swap(arr,left,j);else{j++;swap(arr,j,right);}if(j<=k)left=j+1;if(k<=j)right=j-1;}}function swap(arr,i,j){var tmp=arr[i];arr[i]=arr[j];arr[j]=tmp;}function defaultCompare(a,b){return a<b?-1:a>b?1:0;}

},{}],137:[function(require,module,exports){
'use strict';module.exports=rbush;var quickselect=require('quickselect');function rbush(maxEntries,format){if(!(this instanceof rbush))return new rbush(maxEntries,format);// max entries in a node is 9 by default; min node fill is 40% for best performance
this._maxEntries=Math.max(4,maxEntries||9);this._minEntries=Math.max(2,Math.ceil(this._maxEntries*0.4));if(format){this._initFormat(format);}this.clear();}rbush.prototype={all:function all(){return this._all(this.data,[]);},search:function search(bbox){var node=this.data,result=[],toBBox=this.toBBox;if(!intersects(bbox,node))return result;var nodesToSearch=[],i,len,child,childBBox;while(node){for(i=0,len=node.children.length;i<len;i++){child=node.children[i];childBBox=node.leaf?toBBox(child):child;if(intersects(bbox,childBBox)){if(node.leaf)result.push(child);else if(contains(bbox,childBBox))this._all(child,result);else nodesToSearch.push(child);}}node=nodesToSearch.pop();}return result;},collides:function collides(bbox){var node=this.data,toBBox=this.toBBox;if(!intersects(bbox,node))return false;var nodesToSearch=[],i,len,child,childBBox;while(node){for(i=0,len=node.children.length;i<len;i++){child=node.children[i];childBBox=node.leaf?toBBox(child):child;if(intersects(bbox,childBBox)){if(node.leaf||contains(bbox,childBBox))return true;nodesToSearch.push(child);}}node=nodesToSearch.pop();}return false;},load:function load(data){if(!(data&&data.length))return this;if(data.length<this._minEntries){for(var i=0,len=data.length;i<len;i++){this.insert(data[i]);}return this;}// recursively build the tree with the given data from stratch using OMT algorithm
var node=this._build(data.slice(),0,data.length-1,0);if(!this.data.children.length){// save as is if tree is empty
this.data=node;}else if(this.data.height===node.height){// split root if trees have the same height
this._splitRoot(this.data,node);}else{if(this.data.height<node.height){// swap trees if inserted one is bigger
var tmpNode=this.data;this.data=node;node=tmpNode;}// insert the small tree into the large tree at appropriate level
this._insert(node,this.data.height-node.height-1,true);}return this;},insert:function insert(item){if(item)this._insert(item,this.data.height-1);return this;},clear:function clear(){this.data=createNode([]);return this;},remove:function remove(item,equalsFn){if(!item)return this;var node=this.data,bbox=this.toBBox(item),path=[],indexes=[],i,parent,index,goingUp;// depth-first iterative tree traversal
while(node||path.length){if(!node){// go up
node=path.pop();parent=path[path.length-1];i=indexes.pop();goingUp=true;}if(node.leaf){// check current node
index=findItem(item,node.children,equalsFn);if(index!==-1){// item found, remove the item and condense tree upwards
node.children.splice(index,1);path.push(node);this._condense(path);return this;}}if(!goingUp&&!node.leaf&&contains(node,bbox)){// go down
path.push(node);indexes.push(i);i=0;parent=node;node=node.children[0];}else if(parent){// go right
i++;node=parent.children[i];goingUp=false;}else node=null;// nothing found
}return this;},toBBox:function toBBox(item){return item;},compareMinX:compareNodeMinX,compareMinY:compareNodeMinY,toJSON:function toJSON(){return this.data;},fromJSON:function fromJSON(data){this.data=data;return this;},_all:function _all(node,result){var nodesToSearch=[];while(node){if(node.leaf)result.push.apply(result,node.children);else nodesToSearch.push.apply(nodesToSearch,node.children);node=nodesToSearch.pop();}return result;},_build:function _build(items,left,right,height){var N=right-left+1,M=this._maxEntries,node;if(N<=M){// reached leaf level; return leaf
node=createNode(items.slice(left,right+1));calcBBox(node,this.toBBox);return node;}if(!height){// target height of the bulk-loaded tree
height=Math.ceil(Math.log(N)/Math.log(M));// target number of root entries to maximize storage utilization
M=Math.ceil(N/Math.pow(M,height-1));}node=createNode([]);node.leaf=false;node.height=height;// split the items into M mostly square tiles
var N2=Math.ceil(N/M),N1=N2*Math.ceil(Math.sqrt(M)),i,j,right2,right3;multiSelect(items,left,right,N1,this.compareMinX);for(i=left;i<=right;i+=N1){right2=Math.min(i+N1-1,right);multiSelect(items,i,right2,N2,this.compareMinY);for(j=i;j<=right2;j+=N2){right3=Math.min(j+N2-1,right2);// pack each entry recursively
node.children.push(this._build(items,j,right3,height-1));}}calcBBox(node,this.toBBox);return node;},_chooseSubtree:function _chooseSubtree(bbox,node,level,path){var i,len,child,targetNode,area,enlargement,minArea,minEnlargement;while(true){path.push(node);if(node.leaf||path.length-1===level)break;minArea=minEnlargement=Infinity;for(i=0,len=node.children.length;i<len;i++){child=node.children[i];area=bboxArea(child);enlargement=enlargedArea(bbox,child)-area;// choose entry with the least area enlargement
if(enlargement<minEnlargement){minEnlargement=enlargement;minArea=area<minArea?area:minArea;targetNode=child;}else if(enlargement===minEnlargement){// otherwise choose one with the smallest area
if(area<minArea){minArea=area;targetNode=child;}}}node=targetNode||node.children[0];}return node;},_insert:function _insert(item,level,isNode){var toBBox=this.toBBox,bbox=isNode?item:toBBox(item),insertPath=[];// find the best node for accommodating the item, saving all nodes along the path too
var node=this._chooseSubtree(bbox,this.data,level,insertPath);// put the item into the node
node.children.push(item);extend(node,bbox);// split on node overflow; propagate upwards if necessary
while(level>=0){if(insertPath[level].children.length>this._maxEntries){this._split(insertPath,level);level--;}else break;}// adjust bboxes along the insertion path
this._adjustParentBBoxes(bbox,insertPath,level);},// split overflowed node into two
_split:function _split(insertPath,level){var node=insertPath[level],M=node.children.length,m=this._minEntries;this._chooseSplitAxis(node,m,M);var splitIndex=this._chooseSplitIndex(node,m,M);var newNode=createNode(node.children.splice(splitIndex,node.children.length-splitIndex));newNode.height=node.height;newNode.leaf=node.leaf;calcBBox(node,this.toBBox);calcBBox(newNode,this.toBBox);if(level)insertPath[level-1].children.push(newNode);else this._splitRoot(node,newNode);},_splitRoot:function _splitRoot(node,newNode){// split root node
this.data=createNode([node,newNode]);this.data.height=node.height+1;this.data.leaf=false;calcBBox(this.data,this.toBBox);},_chooseSplitIndex:function _chooseSplitIndex(node,m,M){var i,bbox1,bbox2,overlap,area,minOverlap,minArea,index;minOverlap=minArea=Infinity;for(i=m;i<=M-m;i++){bbox1=distBBox(node,0,i,this.toBBox);bbox2=distBBox(node,i,M,this.toBBox);overlap=intersectionArea(bbox1,bbox2);area=bboxArea(bbox1)+bboxArea(bbox2);// choose distribution with minimum overlap
if(overlap<minOverlap){minOverlap=overlap;index=i;minArea=area<minArea?area:minArea;}else if(overlap===minOverlap){// otherwise choose distribution with minimum area
if(area<minArea){minArea=area;index=i;}}}return index;},// sorts node children by the best axis for split
_chooseSplitAxis:function _chooseSplitAxis(node,m,M){var compareMinX=node.leaf?this.compareMinX:compareNodeMinX,compareMinY=node.leaf?this.compareMinY:compareNodeMinY,xMargin=this._allDistMargin(node,m,M,compareMinX),yMargin=this._allDistMargin(node,m,M,compareMinY);// if total distributions margin value is minimal for x, sort by minX,
// otherwise it's already sorted by minY
if(xMargin<yMargin)node.children.sort(compareMinX);},// total margin of all possible split distributions where each node is at least m full
_allDistMargin:function _allDistMargin(node,m,M,compare){node.children.sort(compare);var toBBox=this.toBBox,leftBBox=distBBox(node,0,m,toBBox),rightBBox=distBBox(node,M-m,M,toBBox),margin=bboxMargin(leftBBox)+bboxMargin(rightBBox),i,child;for(i=m;i<M-m;i++){child=node.children[i];extend(leftBBox,node.leaf?toBBox(child):child);margin+=bboxMargin(leftBBox);}for(i=M-m-1;i>=m;i--){child=node.children[i];extend(rightBBox,node.leaf?toBBox(child):child);margin+=bboxMargin(rightBBox);}return margin;},_adjustParentBBoxes:function _adjustParentBBoxes(bbox,path,level){// adjust bboxes along the given tree path
for(var i=level;i>=0;i--){extend(path[i],bbox);}},_condense:function _condense(path){// go through the path, removing empty nodes and updating bboxes
for(var i=path.length-1,siblings;i>=0;i--){if(path[i].children.length===0){if(i>0){siblings=path[i-1].children;siblings.splice(siblings.indexOf(path[i]),1);}else this.clear();}else calcBBox(path[i],this.toBBox);}},_initFormat:function _initFormat(format){// data format (minX, minY, maxX, maxY accessors)
// uses eval-type function compilation instead of just accepting a toBBox function
// because the algorithms are very sensitive to sorting functions performance,
// so they should be dead simple and without inner calls
var compareArr=['return a',' - b',';'];this.compareMinX=new Function('a','b',compareArr.join(format[0]));this.compareMinY=new Function('a','b',compareArr.join(format[1]));this.toBBox=new Function('a','return {minX: a'+format[0]+', minY: a'+format[1]+', maxX: a'+format[2]+', maxY: a'+format[3]+'};');}};function findItem(item,items,equalsFn){if(!equalsFn)return items.indexOf(item);for(var i=0;i<items.length;i++){if(equalsFn(item,items[i]))return i;}return-1;}// calculate node's bbox from bboxes of its children
function calcBBox(node,toBBox){distBBox(node,0,node.children.length,toBBox,node);}// min bounding rectangle of node children from k to p-1
function distBBox(node,k,p,toBBox,destNode){if(!destNode)destNode=createNode(null);destNode.minX=Infinity;destNode.minY=Infinity;destNode.maxX=-Infinity;destNode.maxY=-Infinity;for(var i=k,child;i<p;i++){child=node.children[i];extend(destNode,node.leaf?toBBox(child):child);}return destNode;}function extend(a,b){a.minX=Math.min(a.minX,b.minX);a.minY=Math.min(a.minY,b.minY);a.maxX=Math.max(a.maxX,b.maxX);a.maxY=Math.max(a.maxY,b.maxY);return a;}function compareNodeMinX(a,b){return a.minX-b.minX;}function compareNodeMinY(a,b){return a.minY-b.minY;}function bboxArea(a){return(a.maxX-a.minX)*(a.maxY-a.minY);}function bboxMargin(a){return a.maxX-a.minX+(a.maxY-a.minY);}function enlargedArea(a,b){return(Math.max(b.maxX,a.maxX)-Math.min(b.minX,a.minX))*(Math.max(b.maxY,a.maxY)-Math.min(b.minY,a.minY));}function intersectionArea(a,b){var minX=Math.max(a.minX,b.minX),minY=Math.max(a.minY,b.minY),maxX=Math.min(a.maxX,b.maxX),maxY=Math.min(a.maxY,b.maxY);return Math.max(0,maxX-minX)*Math.max(0,maxY-minY);}function contains(a,b){return a.minX<=b.minX&&a.minY<=b.minY&&b.maxX<=a.maxX&&b.maxY<=a.maxY;}function intersects(a,b){return b.minX<=a.maxX&&b.minY<=a.maxY&&b.maxX>=a.minX&&b.maxY>=a.minY;}function createNode(children){return{children:children,height:1,leaf:true,minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity};}// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach
function multiSelect(arr,left,right,n,compare){var stack=[left,right],mid;while(stack.length){right=stack.pop();left=stack.pop();if(right-left<=n)continue;mid=left+Math.ceil((right-left)/n/2)*n;quickselect(arr,mid,left,right,compare);stack.push(left,mid,mid,right);}}

},{"quickselect":136}],138:[function(require,module,exports){
'use strict';/**
 * Class representing an event.
 */function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Event=/**
	 * Instantiates a new Event object.
	 *
	 * @param {Object} target - The object that fired the event.
	 * @param {number} timestamp - The timestamp when the event was created. Optional.
	 */function Event(target){var timestamp=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Date.now();_classCallCheck(this,Event);this.target=target;this.timestamp=timestamp;};module.exports=Event;

},{}],139:[function(require,module,exports){
'use strict';/**
 * Class representing an event broadcaster.
 * @private
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var EventBroadcaster=function(){/**
	 * Instantiates a new EventBroadcaster object.
	 *
	 * @param {Plot} plot - The plot to attach the broadcaster to.
	 */function EventBroadcaster(plot){_classCallCheck(this,EventBroadcaster);this.plot=plot;}/**
	 * Broadcasts the provided event type to all children of the plot.
	 *
	 * @param {string} type - The event type to broadcast.
	 */_createClass(EventBroadcaster,[{key:'broadcast',value:function broadcast(type){var _this=this;this.plot.on(type,function(event){var children=_this.plot.getSortedLayers();for(var i=children.length-1;i>=0;i--){if(!children[i].isHidden()){children[i].emit(type,event);}}});}}]);return EventBroadcaster;}();module.exports=EventBroadcaster;

},{}],140:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _DELEGATION_FUNCS;function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var EventType=require('./EventType');var MouseEvent=require('./MouseEvent');var setCursor=function setCursor(plot){plot.getContainer().style.cursor='pointer';};var resetCursor=function resetCursor(plot){plot.getContainer().style.cursor='inherit';};var copyEvent=function copyEvent(target,data,event){return new MouseEvent(target,event.originalEvent,{x:event.pos.x,y:event.pos.y},{x:event.px.x,y:event.px.y},data);};var delegateMouseMove=function delegateMouseMove(delegator,child,event,collision){// create events to delegate
var delegations=[];var prev=delegator.prevMouseover;if(!collision){//  no collision
// check for prev
if(prev){// clear cursor style
resetCursor(delegator.plot);// un-highlight previous target
prev.target.unhighlight();// `mouseout` on previous target
delegations.push({type:EventType.MOUSE_OUT,event:copyEvent(prev.target,prev.data,prev)});// unflag as prev `mouseover` target
delegator.prevMouseover=null;}}else{// collision
// check for prev
if(prev&&prev.data!==collision){// un-highlight previous target
prev.target.unhighlight();// `mouseout` on previous target
delegations.push({type:EventType.MOUSE_OUT,event:copyEvent(prev.target,prev.data,prev)});}// `mousemove` on current target
delegations.push({type:EventType.MOUSE_MOVE,event:copyEvent(child,collision,event)});// set cursor for hover
setCursor(delegator.plot);// highlight
child.highlight(collision);if(!prev||prev.data!==collision){// `mouseover` on current
delegations.push({type:EventType.MOUSE_OVER,event:copyEvent(child,collision,event)});}// flag as prev `mouseover`
delegator.prevMouseover=delegations[delegations.length-1].event;}return delegations;};var delegateMouseUp=function delegateMouseUp(delegator,child,event,collision){if(collision){return[{type:EventType.MOUSE_UP,event:copyEvent(child,collision,event)}];}return[];};var delegateMouseDown=function delegateMouseDown(delegator,child,event,collision){if(collision){return[{type:EventType.MOUSE_DOWN,event:copyEvent(child,collision,event)}];}return[];};var delegateClick=function delegateClick(delegator,child,event,collision){// check if multi-select is enabled
var multiSelect=event.originalEvent.ctrlKey||event.originalEvent.metaKey;if(collision){// select
if(!child.isSelected(collision)){if(!multiSelect){// if not multi-select, unselect the data prev selected data
delegator.prevClick.forEach(function(prev){prev.target.unselectAll();});delegator.prevClick=[];}// if not already selected, add to selection
child.select(collision,multiSelect);}else{if(multiSelect){// remove if already selected
child.unselect(collision);}}// `click` event
var delegation={type:EventType.CLICK,event:copyEvent(child,collision,event)};// flag as prev `click` target
delegator.prevClick.push(delegation.event);// return delegation
return[delegation];}else{if(delegator.prevClick.length>0){if(multiSelect){// if multi-select is held, don't clear selection, assume the
// user may have misclicked
return[];}// unselect the data
delegator.prevClick.forEach(function(prev){prev.target.unselectAll();});// unflag as prev `click` target
delegator.prevClick=[];}}return[];};var delegateDblClick=function delegateDblClick(delegator,child,event,collision){if(collision){return[{type:EventType.DBL_CLICK,event:copyEvent(child,collision,event)}];}return[];};var DELEGATION_FUNCS=(_DELEGATION_FUNCS={},_defineProperty(_DELEGATION_FUNCS,EventType.MOUSE_MOVE,delegateMouseMove),_defineProperty(_DELEGATION_FUNCS,EventType.MOUSE_UP,delegateMouseUp),_defineProperty(_DELEGATION_FUNCS,EventType.MOUSE_DOWN,delegateMouseDown),_defineProperty(_DELEGATION_FUNCS,EventType.CLICK,delegateClick),_defineProperty(_DELEGATION_FUNCS,EventType.DBL_CLICK,delegateDblClick),_DELEGATION_FUNCS);/**
 * Class representing an event delegator.
 * @private
 */var EventDelegator=function(){/**
	 * Instantiates a new EventDelegator object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 */function EventDelegator(plot){_classCallCheck(this,EventDelegator);this.plot=plot;this.prevClick=[];this.prevMouseover=null;}/**
	 * Delegates the provided event type to all children of the plot.
	 *
	 * @param {string} type - The event type to delegate.
	 */_createClass(EventDelegator,[{key:'delegate',value:function delegate(type){var _this=this;// get appropriate delegation function
var func=DELEGATION_FUNCS[type];if(!func){throw'Delegation for event type '+type+' is not supported';}// attach delegation handler
this.plot.on(type,function(event){// get children sorted by z-index
var children=_this.plot.getSortedLayers();// pick children, by priority
var collision=null;var child=null;for(var i=children.length-1;i>=0;i--){if(!children[i].isHidden()){collision=children[i].pick(event.pos);if(collision){child=children[i];break;}}}// delegate using provided func
var delegations=func(_this,child,event,collision);// delegate the accumulated events
for(var _i=0;_i<delegations.length;_i++){var delegation=delegations[_i];delegation.event.target.emit(delegation.type,delegation.event);}});}}]);return EventDelegator;}();module.exports=EventDelegator;

},{"./EventType":141,"./MouseEvent":142}],141:[function(require,module,exports){
'use strict';/**
 * Event type string constants.
 */module.exports={/**
	 * Emitted when the plot is clicked.
	 * @constant {string}
	 */CLICK:'click',/**
	 * Emitted when the plot is double clicked.
	 * @constant {string}
	 */DBL_CLICK:'dblclick',/**
	 * Emitted when a mouse button is pressed.
	 * @constant {string}
	 */MOUSE_DOWN:'mousedown',/**
	 * Emitted when a mouse button is released.
	 * @constant {string}
	 */MOUSE_UP:'mouseup',/**
	 * Emitted when the mouse is moved on the target.
	 * @constant {string}
	 */MOUSE_MOVE:'mousemove',/**
	 * Emitted when the mouse is moved onto the target.
	 * @constant {string}
	 */MOUSE_OVER:'mouseover',/**
	 * Emitted when the mouse is moved out of the target.
	 * @constant {string}
	 */MOUSE_OUT:'mouseout',/**
	 * Emitted when a new pan event is handled.
	 * @constant {string}
	 */PAN_START:'panstart',/**
	 * Emitted during each frame of a pan animation.
	 * @constant {string}
	 */PAN:'pan',/**
	 * Emitted on the final frame of a pan animation.
	 * @constant {string}
	 */PAN_END:'panend',/**
	 * Emitted when a new zoom event is handled.
	 * @constant {string}
	 */ZOOM_START:'zoomstart',/**
	 * Emitted during each frame of a zoom animation.
	 * @constant {string}
	 */ZOOM:'zoom',/**
	 * Emitted on the final frame of a zoom animation.
	 * @constant {string}
	 */ZOOM_END:'zoomend',/**
	 * Emitted before processing a new frame.
	 * @constant {string}
	 */FRAME:'frame',/**
	 * Emitted when processing a resize event.
	 * @constant {string}
	 */RESIZE:'resize',/**
	 * Emitted when the viewing cell of the plot is updated.
	 * @constant {string}
	 */CELL_UPDATE:'cellupdate',/**
	 * Emitted when the layer is refreshed.
	 * @constant {string}
	 */REFRESH:'refresh',/**
	 * Emitted when an initial request for a tile is made, the tile is not
	 * yet part of the layer and has not yet been requested.
	 * @constant {string}
	 */TILE_REQUEST:'tilerequest',/**
	 * Emitted when a tile request completes unsuccessfully. The tile is not
	 * added to the layer.
	 * @constant {string}
	 */TILE_FAILURE:'tilefailure',/**
	 * Emitted when a tile request completes successfully. The tile is added
	 * to the layer.
	 * @constant {string}
	 */TILE_ADD:'tileadd',/**
	 * Emitted when a tile request completes successfully but the tile is no
	 * longer in view. The tile is not added to the layer.
	 * @constant {string}
	 */TILE_DISCARD:'tilediscard',/**
	 * Emitted when a tile is evicted from the internal LRU cache.
	 * @constant {string}
	 */TILE_REMOVE:'tileremove',/**
	 * Emitted when all visible tiles have been loaded for a layer.
	 * @constant {string}
	 */LOAD:'load'};

},{}],142:[function(require,module,exports){
'use strict';function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Event=require('./Event');/**
 * Class representing a mouse event.
 */var MouseEvent=function(_Event){_inherits(MouseEvent,_Event);/**
	 * Instantiates a new MouseEvent object.
	 *
	 * @param {Object} target - The object that fired the event.
	 * @param {string} event - The original DOM mouse event fired by the browser.
	 * @param {Object} pos - The position of the mouse event in plot coordinates.
	 * @param {Object} px - The position of the mouse event in viewport pixel coordinates.
	 * @param {Object} data - The data associated with the event.
	 */function MouseEvent(target,event,pos,px){var data=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;_classCallCheck(this,MouseEvent);var _this=_possibleConstructorReturn(this,(MouseEvent.__proto__||Object.getPrototypeOf(MouseEvent)).call(this,target));_this.originalEvent=event;_this.pos=pos;_this.px=px;_this.data=data;return _this;}return MouseEvent;}(Event);module.exports=MouseEvent;

},{"./Event":138}],143:[function(require,module,exports){
'use strict';function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Event=require('./Event');/**
 * Class representing a resize event.
 */var ResizeEvent=function(_Event){_inherits(ResizeEvent,_Event);/**
	 * Instantiates a new ResizeEvent object.
	 *
	 * @param {Object} target - The object that fired the event.
	 * @param {number} oldSize - The old size of the viewport.
	 * @param {number} newSize - The new size of the viewport.
	 */function ResizeEvent(target,oldSize,newSize){_classCallCheck(this,ResizeEvent);var _this=_possibleConstructorReturn(this,(ResizeEvent.__proto__||Object.getPrototypeOf(ResizeEvent)).call(this,target));_this.oldSize=oldSize;_this.newSize=newSize;return _this;}return ResizeEvent;}(Event);module.exports=ResizeEvent;

},{"./Event":138}],144:[function(require,module,exports){
'use strict';function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Event=require('./Event');/**
 * Class representing a tile event.
 */var TileEvent=function(_Event){_inherits(TileEvent,_Event);/**
	 * Instantiates a new TileEvent object.
	 *
	 * @param {Object} target - The object that fired the event.
	 * @param {number} tile - The tile object.
	 */function TileEvent(target,tile){_classCallCheck(this,TileEvent);var _this=_possibleConstructorReturn(this,(TileEvent.__proto__||Object.getPrototypeOf(TileEvent)).call(this,target));_this.tile=tile;return _this;}return TileEvent;}(Event);module.exports=TileEvent;

},{"./Event":138}],145:[function(require,module,exports){
'use strict';var EventType=require('./event/EventType');module.exports={// events
CLICK:EventType.CLICK,DBL_CLICK:EventType.DBL_CLICK,MOUSE_DOWN:EventType.MOUSE_DOWN,MOUSE_UP:EventType.MOUSE_UP,MOUSE_MOVE:EventType.MOUSE_MOVE,MOUSE_OVER:EventType.MOUSE_OVER,MOUSE_OUT:EventType.MOUSE_OUT,PAN_START:EventType.PAN_START,PAN:EventType.PAN,PAN_END:EventType.PAN_END,ZOOM_START:EventType.ZOOM_START,ZOOM:EventType.ZOOM,ZOOM_END:EventType.ZOOM_END,RESIZE:EventType.RESIZE,FRAME:EventType.FRAME,REFRESH:EventType.REFRESH,TILE_REQUEST:EventType.TILE_REQUEST,TILE_FAILURE:EventType.TILE_FAILURE,TILE_ADD:EventType.TILE_ADD,TILE_DISCARD:EventType.TILE_DISCARD,TILE_REMOVE:EventType.TILE_REMOVE,CELL_UPDATE:EventType.CELL_UPDATE,// event
Event:require('./event/Event'),MouseEvent:require('./event/MouseEvent'),ResizeEvent:require('./event/ResizeEvent'),TileEvent:require('./event/TileEvent'),// geometry
Bounds:require('./geometry/Bounds'),RTree:require('./geometry/RTree'),RTreePyramid:require('./geometry/RTreePyramid'),CircleCollidable:require('./geometry/CircleCollidable'),RectangleCollidable:require('./geometry/RectangleCollidable'),RingCollidable:require('./geometry/RingCollidable'),// plot
Plot:require('./plot/Plot'),// layer
Layer:require('./layer/Layer'),// tile layer
TileLayer:require('./layer/tile/TileLayer'),// overlay layer
Overlay:require('./layer/overlay/Overlay'),PointOverlay:require('./layer/overlay/PointOverlay'),PolylineOverlay:require('./layer/overlay/PolylineOverlay'),PolygonOverlay:require('./layer/overlay/PolygonOverlay'),// renderer
Renderer:require('./renderer/Renderer'),// tile renderer
TileRenderer:require('./renderer/tile/TileRenderer'),// webgl tile renderer
WebGLTileRenderer:require('./renderer/tile/WebGLTileRenderer'),ImageTileRenderer:require('./renderer/tile/sample/ImageTileRenderer'),InteractiveTileRenderer:require('./renderer/tile/sample/InteractiveTileRenderer'),PointTileRenderer:require('./renderer/tile/sample/PointTileRenderer'),InstancedTileRenderer:require('./renderer/tile/sample/InstancedTileRenderer'),// overlay renderer
OverlayRenderer:require('./renderer/overlay/OverlayRenderer'),// webgl overlay renderer
WebGLOverlayRenderer:require('./renderer/overlay/WebGLOverlayRenderer'),PointOverlayRenderer:require('./renderer/overlay/sample/PointOverlayRenderer'),PolylineOverlayRenderer:require('./renderer/overlay/sample/PolylineOverlayRenderer'),PolygonOverlayRenderer:require('./renderer/overlay/sample/PolygonOverlayRenderer'),// webgl shader
Shader:require('./webgl/shader/Shader'),// webgl texture
Texture:require('./webgl/texture/Texture'),TextureArray:require('./webgl/texture/TextureArray'),// webgl vertex
VertexAtlas:require('./webgl/vertex/VertexAtlas'),VertexBuffer:require('./webgl/vertex/VertexBuffer'),IndexBuffer:require('./webgl/vertex/IndexBuffer'),// util
loadBuffer:require('./util/loadBuffer'),loadImage:require('./util/loadImage')};

},{"./event/Event":138,"./event/EventType":141,"./event/MouseEvent":142,"./event/ResizeEvent":143,"./event/TileEvent":144,"./geometry/Bounds":146,"./geometry/CircleCollidable":147,"./geometry/RTree":148,"./geometry/RTreePyramid":149,"./geometry/RectangleCollidable":150,"./geometry/RingCollidable":151,"./layer/Layer":152,"./layer/overlay/Overlay":153,"./layer/overlay/PointOverlay":154,"./layer/overlay/PolygonOverlay":155,"./layer/overlay/PolylineOverlay":156,"./layer/tile/TileLayer":159,"./plot/Plot":163,"./renderer/Renderer":173,"./renderer/overlay/OverlayRenderer":174,"./renderer/overlay/WebGLOverlayRenderer":175,"./renderer/overlay/sample/PointOverlayRenderer":176,"./renderer/overlay/sample/PolygonOverlayRenderer":177,"./renderer/overlay/sample/PolylineOverlayRenderer":178,"./renderer/tile/TileRenderer":180,"./renderer/tile/WebGLTileRenderer":181,"./renderer/tile/sample/ImageTileRenderer":182,"./renderer/tile/sample/InstancedTileRenderer":183,"./renderer/tile/sample/InteractiveTileRenderer":184,"./renderer/tile/sample/PointTileRenderer":185,"./util/loadBuffer":189,"./util/loadImage":190,"./webgl/shader/Shader":192,"./webgl/texture/Texture":195,"./webgl/texture/TextureArray":196,"./webgl/vertex/IndexBuffer":197,"./webgl/vertex/VertexAtlas":198,"./webgl/vertex/VertexBuffer":199}],146:[function(require,module,exports){
'use strict';// Constants
var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var INSIDE=0x00;// 0000
var LEFT=0x01;// 0001
var RIGHT=0x02;// 0010
var BOTTOM=0x04;// 0100
var TOP=0x08;// 1000
var computeCode=function computeCode(bounds,x,y){var code=INSIDE;if(x<bounds.left){// to the left of clip window
code|=LEFT;}else if(x>bounds.right){// to the right of clip window
code|=RIGHT;}if(y<bounds.bottom){// below the clip window
code|=BOTTOM;}else if(y>bounds.top){// above the clip window
code|=TOP;}return code;};var sutherlandHodgemanClip=function sutherlandHodgemanClip(bounds,points){// Sutherland-Hodgeman clipping algorithm clips a polygon against a
// rectangle.
var result=void 0;for(var code=1;code<=8;code*=2){result=[];var prev=points[points.length-1];var prevInside=!(computeCode(bounds,prev.x,prev.y)&code);for(var i=0;i<points.length;i++){var p=points[i];var inside=!(computeCode(bounds,p.x,p.y)&code);// if segment goes through the clip window, add an intersection
if(inside!==prevInside){var ax=prev.x;var ay=prev.y;var bx=p.x;var by=p.y;var x=void 0,y=0;if(code&TOP){// point is above the clip rectangle
x=ax+(bx-ax)*(bounds.top-ay)/(by-ay);y=bounds.top;}else if(code&BOTTOM){// point is below the clip rectangle
x=ax+(bx-ax)*(bounds.bottom-ay)/(by-ay);y=bounds.bottom;}else if(code&RIGHT){// point is to the right of clip rectangle
y=ay+(by-ay)*(bounds.right-ax)/(bx-ax);x=bounds.right;}else{//if (code & LEFT) {
// point is to the left of clip rectangle
y=ay+(by-ay)*(bounds.left-ax)/(bx-ax);x=bounds.left;}result.push({x:x,y:y});}if(inside){// add a point if it's inside
result.push(p);}prev=p;prevInside=inside;}points=result;if(!points.length){break;}}return result.length>0?result:null;};var cohenSutherlandClip=function cohenSutherlandClip(bounds,a,b){// CohenSutherland clipping algorithm clips a line against a rectangle.
// copy so we don't change in-place
var ax=a.x;var ay=a.y;var bx=b.x;var by=b.y;// compute outcodes for P0, P1, and whatever point lies outside the clip rectangle
var aCode=computeCode(bounds,ax,ay);var bCode=computeCode(bounds,bx,by);var accept=false;// normal alg has infiinite while loop, cap at 8 iterations just in case
var MAX_ITERATIONS=8;var iter=0;while(iter<MAX_ITERATIONS){if(!(aCode|bCode)){// bitwise OR is 0. Trivially accept and get out of loop
accept=true;break;}else if(aCode&bCode){// bitwise AND is not 0. (implies both end points are in the same
// region outside the window). Reject and get out of loop
break;}else{// failed both tests, so calculate the line segment to clip
// from an outside point to an intersection with clip edge
var x=void 0,y=0;// At least one endpoint is outside the clip rectangle; pick it.
var code=aCode?aCode:bCode;// Now find the intersection point;
// use formulas
// y = ay + slope * (x - ax), x = ax + (1 / slope) * (y - ay)
if(code&TOP){// point is above the clip rectangle
x=ax+(bx-ax)*(bounds.top-ay)/(by-ay);y=bounds.top;}else if(code&BOTTOM){// point is below the clip rectangle
x=ax+(bx-ax)*(bounds.bottom-ay)/(by-ay);y=bounds.bottom;}else if(code&RIGHT){// point is to the right of clip rectangle
y=ay+(by-ay)*(bounds.right-ax)/(bx-ax);x=bounds.right;}else{//if (code & LEFT) {
// point is to the left of clip rectangle
y=ay+(by-ay)*(bounds.left-ax)/(bx-ax);x=bounds.left;}// now we move outside point to intersection point to clip
// and get ready for next pass.
if(code===aCode){ax=x;ay=y;aCode=computeCode(bounds,ax,ay);}else{bx=x;by=y;bCode=computeCode(bounds,bx,by);}}iter++;}if(accept){return[{x:ax,y:ay},{x:bx,y:by}];}return null;};/**
 * Class representing a set of bounds.
 */var Bounds=function(){/**
	 * Instantiates a new Bounds object.
	 *
	 * @param {number} left - The left bound.
	 * @param {number} right - The right bound.
	 * @param {number} bottom - The bottom bound.
	 * @param {number} top - The top bound.
	 */function Bounds(left,right,bottom,top){_classCallCheck(this,Bounds);this.left=left;this.right=right;this.bottom=bottom;this.top=top;}/**
	 * Get the width of the bounds.
	 *
	 * @returns {number} The width of the bounds.
	 */_createClass(Bounds,[{key:'getWidth',value:function getWidth(){return this.right-this.left;}/**
	 * Get the height of the bounds.
	 *
	 * @returns {number} The height of the bounds.
	 */},{key:'getHeight',value:function getHeight(){return this.top-this.bottom;}/**
	 * Extends the bounds by the provided point or bounds object.
	 *
	 * @param {Object|Bounds} arg - The point or bounds to extend the bounds by.
	 *
	 * @returns {Bounds} The bounds object, for chaining.
	 */},{key:'extend',value:function extend(arg){if(arg.left!==undefined&&arg.right!==undefined&&arg.bottom!==undefined&&arg.top!==undefined){// bounds
if(arg.left<this.left){this.left=arg.left;}if(arg.right>this.right){this.right=arg.right;}if(arg.bottom<this.bottom){this.bottom=arg.bottom;}if(arg.top>this.top){this.top=arg.top;}}else{// point
if(arg.x<this.left){this.left=arg.x;}if(arg.x>this.right){this.right=arg.x;}if(arg.y<this.bottom){this.bottom=arg.y;}if(arg.y>this.top){this.top=arg.y;}}}/**
	 * Get the center coordinate of the bounds.
	 *
	 * @returns {Object} The center coordinate of the bounds.
	 */},{key:'getCenter',value:function getCenter(){return{x:this.left+this.getWidth()/2,y:this.bottom+this.getHeight()/2};}/**
	 * Test if the bounds equals another.
	 *
	 * @param {Bounds} bounds - The bounds object to test.
	 *
	 * @returns {boolean} Whether or not the bounds objects are equal.
	 */},{key:'equals',value:function equals(bounds){return this.left===bounds.left&&this.right===bounds.right&&this.bottom===bounds.bottom&&this.top===bounds.top;}/**
	 * Test if the bounds overlaps another. Test is inclusive of edges.
	 *
	 * @param {Bounds} bounds - The bounds object to test.
	 *
	 * @returns {boolean} Whether or not the bounds overlap eachother.
	 */},{key:'overlaps',value:function overlaps(bounds){// NOTE: inclusive of edges
return!(this.left>bounds.right||this.right<bounds.left||this.top<bounds.bottom||this.bottom>bounds.top);}/**
	 * Return the intersection of the bounds. Test is inclusive of edges. If
	 * the bounds do not intersect, returns undefined.
	 *
	 * @param {Bounds} bounds - The bounds object to intersect.
	 *
	 * @returns {Bounds} The intersection of both bounds.
	 */},{key:'intersection',value:function intersection(bounds){// NOTE: inclusive of edges
if(!this.overlaps(bounds)){return undefined;}return new Bounds(Math.max(this.left,bounds.left),Math.min(this.right,bounds.right),Math.max(this.bottom,bounds.bottom),Math.min(this.top,bounds.top));}/**
	 * Clips the provided line segment to within the dimensions of the bounds.
	 * Test is inclusive of edges.
	 *
	 * @param {Array} line - The line.
	 *
	 * @returns {Array} The clipped line, or null if it is outside the bounds.
	 */},{key:'clipLine',value:function clipLine(line){if(!line||line.length!==2){return null;}return cohenSutherlandClip(this,line[0],line[1]);}/**
	 * Clips the provided polyline to within the dimensions of the bounds. Will
	 * return an array of clipped polylines as result.
	 * Test is inclusive of edges.
	 *
	 * @param {Array} polyline - The polyline.
	 *
	 * @returns {Array} The resulting clipped polylines, or null if it is outside the bounds.
	 */},{key:'clipPolyline',value:function clipPolyline(polyline){if(!polyline||polyline.length<2){return null;}var clipped=[];var current=[];for(var i=1;i<polyline.length;i++){var a=polyline[i-1];var b=polyline[i];// clip the line
var line=cohenSutherlandClip(this,a,b);// no line in bounds
if(!line){continue;}var clippedA=line[0];var clippedB=line[1];// add src point
current.push(clippedA);if(clippedB.x!==b.x&&clippedB.y!==b.y||i===polyline.length-1){// only add destination point if it was clipped, or is last
// point
current.push(clippedB);// then break the polyline
clipped.push(current);current=[];}}return clipped.length>0?clipped:null;}/**
	 * Clips the provided points to those within the dimensions of the bounds.
	 * Test is inclusive of edges.
	 *
	 * @param {Array} points - The points to clip.
	 *
	 * @returns {Array} The clipped points, or null if none are within the bounds.
	 */},{key:'clipPoints',value:function clipPoints(points){if(!points){return null;}var clipped=[];for(var i=0;i<points.length;i++){var point=points[i];if(point.x>=this.left&&point.x<=this.right&&point.y>=this.bottom&&point.y<=this.top){clipped.push(point);}}return clipped.length>0?clipped:null;}/**
	 * Clips the provided polygon to those within the dimensions of the bounds.
	 * Test is inclusive of edges.
	 *
	 * @param {Array} polygon - The points of the polygon to clip.
	 *
	 * @returns {Array} The clipped points of the polygon, or null if it is not within the bounds.
	 */},{key:'clipPolygon',value:function clipPolygon(polygon){if(!polygon||polygon.length<3){return null;}return sutherlandHodgemanClip(this,polygon);}}]);return Bounds;}();module.exports=Bounds;

},{}],147:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var clamp=require('lodash/clamp');/**
 * Class representing a circle collidable.
 */var CircleCollidable=function(){/**
	 * Instantiates a new CircleCollidable object.
	 *
	 * @param {number} x - The tile x pixel coordinate.
	 * @param {number} y - The tile y pixel coordinate.
	 * @param {number} radius - The radius in pixels.
	 * @param {number} xOffset - The tile x offset in pixels.
	 * @param {number} yOffset - The tile y offset in pixels.
	 * @param {Tile} tile - The tile object.
	 * @param {Object} data - Any arbitrary user data.
	 */function CircleCollidable(x,y,radius,xOffset,yOffset,tile,data){_classCallCheck(this,CircleCollidable);this.x=x;this.y=y;this.radius=radius;this.minX=x+xOffset-radius;this.maxX=x+xOffset+radius;this.minY=y+yOffset-radius;this.maxY=y+yOffset+radius;this.tile=tile;this.data=data;}/**
	 * Test if the provided position is within the inner shape of the collidable.
	 *
	 * @param {number} x - The x position to test.
	 * @param {number} y - The y position to test.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 */_createClass(CircleCollidable,[{key:'testPoint',value:function testPoint(x,y){// center pos
var cx=(this.minX+this.maxX)*0.5;var cy=(this.minY+this.maxY)*0.5;// distance to point
var dx=cx-x;var dy=cy-y;return dx*dx+dy*dy<=this.radius*this.radius;}/**
	 * Test if the provided rectangle is within the inner shape of the
	 * collidable.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 */},{key:'testRectangle',value:function testRectangle(minX,maxX,minY,maxY){// circle pos
var cx=(this.minX+this.maxX)*0.5;var cy=(this.minY+this.maxY)*0.5;// find closest point in rectangle to circle
var nearestX=clamp(cx,minX,maxX);var nearestY=clamp(cy,minY,maxY);// test distance
var dx=cx-nearestX;var dy=cy-nearestY;return dx*dx+dy*dy<this.radius*this.radius;}}]);return CircleCollidable;}();module.exports=CircleCollidable;

},{"lodash/clamp":107}],148:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var rbush=require('rbush');var defaultTo=require('lodash/defaultTo');/**
 * Class representing an r-tree.
 */var RTree=function(){/**
	 * Instantiates a new RTree object.
	 *
	 * @param {Object} options - The options object.
	 * @param {boolean} options.nodeCapacity - The node capacity of the r-tree.
	 */function RTree(options){_classCallCheck(this,RTree);this.tree=rbush(defaultTo(options.nodeCapacity,32));}/**
	 * Inserts an array of collidables into the r-tree.
	 *
	 * @param {Array} collidables - The array of collidables to insert.
	 */_createClass(RTree,[{key:'insert',value:function insert(collidables){this.tree.load(collidables);}/**
	 * Removes an array of collidables from the r-tree.
	 *
	 * @param {Array} collidables - The array of collidables to remove.
	 */},{key:'remove',value:function remove(collidables){var tree=this.tree;for(var i=0;i<collidables.length;i++){tree.remove(collidables[i]);}}/**
	 * Searchs the r-tree using a point.
	 *
	 * @param {number} x - The x component.
	 * @param {number} y - The y component.
	 *
	 * @returns {Object} The collision object.
	 */},{key:'searchPoint',value:function searchPoint(x,y){var collisions=this.tree.search({minX:x,maxX:x,minY:y,maxY:y});if(collisions.length===0){return null;}// inner shape test
for(var i=0;i<collisions.length;i++){var collision=collisions[i];if(collision.testPoint(x,y)){return collision;}}return null;}/**
	 * Searchs the r-tree using a rectangle.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 *
	 * @returns {Object} The collision object.
	 */},{key:'searchRectangle',value:function searchRectangle(minX,maxX,minY,maxY){var collisions=this.tree.search({minX:minX,maxX:maxX,minY:minY,maxY:maxY});if(collisions.length===0){return null;}// inner shape test
for(var i=0;i<collisions.length;i++){var collision=collisions[i];if(collision.testRectangle(minX,maxX,minY,maxY)){return collision;}}return null;}}]);return RTree;}();module.exports=RTree;

},{"lodash/defaultTo":109,"rbush":137}],149:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var RTree=require('./RTree');/**
 * Class representing a pyramid of r-trees.
 */var RTreePyramid=function(){/**
	 * Instantiates a new RTreePyramid object.
	 *
	 * @param {Object} options - The options object.
	 * @param {boolean} options.nodeCapacity - The node capacity of the r-tree.
	 */function RTreePyramid(options){_classCallCheck(this,RTreePyramid);this.trees=new Map();this.collidables=new Map();this.nodeCapacity=defaultTo(options.nodeCapacity,32);}/**
	 * Inserts an array of collidables into the r-tree for the provided coord.
	 *
	 * @param {TileCoord} coord - The coord of the tile.
	 * @param {Array} collidables - The array of collidables to insert.
	 *
	 * @returns {RTreePyramid} The RTreePyramid object, for chaining.
	 */_createClass(RTreePyramid,[{key:'insert',value:function insert(coord,collidables){if(!this.trees.has(coord.z)){this.trees.set(coord.z,new RTree({nodeCapacity:this.nodeCapacity}));}this.trees.get(coord.z).insert(collidables);this.collidables.set(coord.hash,collidables);return this;}/**
	 * Removes an array of collidables from the r-tree for the provided coord.
	 *
	 * @param {TileCoord} coord - The coord of the tile.
	 *
	 * @returns {RTreePyramid} The RTreePyramid object, for chaining.
	 */},{key:'remove',value:function remove(coord){var collidables=this.collidables.get(coord.hash);this.trees.get(coord.z).remove(collidables);this.collidables.delete(coord.hash);return this;}/**
	 * Searchs the r-tree using a point.
	 *
	 * @param {number} x - The x component.
	 * @param {number} y - The y component.
	 * @param {number} zoom - The zoom level of the plot.
	 * @param {number} extent - The pixel extent of the plot zoom.
	 *
	 * @returns {Object} The collision object.
	 */},{key:'searchPoint',value:function searchPoint(x,y,zoom,extent){// points are stored in un-scaled coordinates, unscale the point
var tileZoom=Math.round(zoom);// get the tree for the zoom
var tree=this.trees.get(tileZoom);if(!tree){// no data for tile
return null;}var scale=Math.pow(2,tileZoom-zoom);// unscaled points
var sx=x*extent*scale;var sy=y*extent*scale;// get collision
return tree.searchPoint(sx,sy);}/**
	 * Searchs the r-tree using a rectangle.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 * @param {number} zoom - The zoom level of the plot.
	 * @param {number} extent - The pixel extent of the plot zoom.
	 *
	 * @returns {Object} The collision object.
	 */},{key:'searchRectangle',value:function searchRectangle(minX,maxX,minY,maxY,zoom,extent){// points are stored in un-scaled coordinates, unscale the point
var tileZoom=Math.round(zoom);// get the tree for the zoom
var tree=this.trees.get(tileZoom);if(!tree){// no data for tile
return null;}var scale=Math.pow(2,tileZoom-zoom);// unscaled points
var sminX=minX*extent*scale;var smaxX=maxX*extent*scale;var sminY=minY*extent*scale;var smaxY=maxY*extent*scale;// get collision
return tree.searchRectangle(sminX,smaxX,sminY,smaxY);}}]);return RTreePyramid;}();module.exports=RTreePyramid;

},{"./RTree":148,"lodash/defaultTo":109}],150:[function(require,module,exports){
'use strict';/**
 * Class representing a rectangle collidable.
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var RectangleCollidable=function(){/**
	 * Instantiates a new RectangleCollidable object.
	 *
	 * @param {number} minX - The left bound in pixels.
	 * @param {number} maxX - The right bound in pixels.
	 * @param {number} minY - The bottom bound in pixels.
	 * @param {number} maxY - The top bound in pixels.
	 * @param {number} xOffset - The tile x offset in pixels.
	 * @param {number} yOffset - The tile y offset in pixels.
	 * @param {Tile} tile - The tile object.
	 * @param {Object} data - Any arbitrary user data.
	 */function RectangleCollidable(minX,maxX,minY,maxY,xOffset,yOffset,tile,data){_classCallCheck(this,RectangleCollidable);this.minX=minX+xOffset;this.maxX=maxX+xOffset;this.minY=minY+yOffset;this.maxY=maxY+yOffset;this.tile=tile;this.data=data;}/**
	 * Test if the provided position is within the inner shape of the collidable.
	 *
	 * @param {number} x - The x position to test.
	 * @param {number} y - The y position to test.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 *//* eslint-disable no-unused-vars */_createClass(RectangleCollidable,[{key:'testPoint',value:function testPoint(x,y){return true;}/**
	 * Test if the provided rectangle is within the inner shape of the
	 * collidable.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 *//* eslint-disable no-unused-vars */},{key:'testRectangle',value:function testRectangle(minX,maxX,minY,maxY){return true;}}]);return RectangleCollidable;}();module.exports=RectangleCollidable;

},{}],151:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var clamp=require('lodash/clamp');/**
 * Class representing a circle collidable.
 */var RingCollidable=function(){/**
	 * Instantiates a new RingCollidable object.
	 *
	 * @param {number} x - The tile x pixel coordinate.
	 * @param {number} y - The tile y pixel coordinate.
	 * @param {number} radius - The radius in pixels.
	 * @param {number} width - The radius buffer in pixels (additional hit-area beyond radius)
	 * @param {number} xOffset - The tile x offset in pixels.
	 * @param {number} yOffset - The tile y offset in pixels.
	 * @param {Tile} tile - The tile object.
	 * @param {Object} data - Any arbitrary user data.
	 */function RingCollidable(x,y,radius,width,xOffset,yOffset,tile,data){_classCallCheck(this,RingCollidable);this.x=x;this.y=y;this.radius=radius;this.width=width;var halfWidth=width*0.5;this.minX=x+xOffset-radius-halfWidth;this.maxX=x+xOffset+radius+halfWidth;this.minY=y+yOffset-radius-halfWidth;this.maxY=y+yOffset+radius+halfWidth;this.tile=tile;this.data=data;}/**
	 * Test if the provided position is within the inner shape of the collidable.
	 *
	 * @param {number} x - The x position to test.
	 * @param {number} y - The y position to test.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 */_createClass(RingCollidable,[{key:'testPoint',value:function testPoint(x,y){// center pos
var cx=(this.minX+this.maxX)*0.5;var cy=(this.minY+this.maxY)*0.5;// distance to point
var dx=cx-x;var dy=cy-y;var distanceSqr=dx*dx+dy*dy;var halfWidth=this.width*0.5;var innerRadius=this.radius-halfWidth;var outerRadius=this.radius+halfWidth;return distanceSqr<=outerRadius*outerRadius&&distanceSqr>=innerRadius*innerRadius;}/**
	 * Test if the provided rectangle is within the inner shape of the
	 * collidable.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 */},{key:'testRectangle',value:function testRectangle(minX,maxX,minY,maxY){// circle pos
var cx=(this.minX+this.maxX)*0.5;var cy=(this.minY+this.maxY)*0.5;// find the furthest points on rectangle from the circle
var furthestX=void 0,furthestY=0;if(Math.abs(cx-minX)<Math.abs(cx-maxX)){furthestX=maxX;}else{furthestX=minX;}if(Math.abs(cy-minY)<Math.abs(cy-maxY)){furthestY=maxY;}else{furthestY=minY;}// check if there is any intersection with the inner circle
var fx=cx-furthestX;var fy=cy-furthestY;var halfWidth=this.width*0.5;var innerRadius=this.radius-halfWidth;if(fx*fx+fy*fy<innerRadius*innerRadius){// rectangle is completely inside the ring and cannot intersect
return false;}// otherwise just do a circle - aabb test for outer circle
// find closest point in rectangle to circle
var nearestX=clamp(cx,minX,maxX);var nearestY=clamp(cy,minY,maxY);// test distance
var dx=cx-nearestX;var dy=cy-nearestY;var outerRadius=this.radius+halfWidth;return dx*dx+dy*dy<outerRadius*outerRadius;}}]);return RingCollidable;}();module.exports=RingCollidable;

},{"lodash/clamp":107}],152:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var clamp=require('lodash/clamp');var defaultTo=require('lodash/defaultTo');var EventEmitter=require('events');var Event=require('../event/Event');var EventType=require('../event/EventType');/**
 * Class representing a layer component.
 */var Layer=function(_EventEmitter){_inherits(Layer,_EventEmitter);/**
	 * Instantiates a new Layer object.
	 *
	 * @param {Object} options - The options.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 * @param {boolean} options.hidden - Whether or not the layer is visible.
	 */function Layer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,Layer);var _this=_possibleConstructorReturn(this,(Layer.__proto__||Object.getPrototypeOf(Layer)).call(this));_this.opacity=defaultTo(options.opacity,1.0);_this.hidden=defaultTo(options.hidden,false);_this.zIndex=defaultTo(options.zIndex,0);_this.renderer=defaultTo(options.renderer,null);_this.highlighted=null;_this.selected=[];_this.plot=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the layer to.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */_createClass(Layer,[{key:'onAdd',value:function onAdd(plot){if(!plot){throw'No plot argument provided';}// set plot
this.plot=plot;// flag as dirty
this.plot.setDirty();// execute renderer hook
if(this.renderer){this.renderer.onAdd(this);}return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the layer from.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){if(!plot){throw'No plot argument provided';}// execute renderer hook
if(this.renderer){this.renderer.onRemove(this);}// clear state
this.clear();// flag as dirty
this.plot.setDirty();// remove plot
this.plot=null;return this;}/**
	 * Add a renderer to the layer.
	 *
	 * @param {Renderer} renderer - The renderer to add to the layer.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'setRenderer',value:function setRenderer(renderer){if(!renderer){throw'No renderer argument provided';}if(this.renderer&&this.plot){this.renderer.onRemove(this);}this.renderer=renderer;if(this.plot){this.renderer.onAdd(this);}return this;}/**
	 * Remove the renderer from the layer.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'removeRenderer',value:function removeRenderer(){if(!this.renderer){throw'No renderer is currently attached to the layer';}if(this.plot){this.renderer.onRemove(this);}this.renderer=null;return this;}/**
	 * Returns the renderer of the layer.
	 *
	 * @returns {Renderer} The renderer object.
	 */},{key:'getRenderer',value:function getRenderer(){return this.renderer;}/**
	 * Set the opacity of the layer.
	 *
	 * @param {number} opacity - The opacity to set.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'setOpacity',value:function setOpacity(opacity){opacity=clamp(opacity,0,1);if(this.opacity!==opacity){this.opacity=opacity;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Get the opacity of the layer.
	 *
	 * @returns {number} The opacity of the layer object,.
	 */},{key:'getOpacity',value:function getOpacity(){return this.opacity;}/**
	 * Set the z-index of the layer.
	 *
	 * @param {number} zIndex - The z-index to set.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'setZIndex',value:function setZIndex(zIndex){if(this.zIndex!==zIndex){this.zIndex=zIndex;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Get the z-index of the layer.
	 *
	 * @returns {number} The zIndex of the layer object,.
	 */},{key:'getZIndex',value:function getZIndex(){return this.zIndex;}/**
	 * Make the layer visible.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'show',value:function show(){if(this.hidden){this.hidden=false;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Make the layer invisible.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'hide',value:function hide(){if(!this.hidden){this.hidden=true;if(this.renderer){this.renderer.clear();}if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Returns true if the layer is hidden.
	 *
	 * @returns {boolean} Whether or not the layer is hidden.
	 */},{key:'isHidden',value:function isHidden(){return this.hidden;}/**
	 * Pick a position of the layer for a collision with any rendered objects.
	 *
	 * @param {Object} pos - The plot position to pick at.
	 *
	 * @returns {Object} The collision, or null.
	 */},{key:'pick',value:function pick(pos){if(this.renderer){return this.renderer.pick(pos);}return null;}/**
	 * Highlights the provided data.
	 *
	 * @param {Object} data - The data to highlight.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'highlight',value:function highlight(data){if(this.highlighted!==data){this.highlighted=data;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Clears any current highlight.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'unhighlight',value:function unhighlight(){if(this.highlighted!==null){this.highlighted=null;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Returns any highlighted data.
	 *
	 * @returns {Object} The highlighted data.
	 */},{key:'getHighlighted',value:function getHighlighted(){return this.highlighted;}/**
	 * Returns true if the provided argument is highlighted.
	 *
	 * @param {Object} data - The data to test.
	 *
	 * @returns {boolean} Whether or not there is highlighted data.
	 */},{key:'isHighlighted',value:function isHighlighted(data){return this.highlighted===data;}/**
	 * Selects the provided data.
	 *
	 * @param {Object} data - The data to select.
	 * @param {Object} multiSelect - Whether mutli-select is enabled.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'select',value:function select(data,multiSelect){var changed=false;if(multiSelect){// add to collection if multi-selection is enabled
var index=this.selected.indexOf(data);if(index===-1){// select point
this.selected.push(data);changed=true;}}else{// clear selection, adding only the latest entry
if(this.selected.length!==1||this.selected[0]!==data){this.selected=[data];changed=true;}}if(this.plot&&changed){this.plot.setDirty();}return this;}/**
	 * Remove the provided data from the current selection.
	 *
	 * @param {Object} data - The data to unselect.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'unselect',value:function unselect(data){var index=this.selected.indexOf(data);if(index!==-1){// unselect point
this.selected.splice(index,1);if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Clears the current selection.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'unselectAll',value:function unselectAll(){if(this.selected.length>0){// unselect all
this.selected=[];if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Returns any selected data.
	 *
	 * @returns {Array} The selected data.
	 */},{key:'getSelected',value:function getSelected(){return this.selected;}/**
	 * Returns true if the provided argument is selected.
	 *
	 * @param {Object} data - The data to test.
	 *
	 * @returns {boolean} Whether or not the data is selected.
	 */},{key:'isSelected',value:function isSelected(data){return this.selected.indexOf(data)!==-1;}/**
	 * Draw the layer for the frame.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'draw',value:function draw(timestamp){if(this.renderer){this.renderer.draw(timestamp);}return this;}/**
	 * Clears any persisted state in the layer.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'clear',value:function clear(){// clear selected / highlighted
if(this.highlighted||this.selected.length>0){this.highlighted=null;this.selected=[];}// clear renderer state
if(this.renderer){this.renderer.clear();}// flag as dirty
if(this.plot){this.plot.setDirty();}return this;}/**
	 * Clears any persisted state in the layer and refreshes the underlying
	 * data.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'refresh',value:function refresh(){// clear the layer state
this.clear();// emit refresh event
this.emit(EventType.REFRESH,new Event(this));return this;}}]);return Layer;}(EventEmitter);module.exports=Layer;

},{"../event/Event":138,"../event/EventType":141,"events":2,"lodash/clamp":107,"lodash/defaultTo":109}],153:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var Layer=require('../Layer');// Constants
/**
 * Cell update event handler symbol.
 * @private
 * @constant {Symbol}
 */var CELL_UPDATE=Symbol();/**
 * Clipped geometry symbol.
 * @private
 * @constant {Symbol}
 */var CLIPPED=Symbol();/**
 * Class representing an overlay layer.
 */var Overlay=function(_Layer){_inherits(Overlay,_Layer);/**
	 * Instantiates a new Overlay object.
	 *
	 * @param {Object} options - The overlay options.
	 * @param {number} options.opacity - The overlay opacity.
	 * @param {number} options.zIndex - The overlay z-index.
	 * @param {boolean} options.hidden - Whether or not the overlay is visible.
	 */function Overlay(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,Overlay);var _this=_possibleConstructorReturn(this,(Overlay.__proto__||Object.getPrototypeOf(Overlay)).call(this,options));_this[CLIPPED]=null;_this[CELL_UPDATE]=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the overlay to.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */_createClass(Overlay,[{key:'onAdd',value:function onAdd(plot){var _this2=this;_get(Overlay.prototype.__proto__||Object.getPrototypeOf(Overlay.prototype),'onAdd',this).call(this,plot);// clip existing geometry
this.refresh();// create cell update handler
this[CELL_UPDATE]=function(){_this2.refresh();};// attach handler
this.plot.on(EventType.CELL_UPDATE,this[CELL_UPDATE]);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the overlay from.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){// remove clipped geometry
this[CLIPPED]=null;// remove handler
this.plot.removeListener(EventType.CELL_UPDATE,this[CELL_UPDATE]);// create refresh handler
this[CELL_UPDATE]=null;_get(Overlay.prototype.__proto__||Object.getPrototypeOf(Overlay.prototype),'onRemove',this).call(this,plot);return this;}/**
	 * Unmutes and shows the overlay.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */},{key:'enable',value:function enable(){this.show();return this;}/**
	 * Mutes and hides the overlay.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */},{key:'disable',value:function disable(){this.hide();return this;}/**
	 * Returns true if the overlay is disabled.
	 *
	 * @returns {boolean} Whether or not the overlay is disabled.
	 */},{key:'isDisabled',value:function isDisabled(){return this.isHidden();}/**
	 * Clears any persisted state in the overlay and refreshes the underlying
	 * data. This involves refreshing the stored clipped geometry of the
	 * overlay based the current rendering cell of the plot.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */},{key:'refresh',value:function refresh(){if(this.plot){this[CLIPPED]=this.clipGeometry(this.plot.cell);}_get(Overlay.prototype.__proto__||Object.getPrototypeOf(Overlay.prototype),'refresh',this).call(this);return this;}/**
	 * Given an array of point based geometry, return the clipped geometry.
	 *
	 * @param {Cell} cell - The rendering cell.
	 *
	 * @returns {Array} The array of clipped geometry.
	 *//* eslint-disable no-unused-vars */},{key:'clipGeometry',value:function clipGeometry(cell){throw'`clipGeometry` must be overridden';}/**
	 * Return the clipped geometry based on the current cell.
	 *
	 * @returns {Array} The array of clipped geometry.
	 */},{key:'getClippedGeometry',value:function getClippedGeometry(){return this[CLIPPED];}}]);return Overlay;}(Layer);module.exports=Overlay;

},{"../../event/EventType":141,"../Layer":152}],154:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Overlay=require('./Overlay');// Private Methods
var clipPoints=function clipPoints(cell,points){var clipped=[];points.forEach(function(pts){var clippedPoints=cell.bounds.clipPoints(pts);if(!clippedPoints){return;}for(var i=0;i<clippedPoints.length;i++){clipped.push(cell.project(clippedPoints[i]));}});return clipped;};/**
 * Class representing a point overlay.
 */var PointOverlay=function(_Overlay){_inherits(PointOverlay,_Overlay);/**
	 * Instantiates a new PointOverlay object.
	 *
	 * @param {Object} options - The layer options.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 */function PointOverlay(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PointOverlay);var _this=_possibleConstructorReturn(this,(PointOverlay.__proto__||Object.getPrototypeOf(PointOverlay)).call(this,options));_this.points=new Map();return _this;}/**
	 * Add a set of points to render.
	 *
	 * @param {string} id - The id to store the points under.
	 * @param {Array} points - The points.
	 *
	 * @returns {PointOverlay} The overlay object, for chaining.
	 */_createClass(PointOverlay,[{key:'addPoints',value:function addPoints(id,points){this.points.set(id,points);if(this.plot){this.refresh();}return this;}/**
	 * Remove a set of points by id from the overlay.
	 *
	 * @param {string} id - The id to store the points under.
	 *
	 * @returns {PointOverlay} The overlay object, for chaining.
	 */},{key:'removePoints',value:function removePoints(id){this.points.delete(id);if(this.plot){this.refresh();}return this;}/**
	 * Remove all points from the layer.
	 *
	 * @returns {PointOverlay} The overlay object, for chaining.
	 */},{key:'clearPoints',value:function clearPoints(){this.clear();this.points=new Map();if(this.plot){this.refresh();}return this;}/**
	 * Return the clipped geometry based on the current cell.
	 *
	 * @param {Cell} cell - The rendering cell.
	 *
	 * @returns {Array} The array of clipped geometry.
	 */},{key:'clipGeometry',value:function clipGeometry(cell){return clipPoints(cell,this.points);}}]);return PointOverlay;}(Overlay);module.exports=PointOverlay;

},{"./Overlay":153}],155:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Overlay=require('./Overlay');// Private Methods
var clipPolygons=function clipPolygons(cell,polygons){var clipped=[];polygons.forEach(function(polygon){var clippedPolygon=cell.bounds.clipPolygon(polygon);if(!clippedPolygon){return;}var result=new Array(clippedPolygon.length);for(var i=0;i<clippedPolygon.length;i++){result[i]=cell.project(clippedPolygon[i]);}clipped.push(result);});return clipped;};/**
 * Class representing a polygon overlay.
 */var PolygonOverlay=function(_Overlay){_inherits(PolygonOverlay,_Overlay);/**
	 * Instantiates a new PolygonOverlay object.
	 *
	 * @param {Object} options - The layer options.
	 * @param {Renderer} options.renderer - The layer renderer.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 */function PolygonOverlay(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PolygonOverlay);var _this=_possibleConstructorReturn(this,(PolygonOverlay.__proto__||Object.getPrototypeOf(PolygonOverlay)).call(this,options));_this.polygons=new Map();return _this;}/**
	 * Add a set of points to render as a single polygon.
	 *
	 * @param {string} id - The id to store the polygon under.
	 * @param {Array} points - The polygon points.
	 *
	 * @returns {PolygonOverlay} The overlay object, for chaining.
	 */_createClass(PolygonOverlay,[{key:'addPolygon',value:function addPolygon(id,points){this.polygons.set(id,points);if(this.plot){this.refresh();}return this;}/**
	 * Remove a polygon by id from the overlay.
	 *
	 * @param {string} id - The id to store the polygon under.
	 *
	 * @returns {PolygonOverlay} The overlay object, for chaining.
	 */},{key:'removePolygon',value:function removePolygon(id){this.polygons.delete(id);if(this.plot){this.refresh();}return this;}/**
	 * Remove all polygons from the layer.
	 *
	 * @returns {PolygonOverlay} The overlay object, for chaining.
	 */},{key:'clearPolylines',value:function clearPolylines(){this.clear();this.polygons=new Map();if(this.plot){this.refresh();}return this;}/**
	 * Return the clipped geometry based on the current cell.
	 *
	 * @param {Cell} cell - The rendering cell.
	 *
	 * @returns {Array} The array of clipped geometry.
	 */},{key:'clipGeometry',value:function clipGeometry(cell){return clipPolygons(cell,this.polygons);}}]);return PolygonOverlay;}(Overlay);module.exports=PolygonOverlay;

},{"./Overlay":153}],156:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Overlay=require('./Overlay');// Private Methods
var clipPolylines=function clipPolylines(cell,polylines){var clipped=[];polylines.forEach(function(polyline){// clip the polyline, resulting in multiple clipped polylines
var clippedPolylines=cell.bounds.clipPolyline(polyline);if(!clippedPolylines){return;}for(var i=0;i<clippedPolylines.length;i++){var clippedPolyline=clippedPolylines[i];for(var j=0;j<clippedPolyline.length;j++){// project in place
clippedPolyline[j]=cell.project(clippedPolyline[j]);}clipped.push(clippedPolyline);}});return clipped;};/**
 * Class representing a polyline overlay.
 */var PolylineOverlay=function(_Overlay){_inherits(PolylineOverlay,_Overlay);/**
	 * Instantiates a new PolylineOverlay object.
	 *
	 * @param {Object} options - The layer options.
	 * @param {Renderer} options.renderer - The layer renderer.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 */function PolylineOverlay(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PolylineOverlay);var _this=_possibleConstructorReturn(this,(PolylineOverlay.__proto__||Object.getPrototypeOf(PolylineOverlay)).call(this,options));_this.polylines=new Map();return _this;}/**
	 * Add a set of points to render as a single polyline.
	 *
	 * @param {string} id - The id to store the polyline under.
	 * @param {Array} points - The polyline points.
	 *
	 * @returns {PolylineOverlay} The overlay object, for chaining.
	 */_createClass(PolylineOverlay,[{key:'addPolyline',value:function addPolyline(id,points){this.polylines.set(id,points);if(this.plot){this.refresh();}return this;}/**
	 * Remove a polyline by id from the overlay.
	 *
	 * @param {string} id - The id to store the polyline under.
	 *
	 * @returns {PolylineOverlay} The overlay object, for chaining.
	 */},{key:'removePolyline',value:function removePolyline(id){this.polylines.delete(id);if(this.plot){this.refresh();}return this;}/**
	 * Remove all polylines from the layer.
	 *
	 * @returns {PolylineOverlay} The overlay object, for chaining.
	 */},{key:'clearPolylines',value:function clearPolylines(){this.clear();this.polylines=new Map();if(this.plot){this.refresh();}return this;}/**
	 * Return the clipped geometry based on the current cell.
	 *
	 * @param {Cell} cell - The rendering cell.
	 *
	 * @returns {Array} The array of clipped geometry.
	 */},{key:'clipGeometry',value:function clipGeometry(cell){return clipPolylines(cell,this.polylines);}}]);return PolylineOverlay;}(Overlay);module.exports=PolylineOverlay;

},{"./Overlay":153}],157:[function(require,module,exports){
'use strict';// Constants
/**
 * Maximum safe integer.
 * @private
 * @constant {number}
 */function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var MAX_SAFE_INT=Math.pow(2,53)-1;// Private Methods
var uid=1;var getUID=function getUID(){uid=(uid+1)%MAX_SAFE_INT;return uid;};/**
 * Class representing a tile.
 */var Tile=/**
	 * Instantiates a new Tile object.
	 *
	 * @param {TileCoord} coord - The coord of the tile.
	 */function Tile(coord){_classCallCheck(this,Tile);this.coord=coord;this.uid=getUID();this.data=null;this.err=null;};module.exports=Tile;

},{}],158:[function(require,module,exports){
'use strict';// Private Methods
var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var mod=function mod(n,m){return(n%m+m)%m;};/**
 * Class representing a tile coordinate.
 */var TileCoord=function(){/**
	 * Instantiates a new TileCoord object.
	 *
	 * @param {number} z - The z component of the tile coordinate.
	 * @param {number} x - The x component of the tile coordinate.
	 * @param {number} y - The y component of the tile coordinate.
	 */function TileCoord(z,x,y){_classCallCheck(this,TileCoord);this.z=z;this.x=x;this.y=y;this.hash=this.z+':'+this.x+':'+this.y;}/**
	 * Returns the XYZ URL string.
	 *
	 * @returns {string} The XYZ URL string.
	 */_createClass(TileCoord,[{key:'xyz',value:function xyz(){var dim=Math.pow(2,this.z);return this.z+'/'+this.x+'/'+(dim-1-this.y);}/**
	 * Returns the TMS URL string.
	 *
	 * @returns {string} The TMS URL string.
	 */},{key:'tms',value:function tms(){return this.z+'/'+this.x+'/'+this.y;}/**
	 * Test if the bounds equals another.
	 *
	 * @param {TileCoord} coord - The coord object to test.
	 *
	 * @returns {boolean} Whether or not the coord objects are equal.
	 */},{key:'equals',value:function equals(coord){return this.z===coord.z&&this.x===coord.x&&this.y===coord.y;}/**
	 * Get the ancestor coord.
	 *
	 * @param {number} offset - The offset of the ancestor from the coord. Optional.
	 *
	 * @returns {TileCoord} The ancestor coord.
	 */},{key:'getAncestor',value:function getAncestor(){var offset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var scale=Math.pow(2,offset);return new TileCoord(this.z-offset,Math.floor(this.x/scale),Math.floor(this.y/scale));}/**
	 * Get the descendants of the coord.
	 *
	 * @param {number} offset - The offset of the descendants from the coord. Optional.
	 *
	 * @returns {Array} The array of descendant coords.
	 */},{key:'getDescendants',value:function getDescendants(){var offset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var scale=Math.pow(2,offset);var coords=new Array(scale*scale);for(var x=0;x<scale;x++){var stride=x*scale;for(var y=0;y<scale;y++){coords[stride+y]=new TileCoord(this.z+offset,this.x*scale+x,this.y*scale+y);}}return coords;}/**
	 * Test if the coord is an ancestor of the provided coord.
	 *
	 * @param {TileCoord} coord - The coord object to test.
	 *
	 * @returns {boolean} Whether or not the provided coord is an ancestor.
	 */},{key:'isAncestorOf',value:function isAncestorOf(coord){if(this.z>=coord.z){return false;}var diff=coord.z-this.z;var scale=Math.pow(2,diff);var x=Math.floor(coord.x/scale);if(this.x!==x){return false;}var y=Math.floor(coord.y/scale);return this.y===y;}/**
	 * Test if the coord is a descendant of the provided coord.
	 *
	 * @param {TileCoord} coord - The coord object to test.
	 *
	 * @returns {boolean} Whether or not the provided coord is a descendant.
	 */},{key:'isDescendantOf',value:function isDescendantOf(coord){return coord.isAncestorOf(this);}/**
	 * Returns the normalized coord.
	 *
	 * @returns {TileCoord} The normalized coord.
	 */},{key:'normalize',value:function normalize(){var dim=Math.pow(2,this.z);return new TileCoord(this.z,mod(this.x,dim),mod(this.y,dim));}/**
	 * Returns the plot coordinate for the bottom-left corner of the coord.
	 *
	 * @returns {Object} The plot position of the coord.
	 */},{key:'getPosition',value:function getPosition(){var dim=Math.pow(2,this.z);return{x:this.x/dim,y:this.y/dim};}/**
	 * Returns the plot coordinate for the center of the coord.
	 *
	 * @returns {Object} The plot position of the center.
	 */},{key:'getCenter',value:function getCenter(){var dim=Math.pow(2,this.z);return{x:(this.x+0.5)/dim,y:(this.y+0.5)/dim};}}]);return TileCoord;}();module.exports=TileCoord;

},{}],159:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var Layer=require('../Layer');var TilePyramid=require('./TilePyramid');// Private Methods
var requestVisibleTiles=function requestVisibleTiles(layer){// get visible coords
var coords=layer.plot.getTargetVisibleCoords();// request tiles
layer.requestTiles(coords);};/**
 * Class representing a tile-based layer.
 */var TileLayer=function(_Layer){_inherits(TileLayer,_Layer);/**
	 * Instantiates a new TileLayer object.
	 *
	 * @param {Object} options - The layer options.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 * @param {boolean} options.hidden - Whether or not the layer is visible.
	 * @param {boolean} options.muted - Whether or not the layer is muted.
	 * @param {number} options.cacheSize - The size of the temporary tile cache.
	 * @param {number} options.numPersistentLevels - The number of persistent levels in the tile pyramid.
	 */function TileLayer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,TileLayer);var _this=_possibleConstructorReturn(this,(TileLayer.__proto__||Object.getPrototypeOf(TileLayer)).call(this,options));_this.muted=defaultTo(options.muted,false);_this.pyramid=new TilePyramid(_this,options);return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the layer to.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */_createClass(TileLayer,[{key:'onAdd',value:function onAdd(plot){_get(TileLayer.prototype.__proto__||Object.getPrototypeOf(TileLayer.prototype),'onAdd',this).call(this,plot);// request tiles if not muted
if(!this.isMuted()){requestVisibleTiles(this);}return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the layer from.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){// clear the underlying pyramid
this.pyramid.clear();_get(TileLayer.prototype.__proto__||Object.getPrototypeOf(TileLayer.prototype),'onRemove',this).call(this,plot);return this;}/**
	 * Returns the tile pyramid of the layer.
	 *
	 * @returns {TilePyramid} The tile pyramid object.
	 */},{key:'getPyramid',value:function getPyramid(){return this.pyramid;}/**
	 * Make the layer invisible.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'hide',value:function hide(){_get(TileLayer.prototype.__proto__||Object.getPrototypeOf(TileLayer.prototype),'hide',this).call(this);return this;}/**
	 * Mutes the layer, it will no longer send any tile requests.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'mute',value:function mute(){this.muted=true;return this;}/**
	 * Unmutes the layer and immediately requests all visible tiles.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'unmute',value:function unmute(){if(this.isMuted()){this.muted=false;if(this.plot){// request visible tiles
requestVisibleTiles(this);}}return this;}/**
	 * Returns true if the layer is muted.
	 *
	 * @returns {boolean} Whether or not the layer is muted.
	 */},{key:'isMuted',value:function isMuted(){return this.muted;}/**
	 * Unmutes and shows the layer.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'enable',value:function enable(){this.show();this.unmute();return this;}/**
	 * Mutes and hides the layer.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'disable',value:function disable(){this.hide();this.mute();return this;}/**
	 * Returns true if the layer is disabled (muted and hidden).
	 *
	 * @returns {boolean} Whether or not the layer is disabled.
	 */},{key:'isDisabled',value:function isDisabled(){return this.isMuted()&&this.isHidden();}/**
	 * Clears any persisted state in the layer and refreshes the underlying
	 * data. This involves emptying the tile pyramid and re-requesting all the
	 * tiles.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 *//**
 	 * Clears any persisted state in the layer and refreshes the underlying
 	 * data.
 	 */},{key:'refresh',value:function refresh(){// clear the underlying pyramid
this.pyramid.clear();// request if attached and not muted
if(this.plot&&!this.isMuted()){// request visible tiles
requestVisibleTiles(this);}_get(TileLayer.prototype.__proto__||Object.getPrototypeOf(TileLayer.prototype),'refresh',this).call(this);return this;}/**
	 * Request a specific tile.
	 *
	 * @param {TileCoord} coord - The coord of the tile to request.
	 * @param {Function} done - The callback function to execute upon completion.
	 */},{key:'requestTile',value:function requestTile(coord,done){done(null,null);}/**
	 * Request an array of tiles.
	 *
	 * @param {Array} coords - The coords of the tiles to request.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'requestTiles',value:function requestTiles(coords){if(this.isMuted()){return this;}this.pyramid.requestTiles(coords);return this;}}]);return TileLayer;}(Layer);module.exports=TileLayer;

},{"../Layer":152,"./TilePyramid":161,"lodash/defaultTo":109}],160:[function(require,module,exports){
'use strict';/**
 * Class representing a partial tile.
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var TilePartial=function(){/**
	 * Instantiates a new TilePartial object.
	 *
	 * A TilePartial is used to render at least a portion of a missing tile at
	 * the closest available level-of-detail. There are three cases of
	 * instantiation.
	 *
	 * A) Closest available level-of-detail is an ancestor tile.
	 *    - The "target" tile is completely covered by a portion of the "found"
	 *      tile.
	 *    - There is no positional offset nor scaling of the "found" tile, it
	 *      will cover the "target" tile in its entirely.
	 *    - There is a uv offset to render the relevant portion of the "found"
	 *      tile.
	 *
	 * B) Closest available level-of-detail is a descendant tile.
	 *    - The "target" tile is partially covered by the "found" tile.
	 *    - There is a positional offset and scale of the "found" tile relative
	 *      to the "target" tile.
	 *    - There is no uv offset, the "found" tile is rendered in its entirety.
	 *
	 * C) Closest available level-of-detail is an ancestor of the "target", but
	 *    is used to cover a missing descendant. This occurs when one or more
	 *    descendant tiles cover a portion of the "target" tile, but an ancestor
	 *    is required to fill in a missing descendant.
	 *    - The "target" tile is partially covered by the "found" tile.
	 *    - There is a positional offset and scale of the "found" tile relative
	 *      to the descendant the tile is covering.
	 *    - There is a uv offset to render the relevant portion of the "found"
	 *      tile which covers the descendant.
	 *
	 * @param {Coord} target - The coordinate of the tile that is being substituted.
	 * @param {Tile} tile - The tile data of the partial found.
	 * @param {Coord} relative - The coordinate of the tile to position the found tile relative to.
	 */function TilePartial(target,tile,relative){_classCallCheck(this,TilePartial);this.target=target;this.tile=tile;this.relative=relative;}/**
	 * Instantiate a TilePartial object from the tile itself.
	 *
	 * @param {Tile} tile - The tile data of the partial.
	 *
	 * @returns {TilePartial} The TilePartial object.
	 */_createClass(TilePartial,null,[{key:'fromTile',value:function fromTile(tile){return new TilePartial(tile,tile,null);}/**
	 * Instantiate a TilePartial object from an ancestor.
	 *
	 * @param {Coord} target - The coordinate of the tile that is being substituted.
	 * @param {Tile} tile - The tile ancestor data of the partial.
	 * @param {Coord} relative - The coordinate of the tile to position the found tile relative to.
	 *
	 * @returns {TilePartial} The TilePartial object.
	 */},{key:'fromAncestor',value:function fromAncestor(target,tile,relative){return new TilePartial(target,tile,relative);}/**
	 * Instantiate a TilePartial object from a descendant.
	 *
	 * @param {Coord} target - The coordinate of the tile that is being substituted.
	 * @param {Tile} tile - The tile ancestor data of the partial.
	 *
	 * @returns {TilePartial} The TilePartial object.
	 */},{key:'fromDescendant',value:function fromDescendant(target,tile){return new TilePartial(target,tile,null);}}]);return TilePartial;}();module.exports=TilePartial;

},{}],161:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var throttle=require('lodash/throttle');var EventType=require('../../event/EventType');var TileEvent=require('../../event/TileEvent');var LRUCache=require('../../util/LRUCache');var Tile=require('./Tile');var TilePartial=require('./TilePartial');// Constants
/**
 * number of the tiles held in the pyramid.
 * @private
 * @constant {number}
 */var CACHE_SIZE=256;/**
 * number of persistent zoom levels held in the pyramids.
 * @private
 * @constant {number}
 */var PERSISTANT_LEVELS=4;/**
 * Loaded event throttle in milliseconds.
 * @private
 * @constant {number}
 */var LOADED_THROTTLE_MS=200;/**
 * The maximum distance to traverse when checking for tile descendants.
 * @private
 * @constant {number}
 */var MAX_DESCENDENT_DIST=4;// Private Methods
var add=function add(pyramid,tile){if(tile.coord.z<pyramid.numPersistentLevels){// persistent tiles
if(pyramid.persistents.has(tile.coord.hash)){throw'Tile of coord '+tile.coord.hash+' already exists in the pyramid';}pyramid.persistents.set(tile.coord.hash,tile);}else{// non-persistent tiles
if(pyramid.tiles.has(tile.coord.hash)){throw'Tile of coord '+tile.coord.hash+' already exists in the pyramid';}pyramid.tiles.set(tile.coord.hash,tile);}// store in level arrays
if(!pyramid.levels.has(tile.coord.z)){pyramid.levels.set(tile.coord.z,[]);}pyramid.levels.get(tile.coord.z).push(tile);// emit add
pyramid.layer.emit(EventType.TILE_ADD,new TileEvent(pyramid.layer,tile));};var remove=function remove(pyramid,tile){// only check for persistent since we it will already be removed from lru
// cache
if(tile.coord.z<pyramid.numPersistentLevels){if(!pyramid.persistents.has(tile.coord.hash)){throw'Tile of coord '+tile.coord.hash+' does not exists in the pyramid';}pyramid.persistents.delete(tile.coord.hash);}// remove from levels
var level=pyramid.levels.get(tile.coord.z);level.splice(level.indexOf(tile),1);if(level.length===0){pyramid.levels.delete(tile.coord.z);}// emit remove
pyramid.layer.emit(EventType.TILE_REMOVE,new TileEvent(pyramid.layer,tile));};var sumPowerOfFour=function sumPowerOfFour(n){return 1/3*(Math.pow(4,n)-1);};var checkIfLoaded=function checkIfLoaded(pyramid){// if no more pending tiles, emit load
if(pyramid.pending.size===0){pyramid.emitLoad(new TileEvent(pyramid.layer,null));}};var sortAroundCenter=function sortAroundCenter(plot,pairs){// get the plot center position
var center=plot.getTargetViewportCenter();// sort the requests by distance from center tile
pairs.sort(function(a,b){var aCenter=a.coord.getCenter();var bCenter=b.coord.getCenter();var dax=center.x-aCenter.x;var day=center.y-aCenter.y;var dbx=center.x-bCenter.x;var dby=center.y-bCenter.y;var da=dax*dax+day*day;var db=dbx*dbx+dby*dby;return da-db;});return pairs;};var removeDuplicates=function removeDuplicates(pairs){var seen=new Map();return pairs.filter(function(pair){var hash=pair.ncoord.hash;return seen.has(hash)?false:seen.set(hash,true);});};var removePendingOrExisting=function removePendingOrExisting(pyramid,pairs){return pairs.filter(function(pair){// we already have the tile, or it's currently pending
// NOTE: use `get` here to update the recentness of the tile in LRU
return!pyramid.get(pair.ncoord)&&!pyramid.isPending(pair.ncoord);});};var flagTileAsStale=function flagTileAsStale(pyramid,tile){var hash=tile.coord.hash;var uids=pyramid.stale.get(hash);if(!uids){uids=new Map();pyramid.stale.set(hash,uids);}uids.set(tile.uid,true);};var isTileStale=function isTileStale(pyramid,tile){var hash=tile.coord.hash;// check if uid is flagged as stale
var uids=pyramid.stale.get(hash);if(uids&&uids.has(tile.uid)){// tile is stale
uids.delete(tile.uid);if(uids.size===0){pyramid.stale.delete(hash);}return true;}return false;};var shouldDiscard=function shouldDiscard(pyramid,tile){var plot=pyramid.layer.plot;if(!plot){// layer has been removed from plot, discard tile
// NOTE: this should _NEVER_ happen, since when a layer is remove from
// the plot, the pending tiles are all flagged as stale.
return true;}// check if tile is in view, if not, discard
var viewport=plot.getTargetViewport();return!viewport.isInView(tile.coord,plot.wraparound);};/**
 * Class representing a pyramid of tiles.
 */var TilePyramid=function(){/**
	 * Instantiates a new TilePyramid object.
	 *
	 * @param {Layer} layer - The layer object.
	 * @param {Object} options - The pyramid options.
	 * @param {number} options.cacheSize - The size of the tile cache.
	 * @param {number} options.numPersistentLevels - The number of persistent levels in the pyramid.
	 */function TilePyramid(layer){var _this=this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,TilePyramid);if(!layer){throw'No layer parameter provided';}this.cacheSize=defaultTo(options.cacheSize,CACHE_SIZE);this.numPersistentLevels=defaultTo(options.numPersistentLevels,PERSISTANT_LEVELS);this.layer=layer;this.levels=new Map();this.persistents=new Map();this.pending=new Map();this.stale=new Map();this.tiles=new LRUCache({capacity:this.cacheSize,onRemove:function onRemove(tile){remove(_this,tile);}});// create throttled emit load event for this layer
this.emitLoad=throttle(function(event){_this.layer.emit(EventType.LOAD,event);},LOADED_THROTTLE_MS);}/**
	 * Returns the total capacity of the tile pyramid.
	 *
	 * @returns {number} The total capacity of the pyramid.
	 */_createClass(TilePyramid,[{key:'getCapacity',value:function getCapacity(){return this.cacheSize+sumPowerOfFour(this.numPersistentLevels);}/**
	 * Empties the current pyramid of all tiles, flags any pending tiles as
	 * stale.
	 */},{key:'clear',value:function clear(){var _this2=this;// any pending tiles are now flagged as stale
this.pending.forEach(function(tile){// flag uid as stale
flagTileAsStale(_this2,tile);});this.pending=new Map();// fresh map
// clear persistent tiles
this.persistents.forEach(function(tile){remove(_this2,tile);});this.persistents.clear();// clear lru cache
this.tiles.clear();}/**
	 * Test whether or not a coord is held in cache in the pyramid.
	 *
	 * @param {TileCoord} ncoord - The normalized coord to test.
	 *
	 * @returns {boolean} Whether or not the coord exists in the pyramid.
	 */},{key:'has',value:function has(ncoord){if(ncoord.z<this.numPersistentLevels){return this.persistents.has(ncoord.hash);}return this.tiles.has(ncoord.hash);}/**
	 * Iterates over and executes the provided function for all tiles.
	 *
	 * @param {Function} fn - The function to execute on each tile.
	 */},{key:'forEach',value:function forEach(fn){this.persistents.forEach(fn);this.tiles.forEach(fn);}/**
	 * Test whether or not a coord is currently pending.
	 *
	 * @param {TileCoord} ncoord - The normalized coord to test.
	 *
	 * @returns {boolean} Whether or not the coord is currently pending.
	 */},{key:'isPending',value:function isPending(ncoord){return this.pending.has(ncoord.hash);}/**
	 * Returns the tile matching the provided coord. If the tile does not
	 * exist, returns undefined.
	 *
	 * @param {TileCoord} ncoord - The normalized coord of the tile to return.
	 *
	 * @returns {Tile} The tile object.
	 */},{key:'get',value:function get(ncoord){if(ncoord.z<this.numPersistentLevels){return this.persistents.get(ncoord.hash);}return this.tiles.get(ncoord.hash);}/**
	 * Returns the ancestor tile of the coord at the provided offset. If no
	 * tile exists in the pyramid, returns undefined.
	 *
	 * @param {TileCoord} ncoord - The normalized coord of the tile.
	 * @param {number} dist - The offset from the tile.
	 *
	 * @returns {Tile} The ancestor tile of the provided coord.
	 */},{key:'getAncestor',value:function getAncestor(ncoord,dist){var ancestor=ncoord.getAncestor(dist);return this.get(ancestor);}/**
	 * Returns the descendant tiles of the coord at the provided offset. If at
	 * least one tile exists in the pyramid, an array of size 4^dist will be
	 * returned. Each element will either be a tile (in the case that it exists)
	 * or a coord (in the case that it does not exist). If no descendant tiles
	 * are found in the pyramid, returns undefined.
	 *
	 * @param {TileCoord} ncoord - The normalized coord of the tile.
	 * @param {number} dist - The offset from the tile.
	 *
	 * @returns {Array} The descendant tiles and or coordinates of the provided coord.
	 */},{key:'getDescendants',value:function getDescendants(ncoord,dist){// get coord descendants
var descendants=ncoord.getDescendants(dist);// check if we have any
var found=false;for(var i=0;i<descendants.length;i++){if(this.has(descendants[i])){found=true;break;}}// if so return what we have
if(found){var res=new Array(descendants.length);for(var _i=0;_i<descendants.length;_i++){var descendant=descendants[_i];// add tile if it exists, coord if it doesn't
res[_i]=this.get(descendant)||descendant;}return res;}return undefined;}/**
	 * Requests tiles for the provided coords. If the tiles already exist
	 * in the pyramid or is currently pending no request is made.
	 *
	 * @param {Array} coords - The array of coords to request.
	 */},{key:'requestTiles',value:function requestTiles(coords){var _this3=this;// we need both the normalized an un-normalized coords.
// normalized coords are used for requests while un-normalized are used
// to sort them around the viewport center
var pairs=coords.map(function(coord){return{coord:coord,ncoord:coord.normalize()};});// remove any duplicates
pairs=removeDuplicates(pairs);// remove any tiles we already have or that are currently pending
pairs=removePendingOrExisting(this,pairs);// sort coords by distance from viewport center
pairs=sortAroundCenter(this.layer.plot,pairs);// generate tiles and flag as pending
// NOTE: we flag them all now incase a `clear` is called inside the
// `requestTile` call.
var tiles=pairs.map(function(pair){var tile=new Tile(pair.ncoord);// add tile to pending array
_this3.pending.set(tile.coord.hash,tile);return tile;});// request the tiles
var _loop=function _loop(i){var tile=tiles[i];// emit request
_this3.layer.emit(EventType.TILE_REQUEST,new TileEvent(_this3.layer,tile));// request tile
_this3.layer.requestTile(tile.coord,function(err,data){// check if stale, clears stale status
var isStale=isTileStale(_this3,tile);// if not stale remove tile from pending
if(!isStale){_this3.pending.delete(tile.coord.hash);}// check err
if(err!==null){// add err
tile.err=err;// emit failure
_this3.layer.emit(EventType.TILE_FAILURE,new TileEvent(_this3.layer,tile));// if not stale, check if loaded
if(!isStale){checkIfLoaded(_this3);}return;}// add data to the tile
tile.data=data;// check if tile should be discarded
if(isStale||shouldDiscard(_this3,tile)){// emit discard
_this3.layer.emit(EventType.TILE_DISCARD,new TileEvent(_this3.layer,tile));// if not stale, check if loaded
if(!isStale){checkIfLoaded(_this3);}return;}// add to tile pyramid
add(_this3,tile);// check if loaded
checkIfLoaded(_this3);// flag as dirty
_this3.layer.plot.setDirty();});};for(var i=0;i<tiles.length;i++){_loop(i);}}/**
	 * If the tile exists in the pyramid, return it. Otherwise return the
	 * closest available level-of-detail for tile, this may be a single ancestor
	 * or multiple descendants, or a combination of both.
	 *
	 * If no ancestor or descendants exist, return undefined.
	 *
	 * @param {TileCoord} ncoord - The normalized coord of the tile.
	 *
	 * @returns {Array} The array of tile partials that closest match the provided coord.
	 */},{key:'getAvailableLOD',value:function getAvailableLOD(ncoord){// check if we have the tile
var tile=this.get(ncoord);if(tile){// if exists, return it
return[TilePartial.fromTile(tile)];}// if not, find the closest available level-of-detail
// first, get the available levels of detail, ascending in distance
// from the original coord zoom
var zoom=ncoord.z;var levels=[];this.levels.forEach(function(_,key){if(key!==zoom){levels.push(key);}});levels.sort(function(a,b){// give priority to ancestor levels since they are cheaper
var da=a>zoom?a-zoom:zoom-a-0.5;var db=b>zoom?b-zoom:zoom-b-0.5;return da-db;});var results=[];var queue=[];var current=ncoord;var level=levels.shift();// second, iterate through available levels searching for the closest
// level-of-detail for the current head of the queue
while(current!==undefined&&level!==undefined){if(level<current.z){// try to find ancestor
var dist=current.z-level;var ancestor=this.getAncestor(current,dist);if(ancestor){// tile found, create a tile partial from the ancestor
results.push(TilePartial.fromAncestor(ncoord,// target
ancestor,// tile
current));// relative
// pop next coord to search off the queue
current=queue.shift();continue;}}else{// descendant checks are much more expensive, so limit this
// based on distance to the original coord zoom
// NOTE: this distance calculation is safe because it is always
// true that "current.z >= zoom" because only descendant coords
// are appended to the queue.
// therefore in the case that "level >= current.z", then
// "level >= zoom" must be true as well.
var ndist=level-zoom;if(ndist<MAX_DESCENDENT_DIST){// try to find descendant
var _dist=level-current.z;var descendants=this.getDescendants(current,_dist);if(descendants){for(var j=0;j<descendants.length;j++){var descendant=descendants[j];if(descendant.coord){// tile found,  create a tile partial from the
// descendant
results.push(TilePartial.fromDescendant(ncoord,// target
descendant));// tile
}else{// no tile found, descendant is a coord
queue.push(descendant);}continue;}current=queue.shift();}}}// nothing found in level, we can safely remove it from the search
level=levels.shift();}return results.length>0?results:undefined;}}]);return TilePyramid;}();module.exports=TilePyramid;

},{"../../event/EventType":141,"../../event/TileEvent":144,"../../util/LRUCache":187,"./Tile":157,"./TilePartial":160,"lodash/defaultTo":109,"lodash/throttle":133}],162:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Bounds=require('../geometry/Bounds');/**
 * The size of the cell, in pixels.
 * @private
 * @constant {number}
 */var CELL_SIZE=Math.pow(2,16);/**
 * The half size of the cell, in pixels.
 * @private
 * @constant {number}
 */var CELL_HALF_SIZE=CELL_SIZE/2;/**
 * Class representing a cell for clipping a rendering space.
 * @private
 */var Cell=function(){/**
	 * Instantiates a new Cell object.
	 *
	 * @param {number} zoom - The zoom the the cells is generated for.
	 * @param {Object} center - The plot position of the center of the cell.
	 * @param {number} extent - The pixel extent of the plot at the time of generation.
	 */function Cell(zoom,center,extent){_classCallCheck(this,Cell);var halfSize=CELL_HALF_SIZE/extent;var offset={x:center.x-halfSize,y:center.y-halfSize};this.zoom=zoom;this.halfSize=halfSize;this.center=center;this.offset=offset;this.extent=extent;this.bounds=new Bounds(center.x-halfSize,center.x+halfSize,center.y-halfSize,center.y+halfSize);}/**
	 * Project a normalized plot coordinate to the pixel space of the cell.
	 *
	 * @param {Object} pos - The normalized plot coordinate.
	 * @param {number} zoom - The zoom of the plot pixel space to project to. Optional.
	 *
	 * @returns {Object} The coordinate in cell pixel space.
	 */_createClass(Cell,[{key:'project',value:function project(pos){var zoom=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.zoom;var scale=Math.pow(2,zoom-this.zoom)*this.extent;return{x:(pos.x-this.offset.x)*scale,y:(pos.y-this.offset.y)*scale};}/**
	 * Unproject a coordinate from the pixel space of the cell to a normalized
	 * plot coordinate.
	 *
	 * @param {Object} px - The plot pixel coordinate.
	 * @param {number} zoom - The zoom of the plot pixel space to unproject from. Optional.
	 *
	 * @returns {Object} The normalized plot coordinate.
	 */},{key:'unproject',value:function unproject(px){var zoom=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.zoom;var scale=Math.pow(2,zoom-this.zoom)*this.extent;return{x:px.x/scale+this.offset.x,y:px.y/scale+this.offset.y};}}]);return Cell;}();module.exports=Cell;

},{"../geometry/Bounds":146}],163:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var clamp=require('lodash/clamp');var defaultTo=require('lodash/defaultTo');var throttle=require('lodash/throttle');var EventEmitter=require('events');var EventType=require('../event/EventType');var EventBroadcaster=require('../event/EventBroadcaster');var EventDelegator=require('../event/EventDelegator');var Event=require('../event/Event');var ResizeEvent=require('../event/ResizeEvent');var RenderBuffer=require('../webgl/RenderBuffer');var ClickHandler=require('./handler/ClickHandler');var MouseHandler=require('./handler/MouseHandler');var PanHandler=require('./handler/PanHandler');var ZoomHandler=require('./handler/ZoomHandler');var Cell=require('./Cell');var Viewport=require('./Viewport');// Constants
/**
 * Pan request throttle in milliseconds.
 * @private
 * @constant {number}
 */var PAN_THROTTLE_MS=100;/**
 * Resize request throttle in milliseconds.
 * @private
 * @constant {number}
 */var RESIZE_THROTTLE_MS=200;/**
 * Zoom request throttle in milliseconds.
 * @private
 * @constant {number}
 */var ZOOM_THROTTLE_MS=400;/**
 * The maximum zoom delta until a cell update event.
 * @private
 * @constant {number}
 */var CELL_ZOOM_DELTA=1.0;/**
 * The maximum zoom level supported.
 * @private
 * @constant {number}
 */var MAX_ZOOM=24;/**
 * Click handler symbol.
 * @private
 * @constant {Symbol}
 */var CLICK=Symbol();/**
 * Mouse handler symbol.
 * @private
 * @constant {Symbol}
 */var MOUSE=Symbol();/**
 * Pan handler symbol.
 * @private
 * @constant {Symbol}
 */var PAN=Symbol();/**
 * Zoom handler symbol.
 * @private
 * @constant {Symbol}
 */var ZOOM=Symbol();/**
 * Event handlers symbol.
 * @private
 * @constant {Symbol}
 */var HANDLERS=Symbol();/**
 * Event delegators symbol.
 * @private
 * @constant {Symbol}
 */var DELEGATOR=Symbol();/**
 * Event broadcasters symbol.
 * @private
 * @constant {Symbol}
 */var BROADCASTER=Symbol();/**
 * Dirty plot symbol.
 * @private
 * @constant {Symbol}
 */var DIRTY=Symbol();// Private Methods
var requestTiles=function requestTiles(){// get all visible coords in the target viewport
var coords=this.getTargetVisibleCoords();// for each layer
this.layers.forEach(function(layer){if(layer.requestTiles){// request tiles
layer.requestTiles(coords);}});return this;};var resize=function resize(plot){var current={width:plot.container.offsetWidth,height:plot.container.offsetHeight};var prev=plot.getViewportPixelSize();var center=plot.viewport.getCenter();if(prev.width!==current.width||prev.height!==current.height||plot.pixelRatio!==window.devicePixelRatio){// store device pixel ratio
plot.pixelRatio=window.devicePixelRatio;// resize canvas
plot.canvas.style.width=current.width+'px';plot.canvas.style.height=current.height+'px';plot.canvas.width=current.width*plot.pixelRatio;plot.canvas.height=current.height*plot.pixelRatio;// resize renderbuffer
plot.renderBuffer.resize(current.width*plot.pixelRatio,current.height*plot.pixelRatio);// update viewport
var extent=plot.getPixelExtent();plot.viewport.width=current.width/extent;plot.viewport.height=current.height/extent;// re-center viewport
plot.viewport.centerOn(center);// request tiles
plot.resizeRequest();// emit resize
plot.setDirty();plot.emit(EventType.RESIZE,new ResizeEvent(plot,prev,current));}};var updateCell=function updateCell(plot){var zoom=plot.getTargetZoom();var center=plot.getTargetViewportCenter();var extent=plot.getTargetPixelExtent();var size=plot.getViewportPixelSize();var cell=new Cell(zoom,center,extent);var refresh=false;// check if no cell exists
if(!plot.cell){refresh=true;}else{// check if we are outside of one zoom level from last
var zoomDist=Math.abs(plot.cell.zoom-cell.zoom);if(zoomDist>=CELL_ZOOM_DELTA){refresh=true;}else{// check if we are withing buffer distance of the cell bounds
var xDist=plot.cell.halfSize-size.width/plot.cell.extent;var yDist=plot.cell.halfSize-size.height/plot.cell.extent;if(Math.abs(cell.center.x-plot.cell.center.x)>xDist||Math.abs(cell.center.y-plot.cell.center.y)>yDist){refresh=true;}}}if(refresh){// update cell
plot.cell=cell;// emit cell refresh
plot.emit(EventType.CELL_UPDATE,new Event(cell));}};var reset=function reset(plot){if(!plot.wraparound){// if there is no wraparound, do not reset
return;}// resets the position of the viewport relative to the plot such that
// the plot native coordinate range is within the viewports bounds.
// get viewport width in plot coords
var width=Math.ceil(plot.viewport.width/1.0);// past the left bound of the viewport
if(plot.viewport.x>1.0){plot.viewport.x-=width;if(plot.isPanning()){plot.panAnimation.start.x-=width;}}// past the right bound of the viewport
if(plot.viewport.x+plot.viewport.width<0){plot.viewport.x+=width;if(plot.isPanning()){plot.panAnimation.start.x+=width;}}};var frame=function frame(plot){// get frame timestamp
var timestamp=Date.now();// emit frame event
plot.emit(EventType.FRAME,new Event(plot,timestamp));// update size
resize(plot);if(!plot.dirtyChecking||plot.isDirty()){// clear flag now, this way layers that may be animating can signal
// that the animation is not complete by flagging as dirty during the
// draw call.
plot.clearDirty();// apply the zoom animation
if(plot.isZooming()){if(plot.zoomAnimation.update(timestamp)){plot.zoomAnimation=null;}}// apply the pan animation
if(plot.isPanning()){if(plot.panAnimation.update(timestamp)){plot.panAnimation=null;}plot.panRequest();}// reset viewport / plot
reset(plot);// update cell
updateCell(plot);// get context
var gl=plot.getRenderingContext();// clear the backbuffer
gl.clearColor(0,0,0,0);gl.clear(gl.COLOR_BUFFER_BIT);// set the viewport
var size=plot.getViewportPixelSize();gl.viewport(0,0,size.width*plot.pixelRatio,size.height*plot.pixelRatio);// sort layers by z-index
var layers=plot.getSortedLayers();// render each layer
layers.forEach(function(layer){if(!layer.isHidden()){layer.draw(timestamp);}});}// request next frame
plot.frameRequest=requestAnimationFrame(function(){frame(plot);});};/**
 * Class representing a plot.
 */var Plot=function(_EventEmitter){_inherits(Plot,_EventEmitter);/**
	 * Instantiates a new Plot object.
	 *
	 * @param {string} selector - The selector for the container element.
	 * @param {Object} options - The plot options.
	 * @param {number} options.tileSize - The dimension in pixels of a tile.
	 * @param {number} options.zoom - The zoom of the plot.
	 * @param {number} options.minZoom - The minimum zoom of the plot.
	 * @param {number} options.maxZoom - The maximum zoom of the plot.
	 * @param {Object} options.center - The center of the plot, in plot pixels.
	 * @param {boolean} options.wraparound - Whether or not the plot wraps around.
	 * @param {boolean} options.context - The rendering context type, defaults to `webgl`.
	 * @param {boolean} options.contextAttributes - The rendering context attribtues argument. Optional.
	 * @param {boolean} options.dirtyChecking - Whether or not the plot uses dirty checking or renders every frame.
	 *
	 * @param {number} options.panThrottle - Pan request throttle timeout in ms.
	 * @param {number} options.resizeThrottle - Resize request throttle timeout in ms.
	 * @param {number} options.zoomThrottle - Zoom request throttle timeout in ms.
	 *
	 * @param {number} options.inertia - Whether or not pan inertia is enabled.
	 * @param {number} options.inertiaEasing - The inertia easing factor.
	 * @param {number} options.inertiaDeceleration - The inertia deceleration factor.
	 *
	 * @param {number} options.continuousZoom - Whether or not continuous zoom is enabled.
	 * @param {number} options.zoomDuration - The duration of the zoom animation.
	 * @param {number} options.maxConcurrentZooms - The maximum concurrent zooms in a single batch.
	 * @param {number} options.deltaPerZoom - The scroll delta required per zoom level.
	 * @param {number} options.zoomDebounce - The debounce duration of the zoom in ms.
	 */function Plot(selector){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Plot);var _this=_possibleConstructorReturn(this,(Plot.__proto__||Object.getPrototypeOf(Plot)).call(this));_this.container=document.querySelector(selector);if(!_this.container){throw'Element could not be found for selector '+selector;}// set pixel ratio
_this.pixelRatio=window.devicePixelRatio;// create canvas element
_this.canvas=document.createElement('canvas');_this.canvas.style.width=_this.container.offsetWidth+'px';_this.canvas.style.height=_this.container.offsetHeight+'px';_this.canvas.width=_this.container.offsetWidth*_this.pixelRatio;_this.canvas.height=_this.container.offsetHeight*_this.pixelRatio;_this.container.appendChild(_this.canvas);// get rendering context
_this.ctx=_this.canvas.getContext('webgl',options.contextAttributes)||_this.canvas.getContext('experimental-webgl',options.contextAttributes);// MS Edge
if(!_this.ctx){throw'Unable to create a WebGLRenderingContext, please ensure your browser supports WebGL';}// create renderbuffer
_this.renderBuffer=new RenderBuffer(_this.ctx,_this.canvas.width,_this.canvas.height);// tile size in pixels
_this.tileSize=defaultTo(options.tileSize,256);// min and max zoom of the plot
_this.minZoom=defaultTo(options.minZoom,0);_this.maxZoom=defaultTo(options.maxZoom,MAX_ZOOM);// current zoom of the plot
_this.zoom=defaultTo(options.zoom,0);_this.zoom=clamp(_this.zoom,_this.minZoom,_this.maxZoom);// set viewport
var span=Math.pow(2,_this.zoom);var width=_this.canvas.offsetWidth/span;var height=_this.canvas.offsetHeight/span;_this.viewport=new Viewport(0,0,width,height);// center the plot
var center=defaultTo(options.center,{x:0.5,y:0.5});_this.viewport.centerOn(center);// generate cell
_this.cell=null;updateCell(_this);// wraparound
_this.wraparound=defaultTo(options.wraparound,false);// throttled request methods
var panThrottle=defaultTo(options.panThrottle,PAN_THROTTLE_MS);var resizeThrottle=defaultTo(options.resizeThrottle,RESIZE_THROTTLE_MS);var zoomThrottle=defaultTo(options.zoomThrottle,ZOOM_THROTTLE_MS);_this.panRequest=throttle(requestTiles,panThrottle,{leading:false// invoke only on trailing edge
});_this.resizeRequest=throttle(requestTiles,resizeThrottle,{leading:false// invoke only on trailing edge
});_this.zoomRequest=throttle(requestTiles,zoomThrottle,{leading:false// invoke only on trailing edge
});// layers
_this.layers=[];// frame request
_this.frameRequest=null;// create and enable handlers
_this[HANDLERS]=new Map();_this[HANDLERS].set(CLICK,new ClickHandler(_this,options));_this[HANDLERS].set(MOUSE,new MouseHandler(_this,options));_this[HANDLERS].set(PAN,new PanHandler(_this,options));_this[HANDLERS].set(ZOOM,new ZoomHandler(_this,options));_this[HANDLERS].forEach(function(handler){handler.enable();});// delegator
_this[DELEGATOR]=new EventDelegator(_this);// delegate mouse / click events to layers
_this[DELEGATOR].delegate(EventType.CLICK);_this[DELEGATOR].delegate(EventType.DBL_CLICK);_this[DELEGATOR].delegate(EventType.MOUSE_MOVE);_this[DELEGATOR].delegate(EventType.MOUSE_UP);_this[DELEGATOR].delegate(EventType.MOUSE_DOWN);// broadcaster
_this[BROADCASTER]=new EventBroadcaster(_this);// broadcast zoom / pan events to layers
_this[BROADCASTER].broadcast(EventType.ZOOM_START);_this[BROADCASTER].broadcast(EventType.ZOOM);_this[BROADCASTER].broadcast(EventType.ZOOM_END);_this[BROADCASTER].broadcast(EventType.PAN_START);_this[BROADCASTER].broadcast(EventType.PAN);_this[BROADCASTER].broadcast(EventType.PAN_END);// whether or not to use dirty checking
_this.dirtyChecking=defaultTo(options.dirtyChecking,true);// flag as dirty
_this[DIRTY]=true;// begin frame loop
frame(_this);return _this;}/**
	 * Destroys the plots association with the underlying canvas element and
	 * disables all event handlers.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */_createClass(Plot,[{key:'destroy',value:function destroy(){var _this2=this;// stop animation loop
cancelAnimationFrame(this.frameRequest);this.frameRequest=null;// disable handlers
this[HANDLERS].forEach(function(handler){handler.disable();});// remove layers
this.layers.forEach(function(layer){_this2.remove(layer);});// destroy context
this.ctx=null;// remove canvas
this.container.removeChild(this.canvas);this.canvas=null;this.container=null;this.renderBuffer=null;return this;}/**
	 * Flags the plot as dirty singalling that it should be redrawn in the next
	 * frame.
	 */},{key:'setDirty',value:function setDirty(){this[DIRTY]=true;}/**
	 * Check if the plot is dirty and requires a redraw.
	 *
	 * @returns {boolean} Whether or not the plot should be redrawn.
 	*/},{key:'isDirty',value:function isDirty(){return this[DIRTY]||this.isPanning()||this.isZooming();}/**
	 * Clears the dirty flag for the next frame.
	 */},{key:'clearDirty',value:function clearDirty(){this[DIRTY]=false;}/**
	 * Adds a layer to the plot.
	 *
	 * @param {Layer} layer - The layer to add to the plot.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'add',value:function add(layer){if(!layer){throw'No argument provided';}if(this.layers.indexOf(layer)!==-1){throw'Provided layer is already attached to the plot';}this.layers.push(layer);layer.onAdd(this);this.setDirty();return this;}/**
	 * Removes a layer from the plot.
	 *
	 * @param {Layer} layer - The layer to remove from the plot.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'remove',value:function remove(layer){if(!layer){throw'No argument provided';}var index=this.layers.indexOf(layer);if(index===-1){throw'Provided layer is not attached to the plot';}this.layers.splice(index,1);layer.onRemove(this);this.setDirty();return this;}/**
	 * Returns the rendering context of the plot.
	 *
	 * @returns {WebGLRenderingContext|CanvasRenderingContext2D} The context object.
	 */},{key:'getRenderingContext',value:function getRenderingContext(){return this.ctx;}/**
	 * Returns all the layer objects attached to the plot, in descending
	 * order of z-index.
	 */},{key:'getSortedLayers',value:function getSortedLayers(){// sort by z-index
return this.layers.sort(function(a,b){return a.getZIndex()-b.getZIndex();});}},{key:'getZoom',/**
	 * Returns the current zoom of the plot.
	 *
	 * @returns {number} The current zoom of the plot.
	 */value:function getZoom(){return this.zoom;}/**
	 * Returns the target zoom of the plot. If the plot is actively zooming, it
	 * will return the destination zoom. If the plot is not actively zooming, it
	 * will return the current zoom.
	 *
	 * @returns {number} The target zoom of the plot.
	 */},{key:'getTargetZoom',value:function getTargetZoom(){if(this.isZooming()){// if zooming, use the target level
return this.zoomAnimation.targetZoom;}// if not zooming, use the current level
return this.zoom;}/**
	 * Returns the current viewport of the plot.
	 *
	 * @returns {number} The current viewport of the plot.
	 */},{key:'getViewport',value:function getViewport(){return this.viewport;}/**
	 * Returns the target viewport of the plot. If the plot is actively zooming,
	 * it will return the target viewport. If the plot is not actively zooming,
	 * it will return the current viewport.
	 *
	 * @returns {Viewport} The target viewport of the plot.
	 */},{key:'getTargetViewport',value:function getTargetViewport(){if(this.isZooming()){// if zooming, use the target viewport
return this.zoomAnimation.targetViewport;}// if not zooming, use the current viewport
return this.viewport;}/**
	 * Returns the current bottom-left corner of the viewport.
	 *
	 * @returns {Object} The current center in plot coordinates.
	 */},{key:'getViewportPosition',value:function getViewportPosition(){return this.viewport.getPosition();}/**
	 * Returns the target bottom-left corner of the viewport. If the plot is actively zooming
	 * or panning, it will return the destination center.
	 *
	 * @returns {Object} The target center in plot coordinates.
	 */},{key:'getTargetViewportPosition',value:function getTargetViewportPosition(){return this.getTargetViewport().getPosition();}/**
	 * Returns the current center of the viewport.
	 *
	 * @returns {Object} The current center in plot coordinates.
	 */},{key:'getViewportCenter',value:function getViewportCenter(){return this.viewport.getCenter();}/**
	 * Returns the target center of the plot in plot coordinates. If the plot is
	 * actively zooming or panning, it will return the destination center.
	 *
	 * @returns {Object} The target center in plot coordinates.
	 */},{key:'getTargetViewportCenter',value:function getTargetViewportCenter(){return this.getTargetViewport().getCenter();}/**
	 * Returns the tile coordinates visible in the target viewport.
	 *
	 * @returns {Array} The array of visible tile coords.
	 */},{key:'getTargetVisibleCoords',value:function getTargetVisibleCoords(){var tileZoom=Math.round(this.getTargetZoom());// use target zoom
var viewport=this.getTargetViewport();// use target viewport
return viewport.getVisibleCoords(tileZoom,this.wraparound);}/**
	 * Returns the tile coordinates currently visible in the current viewport.
	 *
	 * @returns {Array} The array of visible tile coords.
	 */},{key:'getVisibleCoords',value:function getVisibleCoords(){var tileZoom=Math.round(this.zoom);// use current zoom
var viewport=this.viewport;// use current viewport
return viewport.getVisibleCoords(tileZoom,this.wraparound);}/**
	 * Returns the plot size in pixels.
	 *
	 * @returns {Object} The plot size in pixels.
	 */},{key:'getPixelExtent',value:function getPixelExtent(){return Math.pow(2,this.zoom)*this.tileSize;}/**
	 * Returns the target plot size in pixels.
	 *
	 * @returns {Object} The target plot size in pixels.
	 */},{key:'getTargetPixelExtent',value:function getTargetPixelExtent(){return Math.pow(2,this.getTargetZoom())*this.tileSize;}/**
	 * Returns the viewport size in pixels.
	 *
	 * @returns {Object} The viewport size in pixels.
	 */},{key:'getViewportPixelSize',value:function getViewportPixelSize(){return this.viewport.getPixelSize(this.zoom,this.tileSize);}/**
	 * Returns the target viewport size in pixels.
	 *
	 * @returns {Object} The target viewport size in pixels.
	 */},{key:'getTargetViewportPixelSize',value:function getTargetViewportPixelSize(){return this.getTargetViewport().getPixelSize(this.zoom,this.tileSize);}/**
	 * Returns the viewport offset in pixels.
	 *
	 * @returns {Object} The viewport offset in pixels.
	 */},{key:'getViewportPixelOffset',value:function getViewportPixelOffset(){return this.viewport.getPixelOffset(this.zoom,this.tileSize);}/**
	 * Returns the target viewport offset in pixels.
	 *
	 * @returns {Object} The target viewport offset in pixels.
	 */},{key:'getTargetViewportPixelOffset',value:function getTargetViewportPixelOffset(){return this.getTargetViewport().getPixelOffset(this.zoom,this.tileSize);}/**
	 * Takes a DOM event and returns the corresponding plot position.
	 * Coordinate [0, 0] is bottom-left of the plot.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {Object} The plot position.
	 */},{key:'mouseToPlotCoord',value:function mouseToPlotCoord(event){var extent=this.getPixelExtent();var size=this.getViewportPixelSize();var container=this.getContainer();var bounds=container.getBoundingClientRect();var x=event.pageX-bounds.left;var y=event.pageY-bounds.top;return{x:this.viewport.x+x/extent,y:this.viewport.y+(size.height-y)/extent};}/**
	 * Takes a DOM event and returns the corresponding viewport pixel position.
	 * Coordinate [0, 0] is bottom-left of the viewport.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {Object} The viewport pixel coordinate.
	 */},{key:'mouseToViewportPixel',value:function mouseToViewportPixel(event){var size=this.getViewportPixelSize();var container=this.getContainer();var bounds=container.getBoundingClientRect();var x=event.pageX-bounds.left;var y=event.pageY-bounds.top;return{x:x,y:size.height-y};}/**
	 * Converts a coordinate in viewport pixel space to a normalized plot
	 * coordinate.
	 * Coordinate [0, 0] is bottom-left of the plot.
	 *
	 * @param {Object} px - The viewport pixel coordinate.
	 *
	 * @returns {Object} The normalized plot coordinate.
	 */},{key:'viewportPixelToPlotCoord',value:function viewportPixelToPlotCoord(px){var extent=this.getPixelExtent();return{x:px.x/extent,y:px.y/extent};}/**
	 * Converts a coordinate in normalized plot space to viewport pixel space.
	 * Coordinate [0, 0] is bottom-left of the plot.
	 *
	 * @param {Object} pos - The normalized plot coordinate
	 *
	 * @returns {Object} The viewport pixel coordinate.
	 */},{key:'plotCoordToViewportPixel',value:function plotCoordToViewportPixel(pos){var extent=this.plot.getPixelExtent();return{x:pos.x*extent,y:pos.y*extent};}/**
	 * Returns the orthographic projection matrix for the viewport.
	 *
	 * @returns {Float32Array} The orthographic projection matrix.
	 */},{key:'getOrthoMatrix',value:function getOrthoMatrix(){var size=this.getViewportPixelSize();var left=0;var right=size.width;var bottom=0;var top=size.height;var near=-1;var far=1;var lr=1/(left-right);var bt=1/(bottom-top);var nf=1/(near-far);var out=new Float32Array(16);out[0]=-2*lr;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=-2*bt;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=2*nf;out[11]=0;out[12]=(left+right)*lr;out[13]=(top+bottom)*bt;out[14]=(far+near)*nf;out[15]=1;return out;}/**
	 * Pans to the target plot coordinate. Cancels any current zoom or pan
	 * animations.
	 *
	 * @param {number} pos - The target plot position.
	 * @param {boolean} animate - Whether or not to animate the pan. Defaults to `true`.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'panTo',value:function panTo(pos){var animate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;// cancel existing animations
this.cancelPan();this.cancelZoom();this[HANDLERS].get(PAN).panTo(pos,animate);this.setDirty();return this;}/**
	 * Zooms in to the target zoom level. This is bounded by the plot objects
	 * minZoom and maxZoom attributes. Cancels any current zoom or pan
	 * animations.
	 *
	 * @param {number} level - The target zoom level.
	 * @param {boolean} animate - Whether or not to animate the zoom. Defaults to `true`.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'zoomTo',value:function zoomTo(level){var animate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;// cancel existing animations
this.cancelPan();this.cancelZoom();this[HANDLERS].get(ZOOM).zoomTo(level,animate);this.setDirty();return this;}/**
	 * Zooms in to the target zoom level, centered on the target coordinates. The zoom is bounded by the plot objects
	 * minZoom and maxZoom attributes. Cancels any current zoom or pan animations.
	 *
	 * @param {number} level - The target zoom level.
	 * @param {Object} position - The target center position.
	 * @param {boolean} animate - Whether or not to animate the zoom. Defaults to `true`.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'zoomToPosition',value:function zoomToPosition(level,position){var animate=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;// cancel existing animations
this.cancelPan();this.cancelZoom();this[HANDLERS].get(ZOOM).zoomToPosition(level,position,animate);this.setDirty();return this;}/**
	 * Fit the plot to a provided bounds in plot coordinates.
	 *
	 * @param {Bounds} bounds - The bounds object, in plot coordinates.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'fitToBounds',value:function fitToBounds(bounds){var targetZoom=this.getTargetZoom();var targetViewport=this.getTargetViewport();var scaleX=targetViewport.width/bounds.getWidth();var scaleY=targetViewport.height/bounds.getHeight();var scale=Math.min(scaleX,scaleY);var zoom=Math.log2(scale)+targetZoom;zoom=clamp(zoom,this.minZoom,this.maxZoom);if(!this.continuousZoom){zoom=Math.floor(zoom);}var center=bounds.getCenter();this.zoomTo(zoom,false);this.panTo(center,false);this.setDirty();return this;}/**
	 * Returns whether or not the plot is actively panning.
	 *
	 * @returns {bool} Whether or not the plot is panning.
	 */},{key:'isPanning',value:function isPanning(){return!!this.panAnimation;}/**
	 * Returns whether or not the plot is actively zooming.
	 *
	 * @returns {bool} Whether or not the plot is zooming.
	 */},{key:'isZooming',value:function isZooming(){return!!this.zoomAnimation;}/**
	 * Cancels any current pan animation.
	 *
	 * @returns {boolean} Whether or not the plot was panning.
	 */},{key:'cancelPan',value:function cancelPan(){if(this.isPanning()){this.panAnimation.cancel();this.panAnimation=null;return true;}return false;}/**
	 * Cancels any current zoom animation.
	 *
	 * @returns {boolean} Whether or not the plot was zooming.
	 */},{key:'cancelZoom',value:function cancelZoom(){if(this.isZooming()){this.zoomAnimation.cancel();this.zoomAnimation=null;return true;}return false;}/**
	 * Enables the pan event handler on the plot.
	 */},{key:'enablePanning',value:function enablePanning(){this[HANDLERS].get(PAN).enable();}/**
	 * Disables the pan event handler on the plot.
	 */},{key:'disablePanning',value:function disablePanning(){this[HANDLERS].get(PAN).disable();}/**
	 * Enables the zoom event handler on the plot.
	 */},{key:'enableZooming',value:function enableZooming(){this[HANDLERS].get(ZOOM).enable();}/**
	 * Disables the zoom event handler on the plot.
	 */},{key:'disableZooming',value:function disableZooming(){this[HANDLERS].get(ZOOM).disable();}/**
	 * Returns any highlighted data.
	 *
	 * @returns {Object} The highlighted data.
	 */},{key:'getHighlighted',value:function getHighlighted(){var layers=this.layers;for(var i=0;i<layers.length;i++){var highlight=layers[i].getHighlighted();if(highlight){return highlight;}}return null;}/**
	 * Returns true if the provided argument is highlighted.
	 *
	 * @param {Object} data - The data to test.
	 *
	 * @returns {boolean} Whether or not there is highlighted data.
	 */},{key:'isHighlighted',value:function isHighlighted(data){var layers=this.layers;for(var i=0;i<layers.length;i++){if(layers[i].isHighlighted(data)){return true;}}return false;}/**
	 * Returns any selected data.
	 *
	 * @returns {Array} The selected data.
	 */},{key:'getSelected',value:function getSelected(){var selection=[];var layers=this.layers;for(var i=0;i<layers.length;i++){var selected=layers[i].getSelected();for(var j=0;j<selected.length;j++){selection.push(selected[j]);}}return selection;}/**
	 * Returns true if the provided argument is selected.
	 *
	 * @param {Object} data - The data to test.
	 *
	 * @returns {boolean} Whether or not the data is selected.
	 */},{key:'isSelected',value:function isSelected(data){var layers=this.layers;for(var i=0;i<layers.length;i++){if(layers[i].isSelected(data)){return true;}}return false;}/**
	 * Return the containing element of the plot.
	 *
	 * @returns {HTMLElement} The container of the plot.
	 */},{key:'getContainer',value:function getContainer(){return this.container;}}]);return Plot;}(EventEmitter);module.exports=Plot;

},{"../event/Event":138,"../event/EventBroadcaster":139,"../event/EventDelegator":140,"../event/EventType":141,"../event/ResizeEvent":143,"../webgl/RenderBuffer":191,"./Cell":162,"./Viewport":164,"./handler/ClickHandler":168,"./handler/MouseHandler":170,"./handler/PanHandler":171,"./handler/ZoomHandler":172,"events":2,"lodash/clamp":107,"lodash/defaultTo":109,"lodash/throttle":133}],164:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Bounds=require('../geometry/Bounds');var TileCoord=require('../layer/tile/TileCoord');// Private Methods
var getVisibleTileBounds=function getVisibleTileBounds(viewport,tileZoom,wraparound){var bounds=viewport.getTileBounds(tileZoom);// min / max tile coords
var dim=Math.pow(2,tileZoom);var min=0;var max=dim-1;// get the bounds of the zoom level
var layerBounds=new Bounds(wraparound?-Infinity:min,wraparound?Infinity:max,min,max);// check if the layer is within the viewport
if(!bounds.overlaps(layerBounds)){// there is no overlap
return undefined;}// clamp horizontal bounds if there is no wraparound
var left=wraparound?bounds.left:Math.max(min,bounds.left);var right=wraparound?bounds.right:Math.min(max,bounds.right);// clamp vertical bounds
var bottom=Math.max(min,bounds.bottom);var top=Math.min(max,bounds.top);return new Bounds(left,right,bottom,top);};var isWithinRange=function isWithinRange(min,max,m,n){// Given:
//    1) An integer range r = [min : max].
//    2) An power-of-two integer m.
//    3) An integer n within the within the range of [0 : m).
//    4) An integer constant k.
// Check if n, or any values of m +/- kn, is within the range R.
//
// Ex:
//     min: -3
//     max: 6
//     m: 8
//     n: 7
//
// Return true because 7 - 8 = -1, which is within the range -3 to 6.
// within range
if(min<=n&&n<=max){return true;}// if the range is above n, find how many m's fit
// in the distance between n and min
if(min>n){var _k=Math.ceil((min-n)/m);return n+_k*m<=max;}// if the range is below n, find how many m's fit
// in the distance between max and n
var k=Math.ceil((n-max)/m);return n-k*m>=min;};/**
 * Class representing a viewport.
 */var Viewport=function(){/**
	 * Instantiates a new Viewport object.
	 *
	 * @param {number} x - The x coordinate of the viewport.
	 * @param {number} y - The y coordinate of the viewport.
	 * @param {number} width - The width of the viewport.
	 * @param {number} height - The height of the viewport.
	 */function Viewport(x,y,width,height){_classCallCheck(this,Viewport);this.x=x;this.y=y;this.width=width;this.height=height;}/**
	 * Returns the tile bounds of the viewport. Bounds edges are inclusive.
	 * NOTE: this includes wraparound coordinates.
	 *
	 * @param {number} tileZoom - The zoom of the tiles within the viewport.
	 *
	 * @returns {Bounds} The tile bounds of the viewport.
	 */_createClass(Viewport,[{key:'getTileBounds',value:function getTileBounds(tileZoom){// calc how many fit are in the plot
var tileSpan=1/Math.pow(2,tileZoom);// determine bounds
return new Bounds(Math.floor(this.x/tileSpan),Math.ceil((this.x+this.width)/tileSpan)-1,Math.floor(this.y/tileSpan),Math.ceil((this.y+this.height)/tileSpan)-1);}/**
	 * Returns the coordinates that are visible in the viewport.
	 *
	 * @param {number} tileZoom - The zoom of the tiles within the viewport. Optional.
	 * @param {boolean} wraparound - The if the horizontal axis should wraparound. Optional.
	 *
	 * @returns {Array} The array of visible tile coords.
	 */},{key:'getVisibleCoords',value:function getVisibleCoords(tileZoom){var wraparound=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// get the bounds for what tiles are in view
var bounds=getVisibleTileBounds(this,tileZoom,wraparound);// check if no coords are in view
if(!bounds){return[];}// return an array of the coords
var coords=[];for(var x=bounds.left;x<=bounds.right;x++){for(var y=bounds.bottom;y<=bounds.top;y++){coords.push(new TileCoord(tileZoom,x,y));}}return coords;}/**
	 * Returns whether or not the provided coord is within the viewport.
	 *
	 * @param {TileCoord} coord - The coord.
	 * @param {boolean} wraparound - The if the horizontal axis should wraparound. Optional.
	 *
	 * @returns {boolean} Whether or not the coord is in view.
	 */},{key:'isInView',value:function isInView(coord){var wraparound=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// get the bounds for what tiles are in view
var bounds=getVisibleTileBounds(this,coord.z,wraparound);// check if no coords are in view
if(!bounds){return false;}var dim=Math.pow(2,coord.z);return isWithinRange(bounds.left,bounds.right,dim,coord.x)&&isWithinRange(bounds.bottom,bounds.top,dim,coord.y);}/**
	 * Returns a viewport that has been zoomed around a provided position.
	 *
	 * @param {number} zoom - The current zoom of the viewport.
	 * @param {number} targetZoom - The target zoom of the viewport.
	 * @param {Object} targetPos - The target position to zoom around.
	 * @param {boolean} relative - The target position is relative to the current position when true, and centered
	 * when false.  This paramater defaults to true.
	 *
	 * @returns {Viewport} The new viewport object.
	 */},{key:'zoomToPos',value:function zoomToPos(zoom,targetZoom,targetPos){var relative=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;var scale=Math.pow(2,targetZoom-zoom);var scaledWidth=this.width/scale;var scaledHeight=this.height/scale;var viewport=new Viewport(targetPos.x-(targetPos.x-this.x)/scale,targetPos.y-(targetPos.y-this.y)/scale,scaledWidth,scaledHeight);if(!relative){viewport.centerOn(targetPos);}return viewport;}/**
	 * Returns the lower-left corner position of the viewport in plot
	 * coordinates.
	 *
	 * @returns {Object} The plot position.
	 */},{key:'getPosition',value:function getPosition(){return{x:this.x,y:this.y};}/**
	 * Returns the center of the viewport in plot coordinates.
	 *
	 * @returns {Object} The plot center.
	 */},{key:'getCenter',value:function getCenter(){return{x:this.x+this.width/2,y:this.y+this.height/2};}/**
	 * Returns the viewports size in pixels.
	 *
	 * @param {number} zoom - The zoom of the plot.
	 * @param {number} tileSize - The size of a tile in pixels.
	 *
	 * @returns {Object} The view size in pixels.
	 */},{key:'getPixelSize',value:function getPixelSize(zoom,tileSize){var extent=Math.pow(2,zoom)*tileSize;return{width:Math.round(this.width*extent),height:Math.round(this.height*extent)};}/**
	 * Returns the viewports offset in pixels.
	 *
	 * @param {number} zoom - The zoom of the plot.
	 * @param {number} tileSize - The size of a tile in pixels.
	 *
	 * @returns {Object} The view offset in pixels.
	 */},{key:'getPixelOffset',value:function getPixelOffset(zoom,tileSize){var extent=Math.pow(2,zoom)*tileSize;return{x:this.x*extent,y:this.y*extent};}/**
	 * Centers the viewport on a given plot coordinate.
	 *
	 * @param {Object} pos - The position to center the viewport on.
	 *
	 * @returns {Viewport} The viewport object, for chaining.
	 */},{key:'centerOn',value:function centerOn(pos){this.x=pos.x-this.width/2;this.y=pos.y-this.height/2;}}]);return Viewport;}();module.exports=Viewport;

},{"../geometry/Bounds":146,"../layer/tile/TileCoord":158}],165:[function(require,module,exports){
'use strict';/**
 * Class representing an animation.
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Animation=function(){/**
	 * Instantiates a new Animation object.
	 *
	 * @param {Object} params - The parameters of the animation.
	 * @param {number} params.plot - The plot target of the animation.
	 * @param {number} params.duration - The duration of the animation.
	 */function Animation(params){_classCallCheck(this,Animation);this.timestamp=Date.now();this.duration=params.duration;this.plot=params.plot;}/**
	 * Returns the t-value of the animation based on the provided timestamp.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {number} The t-value for the corresponding timestamp.
	 */_createClass(Animation,[{key:'getT',value:function getT(timestamp){if(this.duration>0){return Math.min(1.0,(timestamp-this.timestamp)/this.duration);}return 1.0;}/**
	 * Updates the the plot based on the current state of the
	 * animation.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {boolean} Whether or not the animation has finished.
	 *//* eslint-disable no-unused-vars */},{key:'update',value:function update(timestamp){return true;}/**
	 * Cancel the animation and remove it from the plot.
	 */},{key:'cancel',value:function cancel(){}/**
	 * Complete the animation and remove it from the plot.
	 */},{key:'finish',value:function finish(){}}]);return Animation;}();module.exports=Animation;

},{}],166:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var Event=require('../../event/Event');var Animation=require('./Animation');/**
 * Class representing a pan animation.
 */var PanAnimation=function(_Animation){_inherits(PanAnimation,_Animation);/**
	 * Instantiates a new PanAnimation object.
	 *
	 * @param {Object} params - The parameters of the animation.
	 * @param {number} params.plot - The plot target of the animation.
	 * @param {number} params.duration - The duration of the animation.
	 * @param {number} params.start - The start timestamp of the animation.
	 * @param {number} params.delta - The positional delta of the animation.
	 * @param {number} params.easing - The easing factor of the animation.
	 */function PanAnimation(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PanAnimation);var _this=_possibleConstructorReturn(this,(PanAnimation.__proto__||Object.getPrototypeOf(PanAnimation)).call(this,params));_this.start=params.start;_this.delta=params.delta;_this.end={x:_this.start.x+_this.delta.x,y:_this.start.y+_this.delta.y};_this.easing=params.easing;return _this;}/**
	 * Updates the position of the plot based on the current state of the
	 * animation.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {boolean} Whether or not the animation has finished.
	 */_createClass(PanAnimation,[{key:'update',value:function update(timestamp){var t=this.getT(timestamp);// calculate the progress of the animation
var progress=1-Math.pow(1-t,1/this.easing);// caclulate the current position along the pan
var plot=this.plot;// set the viewport positions
plot.viewport.x=this.start.x+this.delta.x*progress;plot.viewport.y=this.start.y+this.delta.y*progress;// create pan event
var event=new Event(plot);// check if animation is finished
if(t<1){plot.emit(EventType.PAN,event);return false;}plot.emit(EventType.PAN_END,event);return true;}/**
	 * Cancels the current animation and removes it from the plot.
	 */},{key:'cancel',value:function cancel(){var plot=this.plot;// emit pan end
plot.emit(EventType.PAN_END,new Event(plot));}/**
	 * Complete the current animation and remove it from the plot.
	 */},{key:'finish',value:function finish(){var plot=this.plot;// set the viewport positions
plot.viewport.x=this.end.x;plot.viewport.y=this.end.y;// emit pan end
plot.emit(EventType.PAN_END,new Event(plot));}}]);return PanAnimation;}(Animation);module.exports=PanAnimation;

},{"../../event/Event":138,"../../event/EventType":141,"./Animation":165}],167:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var Event=require('../../event/Event');var Animation=require('./Animation');/**
 * Class representing a zoom animation.
 */var ZoomAnimation=function(_Animation){_inherits(ZoomAnimation,_Animation);/**
	 * Instantiates a new ZoomAnimation object.
	 *
	 * @param {Object} params - The parameters of the animation.
	 * @param {number} params.plot - The plot target of the animation.
	 * @param {number} params.duration - The duration of the animation.
	 * @param {number} params.prevZoom - The starting zoom of the animation.
	 * @param {number} params.targetZoom - The target zoom of the animation.
	 * @param {number} params.prevViewport - The starting viewport of the animation.
	 * @param {number} params.targetViewport - The target viewport of the animation.
	 * @param {number} params.targetPos - The target position of the animation, in plot coordinates.
	 */function ZoomAnimation(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,ZoomAnimation);var _this=_possibleConstructorReturn(this,(ZoomAnimation.__proto__||Object.getPrototypeOf(ZoomAnimation)).call(this,params));_this.prevZoom=params.prevZoom;_this.targetZoom=params.targetZoom;_this.prevViewport=params.prevViewport;_this.targetViewport=params.targetViewport;_this.targetPos=params.targetPos;return _this;}/**
	 * Updates the zoom of the plot based on the current state of the
	 * animation.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {boolean} Whether or not the animation has finished.
	 */_createClass(ZoomAnimation,[{key:'update',value:function update(timestamp){var t=this.getT(timestamp);// calc new zoom
var range=this.targetZoom-this.prevZoom;var zoom=this.prevZoom+range*t;var plot=this.plot;// set new zoom
plot.zoom=zoom;// calc new viewport position from prev
plot.viewport=this.prevViewport.zoomToPos(this.prevZoom,plot.zoom,this.targetPos);// create zoom event
var event=new Event(plot);// check if animation is finished
if(t<1){plot.emit(EventType.ZOOM,event);return false;}plot.emit(EventType.ZOOM_END,event);return true;}/**
	 * Cancels the current animation and removes it from the plot.
	 */},{key:'cancel',value:function cancel(){var plot=this.plot;if(!plot.continuousZoom){// round to the closest zoom
plot.zoom=Math.round(plot.zoom);// calc viewport position from prev
plot.viewport=this.prevViewport.zoomToPos(this.prevZoom,plot.zoom,this.targetPos);}// emit zoom end
var event=new Event(plot);plot.emit(EventType.ZOOM_END,event);}/**
	 * Complete the current animation and remove it from the plot.
	 */},{key:'finish',value:function finish(){var plot=this.plot;plot.zoom=this.targetZoom;plot.viewport=this.targetViewport;// emit zoom end
var event=new Event(plot);plot.emit(EventType.ZOOM_END,event);}}]);return ZoomAnimation;}(Animation);module.exports=ZoomAnimation;

},{"../../event/Event":138,"../../event/EventType":141,"./Animation":165}],168:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var MouseEvent=require('../../event/MouseEvent');var DOMHandler=require('./DOMHandler');// Constants
/**
 * Distance in pixels the mouse can be moved before the click event is
 * cancelled.
 * @private
 * @constant {number}
 */var MOVE_TOLERANCE=15;// Private Methods
var createEvent=function createEvent(handler,plot,event){return new MouseEvent(plot,// target
event,// originalEvent
handler.mouseToPlot(event),// pos
handler.mouseToViewPx(event));// px
};/**
 * Class representing a click handler.
 * @private
 */var ClickHandler=function(_DOMHandler){_inherits(ClickHandler,_DOMHandler);/**
	 * Instantiates a new ClickHandler object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 */function ClickHandler(plot){_classCallCheck(this,ClickHandler);return _possibleConstructorReturn(this,(ClickHandler.__proto__||Object.getPrototypeOf(ClickHandler)).call(this,plot));}/**
	 * Enables the handler.
	 *
	 * @returns {ClickHandler} The handler object, for chaining.
	 */_createClass(ClickHandler,[{key:'enable',value:function enable(){var _this2=this;_get(ClickHandler.prototype.__proto__||Object.getPrototypeOf(ClickHandler.prototype),'enable',this).call(this);var plot=this.plot;var last=null;this.mousedown=function(event){last=_this2.mouseToViewPx(event);};this.mouseup=function(event){if(!last){return;}var pos=_this2.mouseToViewPx(event);var diff={x:last.x-pos.x,y:last.y-pos.y};var distSqrd=diff.x*diff.x+diff.y*diff.y;if(distSqrd<MOVE_TOLERANCE*MOVE_TOLERANCE){// movement was within tolerance, emit click
plot.setDirty();event.preventDefault();_this2.plot.emit(EventType.CLICK,createEvent(_this2,plot,event));}last=null;};this.dblclick=function(event){plot.setDirty();event.preventDefault();_this2.plot.emit(EventType.DBL_CLICK,createEvent(_this2,plot,event));};var container=plot.getContainer();container.addEventListener('mousedown',this.mousedown);container.addEventListener('mouseup',this.mouseup);container.addEventListener('dblclick',this.dblclick);}/**
	 * Disables the handler.
	 *
	 * @returns {ClickHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){_get(ClickHandler.prototype.__proto__||Object.getPrototypeOf(ClickHandler.prototype),'disable',this).call(this);var container=this.plot.getContainer();container.removeEventListener('mousedown',this.mousedown);container.removeEventListener('mouseup',this.mouseup);container.removeEventListener('dblclick',this.dblclick);this.mousedown=null;this.mouseup=null;this.dblclick=null;}}]);return ClickHandler;}(DOMHandler);module.exports=ClickHandler;

},{"../../event/EventType":141,"../../event/MouseEvent":142,"./DOMHandler":169}],169:[function(require,module,exports){
'use strict';/**
 * Class representing a DOM handler.
 * @private
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var DOMHandler=function(){/**
	 * Instantiates a new DOM object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 */function DOMHandler(plot){_classCallCheck(this,DOMHandler);this.plot=plot;this.enabled=false;}/**
	 * Enables the handler.
	 *
	 * @returns {ZoomHandler} The handler object, for chaining.
	 */_createClass(DOMHandler,[{key:'enable',value:function enable(){if(this.enabled){throw'Handler is already enabled';}this.enabled=true;}/**
	 * Disables the handler.
	 *
	 * @returns {ZoomHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){if(!this.enabled){throw'Handler is already disabled';}this.enabled=false;}/**
	 * Takes a DOM event and returns the corresponding plot position.
	 * Coordinate [0, 0] is bottom-left of the plot.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {Object} The plot position.
	 */},{key:'mouseToPlot',value:function mouseToPlot(event){return this.plot.mouseToPlotCoord(event);}/**
	 * Takes a DOM event and returns the corresponding viewport pixel position.
	 * Coordinate [0, 0] is bottom-left of the viewport.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {Object} The viewport pixel coordinate.
	 */},{key:'mouseToViewPx',value:function mouseToViewPx(event){return this.plot.mouseToViewportPixel(event);}/**
	 * Takes a viewport pixel coordinate and returns the corresponding plot
	 * position.
	 * Coordinate [0, 0] is bottom-left of the plot.
	 *
	 * @param {Object} px - The viewport pixel coordinate.
	 *
	 * @returns {Object} The plot position.
	 */},{key:'viewPxToPlot',value:function viewPxToPlot(px){return this.plot.viewportPixelToPlotCoord(px);}/**
	 * Takes a plot position and returns the corresponding viewport pixel
	 * coordinate.
	 * Coordinate [0, 0] is bottom-left of the plot.
	 *
	 * @param {Object} pos - The plot position.
	 *
	 * @returns {Object} The viewport pixel coordinate.
	 */},{key:'plotToViewPx',value:function plotToViewPx(pos){return this.plot.plotCoordToViewportPixel(pos);}/**
	 * Takes a DOM event and returns true if the left mouse button is down.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {boolean} Whether the left mouse button is down.
	 */},{key:'isLeftButton',value:function isLeftButton(event){return event.which?event.which===1:event.button===0;}/**
	 * Takes a DOM event and returns true if the middle mouse button is down.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {boolean} Whether the middle mouse button is down.
	 */},{key:'isMiddleButton',value:function isMiddleButton(event){return event.which?event.which===2:event.button===1;}/**
	 * Takes a DOM event and returns true if the right mouse button is down.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {boolean} Whether the right mouse button is down.
	 */},{key:'isRightButton',value:function isRightButton(event){return event.which?event.which===3:event.button===2;}}]);return DOMHandler;}();module.exports=DOMHandler;

},{}],170:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var MouseEvent=require('../../event/MouseEvent');var DOMHandler=require('./DOMHandler');// Private Methods
var createEvent=function createEvent(handler,plot,event){return new MouseEvent(plot,// target
event,// originalEvent
handler.mouseToPlot(event),// pos
handler.mouseToViewPx(event));// px
};/**
 * Class representing a mouse handler.
 * @private
 */var MouseHandler=function(_DOMHandler){_inherits(MouseHandler,_DOMHandler);/**
	 * Instantiates a new MouseHandler object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 */function MouseHandler(plot){_classCallCheck(this,MouseHandler);return _possibleConstructorReturn(this,(MouseHandler.__proto__||Object.getPrototypeOf(MouseHandler)).call(this,plot));}/**
	 * Enables the handler.
	 *
	 * @returns {MouseHandler} The handler object, for chaining.
	 */_createClass(MouseHandler,[{key:'enable',value:function enable(){var _this2=this;_get(MouseHandler.prototype.__proto__||Object.getPrototypeOf(MouseHandler.prototype),'enable',this).call(this);var plot=this.plot;this.mousedown=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_DOWN,createEvent(_this2,plot,event));};this.mouseup=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_UP,createEvent(_this2,plot,event));};this.mousemove=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_MOVE,createEvent(_this2,plot,event));};this.mouseover=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_OVER,createEvent(_this2,plot,event));};this.mouseout=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_OUT,createEvent(_this2,plot,event));};this.wheel=function(event){plot.setDirty();event.preventDefault();};var container=plot.getContainer();container.addEventListener('mousedown',this.mousedown);container.addEventListener('mouseup',this.mouseup);container.addEventListener('mousemove',this.mousemove);container.addEventListener('mouseover',this.mouseover);container.addEventListener('mouseout',this.mouseout);container.addEventListener('wheel',this.wheel);}/**
	 * Disables the handler.
	 *
	 * @returns {MouseHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){_get(MouseHandler.prototype.__proto__||Object.getPrototypeOf(MouseHandler.prototype),'disable',this).call(this);var container=this.plot.getContainer();container.removeEventListener('mousedown',this.mousedown);container.removeEventListener('mouseup',this.mouseup);container.removeEventListener('mousemove',this.mousemove);container.removeEventListener('mouseover',this.mouseover);container.removeEventListener('mouseout',this.mouseout);container.removeEventListener('wheel',this.wheel);this.mousedown=null;this.mouseup=null;this.mousemove=null;this.mouseover=null;this.mouseout=null;this.wheel=null;}}]);return MouseHandler;}(DOMHandler);module.exports=MouseHandler;

},{"../../event/EventType":141,"../../event/MouseEvent":142,"./DOMHandler":169}],171:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var PanAnimation=require('../animation/PanAnimation');var EventType=require('../../event/EventType');var Event=require('../../event/Event');var DOMHandler=require('./DOMHandler');// Constants
/**
 * Time in milliseconds before a pan point expires.
 * @private
 * @constant {number}
 */var PAN_EXPIRY_MS=50;/**
 * Pan inertia enabled.
 * @private
 * @constant {boolean}
 */var PAN_INTERTIA=true;/**
 * Pan inertia easing.
 * @private
 * @constant {number}
 */var PAN_INTERTIA_EASING=0.2;/**
 * Pan inertia deceleration.
 * @private
 * @constant {number}
 */var PAN_INTERTIA_DECELERATION=3400;/**
 * Pan to animation duration
 * @private
 * @constant {number}
 */var PAN_TO_DURATION=800;// Private Methods
var pan=function pan(plot,delta){if(plot.isZooming()){// no panning while zooming
return;}// update current viewport
plot.viewport.x+=delta.x;plot.viewport.y+=delta.y;// request tiles
plot.panRequest();// emit pan
plot.emit(EventType.PAN,new Event(plot));};/**
 * Class representing a pan handler.
 */var PanHandler=function(_DOMHandler){_inherits(PanHandler,_DOMHandler);/**
	 * Instantiates a new PanHandler object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 * @param {Object} options - The parameters of the animation.
	 * @param {number} options.inertia - Whether or not pan inertia is enabled.
	 * @param {number} options.inertiaEasing - The inertia easing factor.
	 * @param {number} options.inertiaDeceleration - The inertia deceleration factor.
	 */function PanHandler(plot){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,PanHandler);var _this=_possibleConstructorReturn(this,(PanHandler.__proto__||Object.getPrototypeOf(PanHandler)).call(this,plot));_this.inertia=defaultTo(options.inertia,PAN_INTERTIA);_this.inertiaEasing=defaultTo(options.inertiaEasing,PAN_INTERTIA_EASING);_this.inertiaDeceleration=defaultTo(options.inertiaDeceleration,PAN_INTERTIA_DECELERATION);return _this;}/**
	 * Enables the handler.
	 *
	 * @returns {PanHandler} The handler object, for chaining.
	 */_createClass(PanHandler,[{key:'enable',value:function enable(){var _this2=this;_get(PanHandler.prototype.__proto__||Object.getPrototypeOf(PanHandler.prototype),'enable',this).call(this);var plot=this.plot;var down=false;var lastPos=null;var lastTime=null;var positions=[];var times=[];this.mousedown=function(event){// ignore if right-button
if(!_this2.isLeftButton(event)){return;}// flag as down
down=true;// set position and timestamp
lastPos=_this2.mouseToViewPx(event);lastTime=Date.now();if(_this2.inertia){// clear existing pan animation
plot.panAnimation=null;// reset position and time arrays
positions=[];times=[];}};this.mousemove=function(event){if(down){// get latest position and timestamp
var pos=_this2.mouseToViewPx(event);var time=Date.now();if(positions.length===0){// emit pan start
plot.emit(EventType.PAN_START,new Event(plot));}if(_this2.inertia){// add to position and time arrays
positions.push(pos);times.push(time);// prevent array from getting too big
if(time-times[0]>PAN_EXPIRY_MS){positions.shift();times.shift();}}// calculate the positional delta
var delta={x:lastPos.x-pos.x,y:lastPos.y-pos.y};// pan the plot
pan(plot,_this2.viewPxToPlot(delta));// update last position and time
lastTime=time;lastPos=pos;}};this.mouseup=function(event){// flag as up
down=false;if(plot.isZooming()){// no panning while zooming
return;}// ignore if right-button
if(!_this2.isLeftButton(event)){return;}// ignore if no drag occurred
if(positions.length===0){return;}if(!_this2.inertia){// exit early if no inertia or no movement
plot.emit(EventType.PAN_END,new Event(plot));return;}// get timestamp
var time=Date.now();// strip any positions that are too old
while(time-times[0]>PAN_EXPIRY_MS){positions.shift();times.shift();}if(times.length<2){// exit early if no remaining valid positions
plot.emit(EventType.PAN_END,new Event(plot));return;}// shorthand
var deceleration=_this2.inertiaDeceleration;var easing=_this2.inertiaEasing;// calculate direction from earliest to latest
var direction={x:lastPos.x-positions[0].x,y:lastPos.y-positions[0].y};// calculate the time difference
var diff=(lastTime-times[0]||1)/1000;// ms to s
// calculate velocity
var velocity={x:direction.x*(easing/diff),y:direction.y*(easing/diff)};// calculate speed
var speed=Math.sqrt(velocity.x*velocity.x+velocity.y*velocity.y);// calculate panning duration
var duration=speed/(deceleration*easing);// calculate inertia delta
var delta={x:Math.round(velocity.x*(-duration/2)),y:Math.round(velocity.y*(-duration/2))};// set pan animation
plot.panAnimation=new PanAnimation({plot:plot,start:plot.getViewportPosition(),delta:_this2.viewPxToPlot(delta),easing:easing,duration:duration*1000// s to ms
});};var container=plot.getContainer();container.addEventListener('mousedown',this.mousedown);document.addEventListener('mousemove',this.mousemove);document.addEventListener('mouseup',this.mouseup);}/**
	 * Disables the handler.
	 *
	 * @returns {PanHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){_get(PanHandler.prototype.__proto__||Object.getPrototypeOf(PanHandler.prototype),'disable',this).call(this);var container=this.plot.getContainer();container.removeEventListener('mousedown',this.mousedown);document.removeEventListener('mousemove',this.mousemove);document.removeEventListener('mouseup',this.mouseup);this.mousedown=null;this.mousemove=null;this.mouseup=null;}/**
	 * Pans to the target plot coordinate.
	 *
	 * @param {number} pos - The target plot position.
	 * @param {boolean} animate - Whether or not to animate the pan. Defaults to `true`.
	 */},{key:'panTo',value:function panTo(pos){var animate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var plot=this.plot;var center=plot.getViewportCenter();var delta={x:pos.x-center.x,y:pos.y-center.y};if(!animate){// do not animate
plot.emit(EventType.PAN_START,new Event(plot));pan(plot,delta);plot.emit(EventType.PAN_END,new Event(plot));}else{// animate pan
plot.emit(EventType.PAN_START,new Event(plot));plot.panAnimation=new PanAnimation({plot:plot,start:plot.getViewportPosition(),delta:delta,easing:this.inertiaEasing,duration:PAN_TO_DURATION});}}}]);return PanHandler;}(DOMHandler);module.exports=PanHandler;

},{"../../event/Event":138,"../../event/EventType":141,"../animation/PanAnimation":166,"./DOMHandler":169,"lodash/defaultTo":109}],172:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var clamp=require('lodash/clamp');var defaultTo=require('lodash/defaultTo');var Browser=require('../../util/Browser');var EventType=require('../../event/EventType');var Event=require('../../event/Event');var ZoomAnimation=require('../animation/ZoomAnimation');var Viewport=require('../Viewport');var DOMHandler=require('./DOMHandler');// Constants
/**
 * Amount of scroll pixels per zoom level.
 * @private
 * @constant {number}
 */var ZOOM_WHEEL_DELTA=300;/**
 * Length of zoom animation in milliseconds.
 * @private
 * @constant {number}
 */var ZOOM_ANIMATION_MS=250;/**
 * Maximum concurrent discrete zooms in a single batch.
 * @private
 * @constant {number}
 */var MAX_CONCURRENT_ZOOMS=4;/**
 * Zoom debounce delay in miliseconds.
 * @private
 * @constant {number}
 */var ZOOM_DEBOUNCE_MS=100;/**
 * Continuous zoom enabled.
 * @private
 * @constant {boolean}
 */var CONTINUOUS_ZOOM=false;// Private Methods
var last=Date.now();var skipInterpolation=function skipInterpolation(animation,delta){// NOTE: attempt to determine if the scroll device is a mouse or a
// trackpad. Mouse scrolling creates large infrequent deltas while
// trackpads create tons of very small deltas. We want to interpolate
// between wheel events, but not between trackpad events.
var now=Date.now();var tdelta=now-last;last=now;if(delta%4.000244140625===0){// definitely a wheel, interpolate
return false;}if(Math.abs(delta)<4){// definitely track pad, do not interpolate
return true;}if(animation&&animation.duration!==0){// current animation has interpolation, should probably interpolate
// the next animation too.
// NOTE: without this, rapid wheel scrolling will trigger the skip
// below
return false;}if(tdelta<40){// events are close enough together that we should probably
// not interpolate
return true;}return false;};var computeZoomDelta=function computeZoomDelta(wheelDelta,continuousZoom,deltaPerZoom,maxZooms){var zoomDelta=wheelDelta/deltaPerZoom;if(!continuousZoom){// snap value if not continuous zoom
if(wheelDelta>0){zoomDelta=Math.ceil(zoomDelta);}else{zoomDelta=Math.floor(zoomDelta);}}// clamp zoom delta to max concurrent zooms
return clamp(zoomDelta,-maxZooms,maxZooms);};var computeTargetZoom=function computeTargetZoom(zoomDelta,currentZoom,currentAnimation,minZoom,maxZoom){var targetZoom=void 0;if(currentAnimation){// append to existing animation target
targetZoom=currentAnimation.targetZoom+zoomDelta;}else{targetZoom=currentZoom+zoomDelta;}// clamp the target zoom to min and max zoom level of plot
return clamp(targetZoom,minZoom,maxZoom);};var zoom=function zoom(plot,targetPos,zoomDelta,duration){var relative=arguments.length>4&&arguments[4]!==undefined?arguments[4]:true;// calculate target zoom level
var targetZoom=computeTargetZoom(zoomDelta,plot.zoom,plot.zoomAnimation,plot.minZoom,plot.maxZoom);// set target viewport
var targetViewport=plot.viewport.zoomToPos(plot.zoom,targetZoom,targetPos,relative);// get previous targets
var prevTargetZoom=plot.getTargetZoom();var prevTargetViewport=plot.getTargetViewport();// only process zoom if it is required
if(targetZoom!==prevTargetZoom||targetViewport.x!==prevTargetViewport.x||targetViewport.y!==prevTargetViewport.y){// clear pan animation
plot.panAnimation=null;// if there is a duration
if(duration>0){// set zoom animation
plot.zoomAnimation=new ZoomAnimation({plot:plot,duration:duration,prevZoom:plot.zoom,targetZoom:targetZoom,prevViewport:new Viewport(plot.viewport.x,plot.viewport.y,plot.viewport.width,plot.viewport.height),targetViewport:targetViewport,targetPos:targetPos});}// emit zoom start
plot.emit(EventType.ZOOM_START,new Event(plot));// if there isn't a duration
if(duration===0){// immediately update plot
plot.zoom=targetZoom;plot.viewport=targetViewport;// emit zoom end
plot.emit(EventType.ZOOM_END,new Event(plot));}// request tiles
plot.zoomRequest();}};var zoomFromWheel=function zoomFromWheel(handler,plot,targetPos,wheelDelta,continuousZoom){// no wheel delta, exit early
if(wheelDelta===0){return;}// calculate zoom delta from wheel delta
var zoomDelta=computeZoomDelta(wheelDelta,continuousZoom,handler.deltaPerZoom,handler.maxConcurrentZooms);// get duration
var duration=handler.zoomDuration;if(continuousZoom&&skipInterpolation(plot.zoomAnimation,wheelDelta)){// skip animation interpolation
duration=0;}// process the zoom
zoom(plot,targetPos,zoomDelta,duration);};var getWheelDelta=function getWheelDelta(plot,event){if(event.deltaMode===0){// pixels
if(Browser.firefox){return-event.deltaY/plot.pixelRatio;}return-event.deltaY;}else if(event.deltaMode===1){// lines
return-event.deltaY*20;}// pages
return-event.deltaY*60;};/**
 * Class representing a zoom handler.
 */var ZoomHandler=function(_DOMHandler){_inherits(ZoomHandler,_DOMHandler);/**
	 * Instantiates a new ZoomHandler object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 * @param {Object} options - The parameters of the animation.
	 * @param {number} options.continuousZoom - Whether or not continuous zoom is enabled.
	 * @param {number} options.zoomDuration - The duration of the zoom animation.
	 * @param {number} options.maxConcurrentZooms - The maximum concurrent zooms in a single batch.
	 * @param {number} options.deltaPerZoom - The scroll delta required per zoom level.
	 * @param {number} options.zoomDebounce - The debounce duration of the zoom in ms.
	 */function ZoomHandler(plot){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,ZoomHandler);var _this=_possibleConstructorReturn(this,(ZoomHandler.__proto__||Object.getPrototypeOf(ZoomHandler)).call(this,plot));_this.continuousZoom=defaultTo(options.continuousZoom,CONTINUOUS_ZOOM);_this.zoomDuration=defaultTo(options.zoomDuration,ZOOM_ANIMATION_MS);_this.maxConcurrentZooms=defaultTo(options.maxConcurrentZooms,MAX_CONCURRENT_ZOOMS);_this.deltaPerZoom=defaultTo(options.deltaPerZoom,ZOOM_WHEEL_DELTA);_this.zoomDebounce=defaultTo(options.zoomDebounce,ZOOM_DEBOUNCE_MS);return _this;}/**
	 * Enables the handler.
	 *
	 * @returns {ZoomHandler} The handler object, for chaining.
	 */_createClass(ZoomHandler,[{key:'enable',value:function enable(){var _this2=this;_get(ZoomHandler.prototype.__proto__||Object.getPrototypeOf(ZoomHandler.prototype),'enable',this).call(this);var plot=this.plot;var wheelDelta=0;var timeout=null;var evt=null;this.dblclick=function(event){// get mouse position
var targetPos=_this2.mouseToPlot(event);// zoom the plot by one level
zoom(plot,targetPos,1,_this2.zoomDuration);};this.wheel=function(event){// get normalized delta
var delta=getWheelDelta(plot,event);if(!_this2.continuousZoom&&Math.abs(delta)<4){// mitigate the hyper sensitivty of a trackpad
return;}// increment wheel delta
wheelDelta+=delta;// check zoom type
if(_this2.continuousZoom){// get target from mouse position
var targetPos=_this2.mouseToPlot(event);// process continuous zoom immediately
zoomFromWheel(_this2,plot,targetPos,wheelDelta,true);// reset wheel delta
wheelDelta=0;}else{// set event
evt=event;// debounce discrete zoom
if(!timeout){timeout=setTimeout(function(){// get target position from mouse position
// NOTE: this is called inside the closure to ensure
// that we use the current viewport of the plot to
// convert from mouse to plot pixels
var targetPos=_this2.mouseToPlot(evt);// process zoom event
zoomFromWheel(_this2,plot,targetPos,wheelDelta,false);// reset wheel delta
wheelDelta=0;// clear timeout
timeout=null;// clear event
evt=null;},_this2.zoomDebounce);}}// prevent default behavior and stop propagationa
event.preventDefault();event.stopPropagation();};var container=plot.getContainer();container.addEventListener('dblclick',this.dblclick);container.addEventListener('wheel',this.wheel);}/**
	 * Disables the handler.
	 *
	 * @returns {ZoomHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){_get(ZoomHandler.prototype.__proto__||Object.getPrototypeOf(ZoomHandler.prototype),'disable',this).call(this);var container=this.plot.getContainer();container.removeEventListener('dblclick',this.dblclick);container.removeEventListener('wheel',this.wheel);this.dblclick=null;this.wheel=null;}/**
	 * Zooms in to the target zoom level. This is bounded by the plot objects
	 * minZoom and maxZoom attributes.
	 *
	 * @param {number} level - The target zoom level.
	 * @param {boolean} animate - Whether or not to animate the zoom. Defaults to `true`.
	 */},{key:'zoomTo',value:function zoomTo(level){var animate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var plot=this.plot;var targetPos=this.plot.getViewportCenter();var zoomDelta=level-plot.zoom;if(!animate){// do not animate
zoom(plot,targetPos,zoomDelta,0);}else{// animate
zoom(plot,targetPos,zoomDelta,this.zoomDuration);}}/**
	 * Zooms to the target zoom level, and centers on the target position.  The zoom is bounded by the plot objects
	 * minZoom and maxZoom attributes.
	 *
	 * @param {number} level - The target zoom level.
	 * @param {Object} targetPos - The target center position.
	 * @param {boolean} animate - Whether or not to animate the zoom. Defaults to `true`.
	 */},{key:'zoomToPosition',value:function zoomToPosition(level,targetPos){var animate=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var plot=this.plot;var zoomDelta=level-plot.zoom;var duration=animate?this.zoomDuration:0;zoom(plot,targetPos,zoomDelta,duration,false/* centered on target position */);}}]);return ZoomHandler;}(DOMHandler);module.exports=ZoomHandler;

},{"../../event/Event":138,"../../event/EventType":141,"../../util/Browser":186,"../Viewport":164,"../animation/ZoomAnimation":167,"./DOMHandler":169,"lodash/clamp":107,"lodash/defaultTo":109}],173:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventEmitter=require('events');/**
 * Class representing a renderer.
 */var Renderer=function(_EventEmitter){_inherits(Renderer,_EventEmitter);/**
	 * Instantiates a new Renderer object.
	 */function Renderer(){_classCallCheck(this,Renderer);return _possibleConstructorReturn(this,(Renderer.__proto__||Object.getPrototypeOf(Renderer)).call(this));}/**
	 * Executed when the target is attached to a plot.
	 *
	 * @param {target} target - The target to attach the renderer to.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 *//* eslint-disable no-unused-vars */_createClass(Renderer,[{key:'onAdd',value:function onAdd(target){return this;}/**
	 * Executed when the target is removed from a plot.
	 *
	 * @param {Overlay} target - The target to remove the renderer from.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 *//* eslint-disable no-unused-vars */},{key:'onRemove',value:function onRemove(target){return this;}/**
	 * Pick a position of the layer for a collision with any rendered objects.
	 *
	 * @param {Object} pos - The plot position to pick at.
	 *
	 * @returns {Object} The collision, or null.
	 *//* eslint-disable no-unused-vars */},{key:'pick',value:function pick(pos){return null;}/**
	 * Clears any persisted state in the renderer.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'clear',value:function clear(){return this;}/**
	 * The draw function that is executed per frame.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 *//* eslint-disable no-unused-vars */},{key:'draw',value:function draw(timestamp){return this;}}]);return Renderer;}(EventEmitter);module.exports=Renderer;

},{"events":2}],174:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Renderer=require('../Renderer');/**
 * Class representing an overlay renderer.
 */var OverlayRenderer=function(_Renderer){_inherits(OverlayRenderer,_Renderer);/**
	 * Instantiates a new OverlayRenderer object.
	 */function OverlayRenderer(){_classCallCheck(this,OverlayRenderer);var _this=_possibleConstructorReturn(this,(OverlayRenderer.__proto__||Object.getPrototypeOf(OverlayRenderer)).call(this));_this.overlay=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Overlay} overlay - The overlay to attach the renderer to.
	 *
	 * @returns {OverlayRenderer} The renderer object, for chaining.
	 */_createClass(OverlayRenderer,[{key:'onAdd',value:function onAdd(overlay){if(!overlay){throw'No overlay provided as argument';}this.overlay=overlay;return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Overlay} overlay - The overlay to remove the renderer from.
	 *
	 * @returns {OverlayRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(overlay){if(!overlay){throw'No overlay provided as argument';}this.overlay=null;return this;}}]);return OverlayRenderer;}(Renderer);module.exports=OverlayRenderer;

},{"../Renderer":173}],175:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Shader=require('../../webgl/shader/Shader');var EventType=require('../../event/EventType');var OverlayRenderer=require('./OverlayRenderer');// Constants
/**
 * Refresh event handler symbol.
 * @private
 * @constant {Symbol}
 */var REFRESH=Symbol();/**
 * Class representing a webgl overlay renderer.
 */var WebGLOverlayRenderer=function(_OverlayRenderer){_inherits(WebGLOverlayRenderer,_OverlayRenderer);/**
	 * Instantiates a new WebGLOverlayRenderer object.
	 *
	 * @param {Object} options - The overlay options.
	 */function WebGLOverlayRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,WebGLOverlayRenderer);var _this=_possibleConstructorReturn(this,(WebGLOverlayRenderer.__proto__||Object.getPrototypeOf(WebGLOverlayRenderer)).call(this,options));_this.gl=null;_this[REFRESH]=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Layer} overlay - The overlay to attach the renderer to.
	 *
	 * @returns {WebGLOverlayRenderer} The renderer object, for chaining.
	 */_createClass(WebGLOverlayRenderer,[{key:'onAdd',value:function onAdd(overlay){var _this2=this;_get(WebGLOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(WebGLOverlayRenderer.prototype),'onAdd',this).call(this,overlay);this.gl=this.overlay.plot.getRenderingContext();// create buffers
this.refreshBuffers();// create refresh handler
this[REFRESH]=function(){_this2.refreshBuffers();};// attach refresh handler
this.overlay.on(EventType.REFRESH,this[REFRESH]);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Layer} overlay - The overlay to remove the renderer from.
	 *
	 * @returns {WebGLOverlayRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(overlay){// remove refresh handler
this.overlay.removeListener(EventType.REFRESH,this[REFRESH]);// destroy refresh handler
this[REFRESH]=null;this.gl=null;_get(WebGLOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(WebGLOverlayRenderer.prototype),'onRemove',this).call(this,overlay);return this;}/**
	 * Generate any underlying buffers.
	 *
	 * @returns {WebGLOverlayRenderer} The overlay object, for chaining.
	 */},{key:'refreshBuffers',value:function refreshBuffers(){throw'`refreshBuffers` must be overridden';}/**
	 * Instantiate and return a new Shader object using the renderers internal
	 * WebGLRenderingContext.
	 *
	 * @param {Object} source - The shader param object.
	 * @param {string} source.common - Common glsl to be shared by both vertex and fragment shaders.
	 * @param {string} source.vert - The vertex shader glsl.
	 * @param {string} source.frag - The fragment shader glsl.
	 *
	 * @returns {Shader} The shader object.
	 */},{key:'createShader',value:function createShader(source){return new Shader(this.gl,source);}/**
	 * Returns the orthographic projection matrix for the viewport.
	 *
	 * @returns {Float32Array} The orthographic projection matrix.
	 */},{key:'getOrthoMatrix',value:function getOrthoMatrix(){return this.overlay.plot.getOrthoMatrix();}}]);return WebGLOverlayRenderer;}(OverlayRenderer);module.exports=WebGLOverlayRenderer;

},{"../../event/EventType":141,"../../webgl/shader/Shader":192,"./OverlayRenderer":174}],176:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLOverlayRenderer=require('../WebGLOverlayRenderer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute vec2 aNormal;\n\t\tuniform vec2 uViewOffset;\n\t\tuniform float uScale;\n\t\tuniform float uLineWidth;\n\t\tuniform float uPixelRatio;\n\t\tuniform float uPointRadius;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) - uViewOffset;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t\tgl_PointSize = uPointRadius * 2.0 * uPixelRatio;\n\t\t}\n\t\t',frag:'\n\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t#extension GL_OES_standard_derivatives : enable\n\t\t#endif\n\t\tprecision highp float;\n\t\tuniform vec4 uPointColor;\n\t\tuniform float uOpacity;\n\t\tvoid main() {\n\t\t\tvec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\t\t\tfloat radius = dot(cxy, cxy);\n\t\t\tfloat alpha = 1.0;\n\t\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t\tfloat delta = fwidth(radius);\n\t\t\t\talpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, radius);\n\t\t\t#else\n\t\t\t\tif (radius > 1.0) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\tgl_FragColor = vec4(uPointColor.rgb, uPointColor.a * alpha * uOpacity);\n\t\t}\n\t\t'};// Private Methods
var bufferPoints=function bufferPoints(points){var buffer=new Float32Array(points.length*2);for(var i=0;i<points.length;i++){var point=points[i];buffer[i*2]=point.x;buffer[i*2+1]=point.y;}return buffer;};var createVertexBuffer=function createVertexBuffer(gl,points){var data=bufferPoints(points);return new VertexBuffer(gl,data,{0:{size:2,type:'FLOAT'}},{mode:'POINTS',count:points.length});};/**
 * Class representing a webgl point overlay renderer.
 */var PointOverlayRenderer=function(_WebGLOverlayRenderer){_inherits(PointOverlayRenderer,_WebGLOverlayRenderer);/**
	 * Instantiates a new PointOverlayRenderer object.
	 *
	 * @param {Object} options - The overlay options.
	 * @param {Array} options.pointColor - The color of the points.
	 * @param {number} options.pointRadius - The pixel radius of the points.
	 */function PointOverlayRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PointOverlayRenderer);var _this=_possibleConstructorReturn(this,(PointOverlayRenderer.__proto__||Object.getPrototypeOf(PointOverlayRenderer)).call(this,options));_this.pointColor=defaultTo(options.pointColor,[1.0,0.0,1.0,1.0]);_this.pointRadius=defaultTo(options.pointRadius,4);_this.shader=null;_this.ext=null;_this.points=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Layer} overlay - The overlay to attach the renderer to.
	 *
	 * @returns {PointOverlayRenderer} The renderer object, for chaining.
	 */_createClass(PointOverlayRenderer,[{key:'onAdd',value:function onAdd(overlay){_get(PointOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PointOverlayRenderer.prototype),'onAdd',this).call(this,overlay);this.ext=this.gl.getExtension('OES_standard_derivatives');this.shader=this.createShader(SHADER_GLSL);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Layer} overlay - The overlay to remove the renderer from.
	 *
	 * @returns {PointOverlayRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(overlay){this.shader=null;this.ext=null;this.points=null;_get(PointOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PointOverlayRenderer.prototype),'onRemove',this).call(this,overlay);return this;}/**
	 * Generate any underlying buffers.
	 *
	 * @returns {PointOverlayRenderer} The overlay object, for chaining.
	 */},{key:'refreshBuffers',value:function refreshBuffers(){// clip points to only those that are inside the cell
var clipped=this.overlay.getClippedGeometry();// generate the buffer
if(clipped&&clipped.length>0){this.points=createVertexBuffer(this.gl,clipped);}else{this.points=null;}}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {PointOverlayRenderer} The overlay object, for chaining.
	 */},{key:'draw',value:function draw(){if(!this.points){return this;}var gl=this.gl;var shader=this.shader;var points=this.points;var plot=this.overlay.plot;var cell=plot.cell;var proj=this.getOrthoMatrix();var scale=Math.pow(2,plot.zoom-cell.zoom);var opacity=this.overlay.opacity;// get view offset in cell space
var offset=cell.project(plot.viewport,plot.zoom);// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uViewOffset',[offset.x,offset.y]);shader.setUniform('uScale',scale);shader.setUniform('uPointColor',this.pointColor);shader.setUniform('uPointRadius',this.pointRadius);shader.setUniform('uPixelRatio',plot.pixelRatio);shader.setUniform('uOpacity',opacity);// draw the points
points.bind();points.draw();return this;}}]);return PointOverlayRenderer;}(WebGLOverlayRenderer);module.exports=PointOverlayRenderer;

},{"../../../webgl/vertex/VertexBuffer":199,"../WebGLOverlayRenderer":175,"lodash/defaultTo":109}],177:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var earcut=require('earcut');var defaultTo=require('lodash/defaultTo');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var IndexBuffer=require('../../../webgl/vertex/IndexBuffer');var WebGLOverlayRenderer=require('../WebGLOverlayRenderer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tuniform vec2 uViewOffset;\n\t\tuniform float uScale;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) - uViewOffset;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform vec4 uPolygonColor;\n\t\tuniform float uOpacity;\n\t\tvoid main() {\n\t\t\tgl_FragColor = vec4(uPolygonColor.rgb, uPolygonColor.a * uOpacity);\n\t\t}\n\t\t'};// Private Methods
var getVertexArray=function getVertexArray(points){var vertices=new Float32Array(points.length*2);for(var i=0;i<points.length;i++){vertices[i*2]=points[i].x;vertices[i*2+1]=points[i].y;}return vertices;};var createBuffers=function createBuffers(overlay,points){var vertices=getVertexArray(points);var indices=earcut(vertices);var vertexBuffer=new VertexBuffer(overlay.gl,vertices,{0:{size:2,type:'FLOAT'}});var is16Bit=vertices.length<Math.pow(2,16);var indexBuffer=new IndexBuffer(overlay.gl,is16Bit?new Uint16Array(indices):new Uint32Array(indices),{mode:'TRIANGLES',type:is16Bit?'UNSIGNED_SHORT':'UNSIGNED_INT',count:indices.length});return{vertex:vertexBuffer,index:indexBuffer};};/**
 * Class representing a webgl polyline overlay renderer.
 */var PolygonOverlayRenderer=function(_WebGLOverlayRenderer){_inherits(PolygonOverlayRenderer,_WebGLOverlayRenderer);/**
	 * Instantiates a new PolygonOverlayRenderer object.
	 *
	 * @param {Object} options - The overlay options.
	 * @param {Array} options.polygonColor - The color of the line.
	 */function PolygonOverlayRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PolygonOverlayRenderer);var _this=_possibleConstructorReturn(this,(PolygonOverlayRenderer.__proto__||Object.getPrototypeOf(PolygonOverlayRenderer)).call(this,options));_this.polygonColor=defaultTo(options.polygonColor,[1.0,0.4,0.1,0.8]);_this.shader=null;_this.polygons=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the overlay to.
	 *
	 * @returns {PolygonOverlayRenderer} The overlay object, for chaining.
	 */_createClass(PolygonOverlayRenderer,[{key:'onAdd',value:function onAdd(plot){_get(PolygonOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PolygonOverlayRenderer.prototype),'onAdd',this).call(this,plot);this.shader=this.createShader(SHADER_GLSL);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the overlay from.
	 *
	 * @returns {PolygonOverlayRenderer} The overlay object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){_get(PolygonOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PolygonOverlayRenderer.prototype),'onRemove',this).call(this,plot);this.shader=null;return this;}/**
	 * Generate any underlying buffers.
	 *
	 * @returns {PolygonOverlayRenderer} The overlay object, for chaining.
	 */},{key:'refreshBuffers',value:function refreshBuffers(){var _this2=this;var clipped=this.overlay.getClippedGeometry();if(clipped){this.polygons=clipped.map(function(points){// generate the buffer
return createBuffers(_this2,points);});}else{this.polygons=null;}}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {PolygonOverlayRenderer} The overlay object, for chaining.
	 */},{key:'draw',value:function draw(){if(!this.polygons){return this;}var gl=this.gl;var shader=this.shader;var polygons=this.polygons;var plot=this.overlay.plot;var cell=plot.cell;var proj=this.getOrthoMatrix();var scale=Math.pow(2,plot.zoom-cell.zoom);var opacity=this.overlay.opacity;// get view offset in cell space
var offset=cell.project(plot.viewport,plot.zoom);// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uViewOffset',[offset.x,offset.y]);shader.setUniform('uScale',scale);shader.setUniform('uPolygonColor',this.polygonColor);shader.setUniform('uOpacity',opacity);// for each polyline buffer
polygons.forEach(function(buffer){// draw the points
buffer.vertex.bind();buffer.index.draw();});return this;}}]);return PolygonOverlayRenderer;}(WebGLOverlayRenderer);module.exports=PolygonOverlayRenderer;

},{"../../../webgl/vertex/IndexBuffer":197,"../../../webgl/vertex/VertexBuffer":199,"../WebGLOverlayRenderer":175,"earcut":1,"lodash/defaultTo":109}],178:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLOverlayRenderer=require('../WebGLOverlayRenderer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute vec2 aNormal;\n\t\tuniform vec2 uViewOffset;\n\t\tuniform float uScale;\n\t\tuniform float uLineWidth;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) - uViewOffset + aNormal * uLineWidth;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform vec4 uLineColor;\n\t\tuniform float uOpacity;\n\t\tvoid main() {\n\t\t\tgl_FragColor = vec4(uLineColor.rgb, uLineColor.a * uOpacity);\n\t\t}\n\t\t'};// Private Methods
// NOTE: smooth / round lines implemented using code modified from:
// http://labs.hyperandroid.com/efficient-webgl-stroking . Instead of baking in
// the positions of the lines, this implementation instead generates the
// positions along the line and stores the tangents, allowing the thickness to
// be arbitrarily scaled outwards independant of scale. In order to prevent
// degeneration of normals due to self-intersections, the triangles are
// generated upon zoom.
var EPSILON=0.000001;var scalarMult=function scalarMult(a,s){return{x:a.x*s,y:a.y*s};};var perpendicular=function perpendicular(a){return{x:-a.y,y:a.x};};var invert=function invert(a){return{x:-a.x,y:-a.y};};var length=function length(a){return Math.sqrt(a.x*a.x+a.y*a.y);};var normalize=function normalize(a){var mod=Math.sqrt(a.x*a.x+a.y*a.y);return{x:a.x/mod,y:a.y/mod};};var add=function add(p0,p1){return{x:p0.x+p1.x,y:p0.y+p1.y};};var sub=function sub(p0,p1){return{x:p0.x-p1.x,y:p0.y-p1.y};};var middle=function middle(p0,p1){return scalarMult(add(p0,p1),0.5);};var equal=function equal(p0,p1){return p0.x===p1.x&&p0.y===p1.y;};var signedArea=function signedArea(p0,p1,p2){return(p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);};var getStrokeGeometry=function getStrokeGeometry(points,strokeWidth){if(points.length<2){throw'A valid polyline must consist of at least 2 points';}var lineWidth=strokeWidth/2;var positions=[];var normals=[];var middlePoints=[];// middle points per each line segment
var closed=false;if(points.length===2){createTriangles(points[0],middle(points[0],points[1]),points[1],positions,normals,lineWidth);}else{if(equal(points[0],points[points.length-1])){var p0=middle(points.shift(),points[0]);points.unshift(p0);points.push(p0);closed=true;}for(var i=0;i<points.length-1;i++){if(i===0){middlePoints.push(points[0]);}else if(i===points.length-2){middlePoints.push(points[points.length-1]);}else{middlePoints.push(middle(points[i],points[i+1]));}}for(var _i=1;_i<middlePoints.length;_i++){createTriangles(middlePoints[_i-1],points[_i],middlePoints[_i],positions,normals,lineWidth);}}if(!closed){// start cap
var _p=points[0];var p1=points[1];var t=perpendicular(sub(p1,_p));createRoundCap(_p,add(_p,t),sub(_p,t),p1,positions,normals);// end cap
_p=points[points.length-1];p1=points[points.length-2];t=perpendicular(sub(p1,_p));createRoundCap(_p,add(_p,t),sub(_p,t),p1,positions,normals);}return{positions:positions,normals:normals};};var createRoundCap=function createRoundCap(center,p0,p1,nextPointInLine,positions,normals){var angle0=Math.atan2(p1.y-center.y,p1.x-center.x);var angle1=Math.atan2(p0.y-center.y,p0.x-center.x);var orgAngle0=angle0;if(angle1>angle0){if(angle1-angle0>=Math.PI-EPSILON){angle1=angle1-2*Math.PI;}}else{if(angle0-angle1>=Math.PI-EPSILON){angle0=angle0-2*Math.PI;}}var angleDiff=angle1-angle0;if(Math.abs(angleDiff)>=Math.PI-EPSILON&&Math.abs(angleDiff)<=Math.PI+EPSILON){var r1=sub(center,nextPointInLine);if(r1.x===0){if(r1.y>0){angleDiff=-angleDiff;}}else if(r1.x>=-EPSILON){angleDiff=-angleDiff;}}var segmentsPerSemi=16;var nsegments=Math.ceil(Math.abs(angleDiff/Math.PI)*segmentsPerSemi);var angleInc=angleDiff/nsegments;var n0={x:0,y:0};for(var i=0;i<nsegments;i++){var n1={x:Math.cos(orgAngle0+angleInc*i),y:Math.sin(orgAngle0+angleInc*i)};var n2={x:Math.cos(orgAngle0+angleInc*(1+i)),y:Math.sin(orgAngle0+angleInc*(1+i))};positions.push(center);positions.push(center);positions.push(center);normals.push(n0);normals.push(n1);normals.push(n2);}};function lineIntersection(p0,p1,p2,p3){var a0=p1.y-p0.y;var b0=p0.x-p1.x;var a1=p3.y-p2.y;var b1=p2.x-p3.x;var det=a0*b1-a1*b0;if(det>-EPSILON&&det<EPSILON){return null;}var c0=a0*p0.x+b0*p0.y;var c1=a1*p2.x+b1*p2.y;var x=(b1*c0-b0*c1)/det;var y=(a0*c1-a1*c0)/det;return{x:x,y:y};}function createTriangles(p0,p1,p2,positions,normals,lineWidth){var t0=sub(p1,p0);var t2=sub(p2,p1);t0=perpendicular(t0);t2=perpendicular(t2);// triangle composed by the 3 points if clockwise or counter-clockwise.
// if counter-clockwise, we must invert the line threshold points, otherwise
// the intersection point could be erroneous and lead to odd results.
if(signedArea(p0,p1,p2)>0){t0=invert(t0);t2=invert(t2);}t0=normalize(t0);t2=normalize(t2);t0=scalarMult(t0,lineWidth);t2=scalarMult(t2,lineWidth);var pintersect=lineIntersection(add(t0,p0),add(t0,p1),add(t2,p2),add(t2,p1));var anchor=null;var anchorLength=Number.MAX_VALUE;var ian=null;if(pintersect){anchor=sub(pintersect,p1);anchorLength=length(anchor);ian=invert(scalarMult(anchor,1.0/lineWidth));}var p0p1=sub(p0,p1);var p0p1Length=length(p0p1);var p1p2=sub(p1,p2);var p1p2Length=length(p1p2);var n0=normalize(t0);var in0=invert(n0);var n2=normalize(t2);var in2=invert(n2);// the cross point exceeds any of the segments dimension.
// do not use cross point as reference.
if(anchorLength>p0p1Length||anchorLength>p1p2Length){positions.push(p0);positions.push(p0);positions.push(p1);normals.push(n0);normals.push(in0);normals.push(n0);positions.push(p0);positions.push(p1);positions.push(p1);normals.push(in0);normals.push(n0);normals.push(in0);createRoundCap(p1,add(p1,t0),add(p1,t2),p2,positions,normals);positions.push(p2);positions.push(p1);positions.push(p1);normals.push(n2);normals.push(in2);normals.push(n2);positions.push(p2);positions.push(p1);positions.push(p2);normals.push(n2);normals.push(in2);normals.push(in2);}else{positions.push(p0);positions.push(p0);positions.push(p1);normals.push(n0);normals.push(in0);normals.push(ian);positions.push(p0);positions.push(p1);positions.push(p1);normals.push(n0);normals.push(ian);normals.push(n0);positions.push(p1);positions.push(p1);positions.push(p1);normals.push(n0);normals.push({x:0,y:0});normals.push(ian);createRoundCap(p1,add(p1,t0),add(p1,t2),sub(p1,anchor),positions,normals);positions.push(p1);positions.push(p1);positions.push(p1);normals.push({x:0,y:0});normals.push(n2);normals.push(ian);positions.push(p2);positions.push(p1);positions.push(p1);normals.push(n2);normals.push(ian);normals.push(n2);positions.push(p2);positions.push(p1);positions.push(p2);normals.push(n2);normals.push(ian);normals.push(in2);}}var bufferPolyline=function bufferPolyline(points,normals){var buffer=new Float32Array(points.length*4);for(var i=0;i<points.length;i++){var point=points[i];var normal=normals[i];buffer[i*4]=point.x;buffer[i*4+1]=point.y;buffer[i*4+2]=normal.x;buffer[i*4+3]=normal.y;}return buffer;};var createVertexBuffer=function createVertexBuffer(overlay,points){var lineWidth=overlay.lineWidth;var geometry=getStrokeGeometry(points,lineWidth);var data=bufferPolyline(geometry.positions,geometry.normals);return new VertexBuffer(overlay.gl,data,{0:{size:2,type:'FLOAT',byteOffset:0},1:{size:2,type:'FLOAT',byteOffset:2*4}},{mode:'TRIANGLES',count:geometry.positions.length});};/**
 * Class representing a webgl polyline overlay renderer.
 */var PolylineOverlayRenderer=function(_WebGLOverlayRenderer){_inherits(PolylineOverlayRenderer,_WebGLOverlayRenderer);/**
	 * Instantiates a new PolylineOverlayRenderer object.
	 *
	 * @param {Object} options - The overlay options.
	 * @param {Array} options.lineColor - The color of the line.
	 * @param {number} options.lineWidth - The pixel width of the line.
	 */function PolylineOverlayRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PolylineOverlayRenderer);var _this=_possibleConstructorReturn(this,(PolylineOverlayRenderer.__proto__||Object.getPrototypeOf(PolylineOverlayRenderer)).call(this,options));_this.lineColor=defaultTo(options.lineColor,[1.0,0.4,0.1,0.8]);_this.lineWidth=defaultTo(options.lineWidth,2);_this.shader=null;_this.lines=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the overlay to.
	 *
	 * @returns {PolylineOverlayRenderer} The overlay object, for chaining.
	 */_createClass(PolylineOverlayRenderer,[{key:'onAdd',value:function onAdd(plot){_get(PolylineOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PolylineOverlayRenderer.prototype),'onAdd',this).call(this,plot);this.shader=this.createShader(SHADER_GLSL);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the overlay from.
	 *
	 * @returns {PolylineOverlayRenderer} The overlay object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){_get(PolylineOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PolylineOverlayRenderer.prototype),'onRemove',this).call(this,plot);this.shader=null;return this;}/**
	 * Generate any underlying buffers.
	 *
	 * @returns {PolylineOverlayRenderer} The overlay object, for chaining.
	 */},{key:'refreshBuffers',value:function refreshBuffers(){var _this2=this;var clipped=this.overlay.getClippedGeometry();if(clipped){this.lines=clipped.map(function(points){// generate the buffer
return createVertexBuffer(_this2,points);});}else{this.lines=null;}}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {PolylineOverlayRenderer} The overlay object, for chaining.
	 */},{key:'draw',value:function draw(){if(!this.lines){return this;}var gl=this.gl;var shader=this.shader;var lines=this.lines;var plot=this.overlay.plot;var cell=plot.cell;var proj=this.getOrthoMatrix();var scale=Math.pow(2,plot.zoom-cell.zoom);var opacity=this.overlay.opacity;// get view offset in cell space
var offset=cell.project(plot.viewport,plot.zoom);// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uViewOffset',[offset.x,offset.y]);shader.setUniform('uScale',scale);shader.setUniform('uLineWidth',this.lineWidth/2);shader.setUniform('uLineColor',this.lineColor);shader.setUniform('uOpacity',opacity);// for each polyline buffer
lines.forEach(function(buffer){// draw the points
buffer.bind();buffer.draw();});return this;}}]);return PolylineOverlayRenderer;}(WebGLOverlayRenderer);module.exports=PolylineOverlayRenderer;

},{"../../../webgl/vertex/VertexBuffer":199,"../WebGLOverlayRenderer":175,"lodash/defaultTo":109}],179:[function(require,module,exports){
'use strict';// Private Methods
var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var getUVOffset=function getUVOffset(ancestor,descendant){var scale=1/Math.pow(2,descendant.z-ancestor.z);return[descendant.x*scale-ancestor.x,descendant.y*scale-ancestor.y,scale,scale];};/**
 * Class representing a tile renderable.
 */var TileRenderable=function(){/**
	 * Instantiates a new TileRenderable object.
	 *
	 * @param {Tile} tile - The tile data to be rendered.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {Object} tileOffset - The tile pixel offset relative to the viewport.
	 * @param {Array} uvOffset - The texture coordinate offset describing the portion of the tile to render.
	 */function TileRenderable(tile,scale,tileOffset,uvOffset){_classCallCheck(this,TileRenderable);this.tile=tile;this.hash=tile.coord.hash;this.scale=scale;this.tileOffset=tileOffset;this.uvOffset=uvOffset;}/**
	 * Instantiate a TileRenderable object from a specific tile.
	 *
	 * @param {Tile} tile - The tile data to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */_createClass(TileRenderable,[{key:'toCanvas',/**
	 * Converts the `uvOffset` and `tileOffset` parameters to the canvas
	 * coordinate system, with [0, 0] being the top-left corner. The conversion
	 * is done in-place.
	 *
	 * @param {Object} viewport - The pixel dimensions of the viewport.
	 * @param {number} tileSize - The size of each tile in pixels.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */value:function toCanvas(viewport,tileSize){// flip y component of uv offset
var uvOffset=this.uvOffset;uvOffset[1]=1-uvOffset[2]-uvOffset[1];// flip y component of tile offset
var tileOffset=this.tileOffset;tileOffset[1]=viewport.height-tileOffset[1]-tileSize*this.scale;return this;}}],[{key:'fromTile',value:function fromTile(tile,coord,scale,tileSize,viewportOffset){var scaledTileSize=scale*tileSize;var tileOffset=[coord.x*scaledTileSize-viewportOffset.x,coord.y*scaledTileSize-viewportOffset.y];return new TileRenderable(tile,scale,tileOffset,[0,0,1,1]);}/**
	 * Instantiate a TileRenderable object from an ancestor of the tile.
	 *
	 * @param {Tile} tile - The tile data to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 * @param {TileCoord} wanted - The coordinate the tile will substitue for.
	 * @param {TileCoord} descendant - The direct descendant of the substituted tile.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */},{key:'fromAncestor',value:function fromAncestor(tile,coord,scale,tileSize,viewportOffset,wanted,descendant){var scaledTileSize=scale*tileSize;var tileOffset=[0,0];if(descendant===wanted){// if the "wanted" tile is the same as the "descendant" of this
// ancestor, then there is no positional offset
tileOffset[0]=coord.x*scaledTileSize-viewportOffset.x;tileOffset[1]=coord.y*scaledTileSize-viewportOffset.y;}else{// if the "wanted" tile is not the same as the "descendant", we need
// to position and scale this tile relative to the descendant
var offsetScale=1/Math.pow(2,descendant.z-wanted.z);var offsetX=descendant.x*offsetScale-wanted.x;var offsetY=descendant.y*offsetScale-wanted.y;tileOffset[0]=(coord.x+offsetX)*scaledTileSize-viewportOffset.x;tileOffset[1]=(coord.y+offsetY)*scaledTileSize-viewportOffset.y;scale*=offsetScale;}return new TileRenderable(tile,scale,tileOffset,getUVOffset(tile.coord,descendant));}/**
	 * Instantiate a TileRenderable object from a descendant of the tile.
	 *
	 * @param {Tile} tile - The tile data to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 * @param {TileCoord} wanted - The coordinate the tile will substitue for.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */},{key:'fromDescendant',value:function fromDescendant(tile,coord,scale,tileSize,viewportOffset,wanted){var scaledTileSize=scale*tileSize;var offsetScale=1/Math.pow(2,tile.coord.z-wanted.z);var offsetX=tile.coord.x*offsetScale-wanted.x;var offsetY=tile.coord.y*offsetScale-wanted.y;var tileOffset=[(coord.x+offsetX)*scaledTileSize-viewportOffset.x,(coord.y+offsetY)*scaledTileSize-viewportOffset.y];return new TileRenderable(tile,scale*offsetScale,tileOffset,[0,0,1,1]);}/**
	 * Instantiate a TileRenderable object from an ancestor of the tile.
	 *
	 * @param {TilePartial} partial - The tile partial to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */},{key:'fromAncestorPartial',value:function fromAncestorPartial(partial,coord,scale,tileSize,viewportOffset){var tile=partial.tile;// tile we have
var target=partial.target;// tile we wanted
var relative=partial.relative;// where to position the tile relative to
var scaledTileSize=scale*tileSize;var tileOffset=[0,0];if(relative===partial.target){// if the "target" tile is the same as the "relative" of this
// ancestor, then there is no positional offset
tileOffset[0]=coord.x*scaledTileSize-viewportOffset.x;tileOffset[1]=coord.y*scaledTileSize-viewportOffset.y;}else{// if the "target" tile is not the same as the "relative", we need
// to position and scale this tile relative to the relative
var offsetScale=1/Math.pow(2,relative.z-target.z);var offsetX=relative.x*offsetScale-target.x;var offsetY=relative.y*offsetScale-target.y;tileOffset[0]=(coord.x+offsetX)*scaledTileSize-viewportOffset.x;tileOffset[1]=(coord.y+offsetY)*scaledTileSize-viewportOffset.y;scale*=offsetScale;}return new TileRenderable(tile,scale,tileOffset,getUVOffset(tile.coord,relative));}/**
	 * Instantiate a TileRenderable object from a descendant of the tile.
	 *
	 * @param {TilePartial} partial - The tile partial to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */},{key:'fromDescendantPartial',value:function fromDescendantPartial(partial,coord,scale,tileSize,viewportOffset){var tile=partial.tile;// tile we have
var target=partial.target;// tile we wanted
var scaledTileSize=scale*tileSize;var offsetScale=1/Math.pow(2,tile.coord.z-target.z);var offsetX=tile.coord.x*offsetScale-target.x;var offsetY=tile.coord.y*offsetScale-target.y;var tileOffset=[(coord.x+offsetX)*scaledTileSize-viewportOffset.x,(coord.y+offsetY)*scaledTileSize-viewportOffset.y];return new TileRenderable(tile,scale*offsetScale,tileOffset,[0,0,1,1]);}}]);return TileRenderable;}();module.exports=TileRenderable;

},{}],180:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var RTreePyramid=require('../../geometry/RTreePyramid');var Renderer=require('../Renderer');var TileRenderable=require('./TileRenderable');// Constants
/**
 * Tile index handler symbol.
 * @private
 * @constant {Symbol}
 */var TILE_INDEX=Symbol();/**
 * Tile unindex handler symbol.
 * @private
 * @constant {Symbol}
 */var TILE_UNINDEX=Symbol();/**
 * Class representing a tile renderer.
 */var TileRenderer=function(_Renderer){_inherits(TileRenderer,_Renderer);/**
	 * Instantiates a new TileRenderer object.
	 */function TileRenderer(){_classCallCheck(this,TileRenderer);var _this=_possibleConstructorReturn(this,(TileRenderer.__proto__||Object.getPrototypeOf(TileRenderer)).call(this));_this[TILE_INDEX]=new Map();_this[TILE_UNINDEX]=new Map();_this.layer=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {TileRenderer} The renderer object, for chaining.
	 */_createClass(TileRenderer,[{key:'onAdd',value:function onAdd(layer){if(!layer){throw'No layer provided as argument';}this.layer=layer;return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {TileRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){if(!layer){throw'No layer provided as argument';}this.layer=null;return this;}/**
	 * Creates an rtree pyramid object. Creates and attaches the necessary
	 * event handlers to add and remove data from the rtree accordingly.
	 *
	 * @param {Object} options - The options for the r-tree pyramid.
	 * @param {number} options.nodeCapacity - The node capacity of the rtree.
	 * @param {Function} options.createCollidables - The function to create collidables from a tile.
	 *
	 * @returns {RTreePyramid} The r-tree pyramid object.
	 */},{key:'createRTreePyramid',value:function createRTreePyramid(){var _this2=this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var createCollidables=options.createCollidables;if(!createCollidables){throw'`options.createCollidables` argument is missing';}// create rtree pyramid
var pyramid=new RTreePyramid({nodeCapacity:options.nodeCapacity});// create handlers
var index=function index(event){var tile=event.tile;var coord=tile.coord;var tileSize=_this2.layer.plot.tileSize;var xOffset=coord.x*tileSize;var yOffset=coord.y*tileSize;var collidables=createCollidables(tile,xOffset,yOffset);pyramid.insert(coord,collidables);};var unindex=function unindex(event){pyramid.remove(event.tile.coord);};// attach handlers
this.layer.on(EventType.TILE_ADD,index);this.layer.on(EventType.TILE_REMOVE,unindex);// store the handlers under the atlas
this[TILE_INDEX].set(pyramid,index);this[TILE_UNINDEX].set(pyramid,unindex);return pyramid;}/**
	 * Destroys a vertex atlas object and removes all event handlers used to add
	 * and remove data from the atlas.
	 *
	 * @param {RTreePyramid} pyramid - The r-tree pyramid object to destroy.
	 */},{key:'destroyRTreePyramid',value:function destroyRTreePyramid(pyramid){// detach handlers
this.layer.removeListener(EventType.TILE_ADD,this[TILE_INDEX].get(pyramid));this.layer.removeListener(EventType.TILE_REMOVE,this[TILE_UNINDEX].get(pyramid));// remove handlers
this[TILE_INDEX].delete(pyramid);this[TILE_UNINDEX].delete(pyramid);}/**
	 * Returns the tile renderables for the underlying layer.
	 *
	 * @returns {Array} The array of tile renderables.
	 */},{key:'getRenderables',value:function getRenderables(){var plot=this.layer.plot;var pyramid=this.layer.pyramid;var tileSize=plot.tileSize;var zoom=plot.zoom;var viewport=plot.getViewportPixelOffset();var coords=plot.getVisibleCoords();var renderables=[];for(var i=0;i<coords.length;i++){var coord=coords[i];var ncoord=coord.normalize();// check if we have the tile
var tile=pyramid.get(ncoord);if(tile){var scale=Math.pow(2,zoom-coord.z);var renderable=TileRenderable.fromTile(tile,coord,scale,tileSize,viewport);renderables.push(renderable);}}return renderables;}/**
	 * Returns the tile renderables for the underlying layer at the closest
	 * available level-of-detail.
	 *
	 * @returns {Array} The array of tile renderables.
	 */},{key:'getRenderablesLOD',value:function getRenderablesLOD(){var plot=this.layer.plot;var pyramid=this.layer.pyramid;var tileSize=plot.tileSize;var zoom=plot.zoom;var viewport=plot.getViewportPixelOffset();var coords=plot.getVisibleCoords();var renderables=[];for(var i=0;i<coords.length;i++){var coord=coords[i];var ncoord=coord.normalize();var scale=Math.pow(2,zoom-coord.z);// check if we have any tile LOD available
var partials=pyramid.getAvailableLOD(ncoord);if(partials){for(var j=0;j<partials.length;j++){var partial=partials[j];var tile=partial.tile;var renderable=void 0;if(tile.coord.z===coord.z){// exact tile
renderable=TileRenderable.fromTile(tile,coord,scale,tileSize,viewport);}else if(tile.coord.z<coord.z){// ancestor of the tile
renderable=TileRenderable.fromAncestorPartial(partial,coord,scale,tileSize,viewport);}else{// descendant of the tile
renderable=TileRenderable.fromDescendantPartial(partial,coord,scale,tileSize,viewport);}renderables.push(renderable);}}}return renderables;}}]);return TileRenderer;}(Renderer);module.exports=TileRenderer;

},{"../../event/EventType":141,"../../geometry/RTreePyramid":149,"../Renderer":173,"./TileRenderable":179}],181:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var EventType=require('../../event/EventType');var Shader=require('../../webgl/shader/Shader');var TextureArray=require('../../webgl/texture/TextureArray');var VertexAtlas=require('../../webgl/vertex/VertexAtlas');var TileRenderer=require('./TileRenderer');// Constants
/**
 * Tile add handler symbol.
 * @private
 * @constant {Symbol}
 */var TILE_ADD=Symbol();/**
 * Tile remove handler symbol.
 * @private
 * @constant {Symbol}
 */var TILE_REMOVE=Symbol();// Private Methods
var addTileToTextureArray=function addTileToTextureArray(array,tile){array.set(tile.coord.hash,tile.data);};var removeTileFromTextureArray=function removeTileFromTextureArray(array,tile){array.delete(tile.coord.hash);};var addTileToVertexAtlas=function addTileToVertexAtlas(atlas,tile){atlas.set(tile.coord.hash,tile.data,tile.data.length/atlas.stride);};var removeTileFromVertexAtlas=function removeTileFromVertexAtlas(atlas,tile){atlas.delete(tile.coord.hash);};/**
 * Class representing a webgl tile renderer.
 */var WebGLTileRenderer=function(_TileRenderer){_inherits(WebGLTileRenderer,_TileRenderer);/**
	 * Instantiates a new WebGLTileRenderer object.
	 */function WebGLTileRenderer(){_classCallCheck(this,WebGLTileRenderer);var _this=_possibleConstructorReturn(this,(WebGLTileRenderer.__proto__||Object.getPrototypeOf(WebGLTileRenderer)).call(this));_this.gl=null;_this[TILE_ADD]=new Map();_this[TILE_REMOVE]=new Map();return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {WebGLTileRenderer} The renderer object, for chaining.
	 */_createClass(WebGLTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(WebGLTileRenderer.prototype.__proto__||Object.getPrototypeOf(WebGLTileRenderer.prototype),'onAdd',this).call(this,layer);this.gl=this.layer.plot.getRenderingContext();return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {WebGLRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.gl=null;_get(WebGLTileRenderer.prototype.__proto__||Object.getPrototypeOf(WebGLTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * Returns the orthographic projection matrix for the viewport.
	 *
	 * @returns {Float32Array} The orthographic projection matrix.
	 */},{key:'getOrthoMatrix',value:function getOrthoMatrix(){return this.layer.plot.getOrthoMatrix();}/**
	 * Instantiate and return a new Shader object using the renderers internal
	 * WebGLRenderingContext.
	 *
	 * @param {Object} source - The shader param object.
	 * @param {string} source.common - Common glsl to be shared by both vertex and fragment shaders.
	 * @param {string} source.vert - The vertex shader glsl.
	 * @param {string} source.frag - The fragment shader glsl.
	 *
	 * @returns {Shader} The shader object.
	 */},{key:'createShader',value:function createShader(source){return new Shader(this.gl,source);}/**
	 * Creates a texture array of appropriate size for the layer pyramid using
	 * the provided texture size. Creates and attaches the necessary event
	 * handlers to add and remove data from the array accordingly.
	 *
	 * @param {Object} options - The options for the texture array.
	 * @param {number} options.chunkSize - The resolution of the tile texture.
	 * @param {string} options.format - The texture pixel format.
	 * @param {string} options.type - The texture pixel component type.
	 * @param {string} options.filter - The min / mag filter used during scaling.
	 * @param {string} options.wrap - The wrapping type over both S and T dimension.
	 * @param {bool} options.invertY - Whether or not invert-y is enabled.
	 * @param {bool} options.premultiplyAlpha - Whether or not alpha premultiplying is enabled.
	 * @param {Function} options.onAdd - The function executed when a tile is added.
	 * @param {Function} options.onRemove - The function executed when a tile is removed.
	 *
	 * @returns {TextureArray} The texture array object.
	 */},{key:'createTextureArray',value:function createTextureArray(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// create texture array
var array=new TextureArray(this.gl,{// set texture params
format:options.format,type:options.type,filter:options.filter,invertY:options.invertY,premultiplyAlpha:options.premultiplyAlpha},{// set num chunks to be able to fit the capacity of the pyramid
numChunks:this.layer.pyramid.getCapacity(),chunkSize:options.chunkSize});// create handlers
var onAdd=defaultTo(options.onAdd,addTileToTextureArray);var onRemove=defaultTo(options.onRemove,removeTileFromTextureArray);var add=function add(event){onAdd(array,event.tile);};var remove=function remove(event){onRemove(array,event.tile);};// attach handlers
this.layer.on(EventType.TILE_ADD,add);this.layer.on(EventType.TILE_REMOVE,remove);// store the handlers under the array
this[TILE_ADD].set(array,add);this[TILE_REMOVE].set(array,remove);return array;}/**
	 * Destroys a texture array object and removes all event handlers used to
	 * add and remove data from the array.
	 *
	 * @param {TextureArray} array - The texture array to destroy.
	 */},{key:'destroyTextureArray',value:function destroyTextureArray(array){// detach handlers
this.layer.removeListener(EventType.TILE_ADD,this[TILE_ADD].get(array));this.layer.removeListener(EventType.TILE_REMOVE,this[TILE_REMOVE].get(array));// remove handlers
this[TILE_ADD].delete(array);this[TILE_REMOVE].delete(array);}/**
	 * Creates a vertex atlas of appropriate size for the layer pyramid using
	 * the provided attribute pointers. Creates and attaches the necessary
	 * event handlers to add and remove data from the atlas accordingly.
	 *
	 * @param {Object} options - The options for the vertex atlas.
	 * @param {Object} options.attributePointers - The vertex attribute pointers.
	 * @param {number} options.chunkSize - The size of a single chunk, in vertices.
	 * @param {Function} options.onAdd - The function executed when a tile is added.
	 * @param {Function} options.onRemove - The function executed when a tile is removed.
	 *
	 * @returns {VertexAtlas} The vertex atlas object.
	 */},{key:'createVertexAtlas',value:function createVertexAtlas(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// create vertex atlas
var atlas=new VertexAtlas(this.gl,options.attributePointers,{// set num chunks to be able to fit the capacity of the pyramid
numChunks:this.layer.pyramid.getCapacity(),chunkSize:options.chunkSize});// create handlers
var onAdd=defaultTo(options.onAdd,addTileToVertexAtlas);var onRemove=defaultTo(options.onRemove,removeTileFromVertexAtlas);var add=function add(event){onAdd(atlas,event.tile);};var remove=function remove(event){onRemove(atlas,event.tile);};// attach handlers
this.layer.on(EventType.TILE_ADD,add);this.layer.on(EventType.TILE_REMOVE,remove);// store the handlers under the atlas
this[TILE_ADD].set(atlas,add);this[TILE_REMOVE].set(atlas,remove);return atlas;}/**
	 * Destroys a vertex atlas object and removes all event handlers used to add
	 * and remove data from the atlas.
	 *
	 * @param {VertexAtlas} atlas - The vertex atlas to destroy.
	 */},{key:'destroyVertexAtlas',value:function destroyVertexAtlas(atlas){// detach handlers
this.layer.removeListener(EventType.TILE_ADD,this[TILE_ADD].get(atlas));this.layer.removeListener(EventType.TILE_REMOVE,this[TILE_REMOVE].get(atlas));// remove handlers
this[TILE_ADD].delete(atlas);this[TILE_REMOVE].delete(atlas);}}]);return WebGLTileRenderer;}(TileRenderer);module.exports=WebGLTileRenderer;

},{"../../event/EventType":141,"../../webgl/shader/Shader":192,"../../webgl/texture/TextureArray":196,"../../webgl/vertex/VertexAtlas":198,"./TileRenderer":180,"lodash/defaultTo":109}],182:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLTileRenderer=require('../WebGLTileRenderer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute vec2 aTextureCoord;\n\t\tuniform vec4 uTextureCoordOffset;\n\t\tuniform vec2 uTileOffset;\n\t\tuniform float uScale;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvarying vec2 vTextureCoord;\n\t\tvoid main() {\n\t\t\tvTextureCoord = vec2(\n\t\t\t\tuTextureCoordOffset.x + (aTextureCoord.x * uTextureCoordOffset.z),\n\t\t\t\tuTextureCoordOffset.y + (aTextureCoord.y * uTextureCoordOffset.w));\n\t\t\tvec2 wPosition = (aPosition * uScale) + uTileOffset;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform sampler2D uTextureSampler;\n\t\tuniform float uOpacity;\n\t\tvarying vec2 vTextureCoord;\n\t\tvoid main() {\n\t\t\tvec4 color = texture2D(uTextureSampler, vec2(vTextureCoord.x, 1.0 - vTextureCoord.y));\n\t\t\tgl_FragColor = vec4(color.rgb, color.a * uOpacity);\n\t\t}\n\t\t'};var createQuad=function createQuad(gl,min,max){var vertices=new Float32Array(24);// positions
vertices[0]=min;vertices[1]=min;vertices[2]=max;vertices[3]=min;vertices[4]=max;vertices[5]=max;vertices[6]=min;vertices[7]=min;vertices[8]=max;vertices[9]=max;vertices[10]=min;vertices[11]=max;// uvs
vertices[12]=0;vertices[13]=0;vertices[14]=1;vertices[15]=0;vertices[16]=1;vertices[17]=1;vertices[18]=0;vertices[19]=0;vertices[20]=1;vertices[21]=1;vertices[22]=0;vertices[23]=1;// create quad buffer
return new VertexBuffer(gl,vertices,{0:{size:2,type:'FLOAT',byteOffset:0},1:{size:2,type:'FLOAT',byteOffset:2*6*4}},{count:6});};/**
 * Class representing a webgl image tile renderer.
 */var ImageTileRenderer=function(_WebGLTileRenderer){_inherits(ImageTileRenderer,_WebGLTileRenderer);/**
	 * Instantiates a new ImageTileRenderer object.
	 */function ImageTileRenderer(){_classCallCheck(this,ImageTileRenderer);var _this=_possibleConstructorReturn(this,(ImageTileRenderer.__proto__||Object.getPrototypeOf(ImageTileRenderer)).call(this));_this.quad=null;_this.shader=null;_this.array=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {ImageTileRenderer} The renderer object, for chaining.
	 */_createClass(ImageTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(ImageTileRenderer.prototype.__proto__||Object.getPrototypeOf(ImageTileRenderer.prototype),'onAdd',this).call(this,layer);this.quad=createQuad(this.gl,0,layer.plot.tileSize);this.shader=this.createShader(SHADER_GLSL);this.array=this.createTextureArray({chunkSize:layer.plot.tileSize});return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {ImageTileRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.destroyTextureArray(this.array);this.array=null;this.quad=null;this.shader=null;_get(ImageTileRenderer.prototype.__proto__||Object.getPrototypeOf(ImageTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {ImageTileRenderer} The renderer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;var shader=this.shader;var array=this.array;var quad=this.quad;var renderables=this.getRenderablesLOD();var proj=this.getOrthoMatrix();// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uTextureSampler',0);shader.setUniform('uOpacity',this.layer.opacity);// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind quad
quad.bind();// for each renderable
for(var i=0;i<renderables.length;i++){var renderable=renderables[i];array.bind(renderable.hash,0);// set tile uniforms
shader.setUniform('uTextureCoordOffset',renderable.uvOffset);shader.setUniform('uScale',renderable.scale);shader.setUniform('uTileOffset',renderable.tileOffset);// draw
quad.draw();// no need to unbind texture
}// unbind quad
quad.unbind();return this;}}]);return ImageTileRenderer;}(WebGLTileRenderer);module.exports=ImageTileRenderer;

},{"../../../webgl/vertex/VertexBuffer":199,"../WebGLTileRenderer":181}],183:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLTileRenderer=require('../WebGLTileRenderer');// Constants
/**
 * Numver of vertices supported per chunk.
 * @private
 * @constant {number}
 */var CHUNK_SIZE=128*128;/**
 * Inner radius of star.
 * @private
 * @constant {number}
 */var STAR_INNER_RADIUS=0.4;/**
 * Outer radius of star.
 * @private
 * @constant {number}
 */var STAR_OUTER_RADIUS=1.0;/**
 * number of points on the star.
 * @private
 * @constant {number}
 */var STAR_NUM_POINTS=5;/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute vec2 aOffset;\n\t\tattribute float aRadius;\n\t\tuniform vec2 uTileOffset;\n\t\tuniform float uScale;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * aRadius) + (aOffset * uScale) + uTileOffset;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform vec4 uColor;\n\t\tvoid main() {\n\t\t\tgl_FragColor = uColor;\n\t\t}\n\t\t'};// Private Methods
var createStar=function createStar(gl){var theta=2*Math.PI/STAR_NUM_POINTS;var htheta=theta/2.0;var qtheta=theta/4.0;var positions=new Float32Array(STAR_NUM_POINTS*2*2+4);positions[0]=0;positions[1]=0;for(var i=0;i<STAR_NUM_POINTS;i++){var angle=i*theta;var sx=Math.cos(angle-qtheta)*STAR_INNER_RADIUS;var sy=Math.sin(angle-qtheta)*STAR_INNER_RADIUS;positions[i*4+2]=sx;positions[i*4+1+2]=sy;sx=Math.cos(angle+htheta-qtheta)*STAR_OUTER_RADIUS;sy=Math.sin(angle+htheta-qtheta)*STAR_OUTER_RADIUS;positions[i*4+2+2]=sx;positions[i*4+3+2]=sy;}positions[positions.length-2]=positions[2];positions[positions.length-1]=positions[3];return new VertexBuffer(gl,positions,{0:{size:2,type:'FLOAT'}},{mode:'TRIANGLE_FAN',count:positions.length/2});};/**
 * Class representing a webgl instanced shape tile renderer.
 */var InstancedTileRenderer=function(_WebGLTileRenderer){_inherits(InstancedTileRenderer,_WebGLTileRenderer);/**
	 * Instantiates a new InstancedTileRenderer object.
	 *
	 * @param {Object} options - The options object.
	 * @param {Array} options.color - The color of the points.
	 */function InstancedTileRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,InstancedTileRenderer);var _this=_possibleConstructorReturn(this,(InstancedTileRenderer.__proto__||Object.getPrototypeOf(InstancedTileRenderer)).call(this));_this.color=defaultTo(options.color,[1.0,0.4,0.1,0.8]);_this.shape=null;_this.shader=null;_this.atlas=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */_createClass(InstancedTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(InstancedTileRenderer.prototype.__proto__||Object.getPrototypeOf(InstancedTileRenderer.prototype),'onAdd',this).call(this,layer);this.shape=createStar(this.gl);this.shader=this.createShader(SHADER_GLSL);this.atlas=this.createVertexAtlas({chunkSize:CHUNK_SIZE,attributePointers:{// offset
1:{size:2,type:'FLOAT'},// radius
2:{size:1,type:'FLOAT'}}});return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.destroyVertexAtlas(this.atlas);this.atlas=null;this.shape=null;this.shader=null;_get(InstancedTileRenderer.prototype.__proto__||Object.getPrototypeOf(InstancedTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;var shader=this.shader;var atlas=this.atlas;var shape=this.shape;var renderables=this.getRenderables();var proj=this.getOrthoMatrix();// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uColor',this.color);// bind shape
shape.bind();// binds the buffer to instance
atlas.bindInstanced();// for each renderable
for(var i=0;i<renderables.length;i++){var renderable=renderables[i];// set tile uniforms
shader.setUniform('uScale',renderable.scale);shader.setUniform('uTileOffset',renderable.tileOffset);// draw the instances
atlas.drawInstanced(renderable.hash,shape.mode,shape.count);}// unbind
atlas.unbindInstanced();// unbind quad
shape.unbind();return this;}}]);return InstancedTileRenderer;}(WebGLTileRenderer);module.exports=InstancedTileRenderer;

},{"../../../webgl/vertex/VertexBuffer":199,"../WebGLTileRenderer":181,"lodash/defaultTo":109}],184:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var CircleCollidable=require('../../../geometry/CircleCollidable');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLTileRenderer=require('../WebGLTileRenderer');// Constants
/**
 * Numver of vertices supported per chunk.
 * @private
 * @constant {number}
 */var CHUNK_SIZE=128*128;/**
 * Highlighted point radius increase.
 * @private
 * @constant {number}
 */var HIGHLIGHTED_RADIUS_OFFSET=2;/**
 * Selected point radius increase.
 * @private
 * @constant {number}
 */var SELECTED_RADIUS_OFFSET=4;/**
 * R-Tree node capacity.
 * @private
 * @constant {number}
 */var NODE_CAPACITY=32;/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute float aRadius;\n\t\tuniform float uRadiusOffset;\n\t\tuniform vec2 uTileOffset;\n\t\tuniform float uScale;\n\t\tuniform float uPixelRatio;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) + uTileOffset;\n\t\t\tgl_PointSize = (aRadius + uRadiusOffset) * uScale * 2.0 * uPixelRatio;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t#extension GL_OES_standard_derivatives : enable\n\t\t#endif\n\t\tprecision highp float;\n\t\tuniform vec4 uColor;\n\t\tvoid main() {\n\t\t\tvec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\t\t\tfloat radius = dot(cxy, cxy);\n\t\t\tfloat alpha = 1.0;\n\t\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t\tfloat delta = fwidth(radius);\n\t\t\t\talpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, radius);\n\t\t\t#else\n\t\t\t\tif (radius > 1.0) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\tgl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\n\t\t}\n\t\t'};// Private Methods
var createPoint=function createPoint(gl){var vertices=new Float32Array(2);vertices[0]=0.0;vertices[1]=0.0;// create quad buffer
return new VertexBuffer(gl,vertices,{0:{size:2,type:'FLOAT'}},{mode:'POINTS',count:1});};var createCollidables=function createCollidables(tile,xOffset,yOffset){var data=tile.data;var collidables=new Array(data.length/3);for(var i=0;i<data.length;i+=3){// add collidable
collidables[i/3]=new CircleCollidable(data[i],// x
data[i+1],// y
data[i+2],// radius
xOffset,yOffset,tile);}return collidables;};var renderTiles=function renderTiles(atlas,shader,renderables,color){// set global uniforms
shader.setUniform('uColor',color);shader.setUniform('uRadiusOffset',0);// binds the buffer to instance
atlas.bind();// for each renderable
for(var i=0;i<renderables.length;i++){var renderable=renderables[i];// set tile uniforms
shader.setUniform('uScale',renderable.scale);shader.setUniform('uTileOffset',renderable.tileOffset);// draw points
atlas.draw(renderable.hash,'POINTS');}// unbind
atlas.unbind();};var renderPoint=function renderPoint(point,shader,plot,target,color,radius){// get tile offset
var coord=target.tile.coord;var scale=Math.pow(2,plot.zoom-coord.z);var viewport=plot.getViewportPixelOffset();var tileOffset=[(coord.x*plot.tileSize+target.x)*scale-viewport.x,(coord.y*plot.tileSize+target.y)*scale-viewport.y];// set uniforms
shader.setUniform('uTileOffset',tileOffset);shader.setUniform('uScale',scale);shader.setUniform('uColor',color);shader.setUniform('uRadiusOffset',radius+target.radius);// binds the buffer to instance
point.bind();// draw the points
point.draw();// unbind
point.unbind();};/**
 * Class representing a webgl interactive point tile renderer.
 */var InteractiveTileRenderer=function(_WebGLTileRenderer){_inherits(InteractiveTileRenderer,_WebGLTileRenderer);/**
	 * Instantiates a new InteractiveTileRenderer object.
	 *
	 * @param {Object} options - The options object.
	 * @param {Array} options.color - The color of the points.
	 */function InteractiveTileRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,InteractiveTileRenderer);var _this=_possibleConstructorReturn(this,(InteractiveTileRenderer.__proto__||Object.getPrototypeOf(InteractiveTileRenderer)).call(this));_this.color=defaultTo(options.color,[1.0,0.4,0.1,0.8]);_this.shader=null;_this.point=null;_this.tree=null;_this.atlas=null;_this.ext=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */_createClass(InteractiveTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(InteractiveTileRenderer.prototype.__proto__||Object.getPrototypeOf(InteractiveTileRenderer.prototype),'onAdd',this).call(this,layer);// get the extension for standard derivatives
this.ext=this.gl.getExtension('OES_standard_derivatives');this.point=createPoint(this.gl);this.shader=this.createShader(SHADER_GLSL);this.tree=this.createRTreePyramid({nodeCapacity:NODE_CAPACITY,createCollidables:createCollidables});this.atlas=this.createVertexAtlas({chunkSize:CHUNK_SIZE,attributePointers:{// position
0:{size:2,type:'FLOAT'},// radius
1:{size:1,type:'FLOAT'}}});return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.destroyVertexAtlas(this.atlas);this.destroyRTreePyramid(this.tree);this.atlas=null;this.shader=null;this.point=null;this.tree=null;this.ext=null;_get(InteractiveTileRenderer.prototype.__proto__||Object.getPrototypeOf(InteractiveTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * Pick a position of the renderer for a collision with any rendered objects.
	 *
	 * @param {Object} pos - The plot position to pick at.
	 *
	 * @returns {Object} The collision, if any.
	 */},{key:'pick',value:function pick(pos){if(this.layer.plot.isZooming()){return null;}return this.tree.searchPoint(pos.x,pos.y,this.layer.plot.zoom,this.layer.plot.getPixelExtent());}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'draw',value:function draw(){var _this2=this;var gl=this.gl;var layer=this.layer;var plot=layer.plot;var projection=this.getOrthoMatrix();var shader=this.shader;// bind render target
plot.renderBuffer.bind();// clear render target
plot.renderBuffer.clear();// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE);// use shader
shader.use();// set uniforms
shader.setUniform('uProjectionMatrix',projection);shader.setUniform('uPixelRatio',plot.pixelRatio);// render the tiles
renderTiles(this.atlas,shader,this.getRenderables(),this.color);// render selected
layer.getSelected().forEach(function(selected){renderPoint(_this2.point,shader,plot,selected,_this2.color,SELECTED_RADIUS_OFFSET);});// render highlighted
var highlighted=layer.getHighlighted();if(highlighted&&!layer.isSelected(highlighted)){renderPoint(this.point,shader,plot,highlighted,this.color,HIGHLIGHTED_RADIUS_OFFSET);}// unbind render target
plot.renderBuffer.unbind();// render framebuffer to the backbuffer
plot.renderBuffer.blitToScreen(this.layer.opacity);return this;}}]);return InteractiveTileRenderer;}(WebGLTileRenderer);module.exports=InteractiveTileRenderer;

},{"../../../geometry/CircleCollidable":147,"../../../webgl/vertex/VertexBuffer":199,"../WebGLTileRenderer":181,"lodash/defaultTo":109}],185:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var WebGLTileRenderer=require('../WebGLTileRenderer');// Constants
/**
 * Numver of vertices supported per chunk.
 * @private
 * @constant {number}
 */var CHUNK_SIZE=128*128;/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute float aRadius;\n\t\tuniform vec2 uTileOffset;\n\t\tuniform float uScale;\n\t\tuniform float uPixelRatio;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) + uTileOffset;\n\t\t\tgl_PointSize = aRadius * 2.0 * uPixelRatio;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t#extension GL_OES_standard_derivatives : enable\n\t\t#endif\n\t\tprecision highp float;\n\t\tuniform vec4 uColor;\n\t\tvoid main() {\n\t\t\tvec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\t\t\tfloat radius = dot(cxy, cxy);\n\t\t\tfloat alpha = 1.0;\n\t\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t\tfloat delta = fwidth(radius);\n\t\t\t\talpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, radius);\n\t\t\t#else\n\t\t\t\tif (radius > 1.0) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\tgl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\n\t\t}\n\t\t'};/**
 * Class representing a webgl point tile renderer.
 */var PointTileRenderer=function(_WebGLTileRenderer){_inherits(PointTileRenderer,_WebGLTileRenderer);/**
	 * Instantiates a new PointTileRenderer object.
	 *
	 * @param {Object} options - The options object.
	 * @param {Array} options.color - The color of the points.
	 */function PointTileRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PointTileRenderer);var _this=_possibleConstructorReturn(this,(PointTileRenderer.__proto__||Object.getPrototypeOf(PointTileRenderer)).call(this));_this.color=defaultTo(options.color,[1.0,0.4,0.1,0.8]);_this.shader=null;_this.atlas=null;_this.ext=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */_createClass(PointTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(PointTileRenderer.prototype.__proto__||Object.getPrototypeOf(PointTileRenderer.prototype),'onAdd',this).call(this,layer);// get the extension for standard derivatives
this.ext=this.gl.getExtension('OES_standard_derivatives');this.shader=this.createShader(SHADER_GLSL);this.atlas=this.createVertexAtlas({chunkSize:CHUNK_SIZE,attributePointers:{// position
0:{size:2,type:'FLOAT'},// radius
1:{size:1,type:'FLOAT'}}});return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.destroyVertexAtlas(this.atlas);this.atlas=null;this.shader=null;this.ext=null;_get(PointTileRenderer.prototype.__proto__||Object.getPrototypeOf(PointTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;var shader=this.shader;var atlas=this.atlas;var plot=this.layer.plot;var renderables=this.getRenderables();var proj=this.getOrthoMatrix();// bind render target
plot.renderBuffer.bind();// clear render target
plot.renderBuffer.clear();// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uColor',this.color);shader.setUniform('uPixelRatio',plot.pixelRatio);// binds the vertex atlas
atlas.bind();// for each renderable
for(var i=0;i<renderables.length;i++){var renderable=renderables[i];// set tile uniforms
shader.setUniform('uScale',renderable.scale);shader.setUniform('uTileOffset',renderable.tileOffset);// draw the points
atlas.draw(renderable.hash,'POINTS');}// unbind
atlas.unbind();// unbind render target
plot.renderBuffer.unbind();// render framebuffer to the backbuffer
plot.renderBuffer.blitToScreen(this.layer.opacity);return this;}}]);return PointTileRenderer;}(WebGLTileRenderer);module.exports=PointTileRenderer;

},{"../WebGLTileRenderer":181,"lodash/defaultTo":109}],186:[function(require,module,exports){
'use strict';// https://github.com/arasatasaygin/is.js/blob/master/is.js
var userAgent=(navigator&&navigator.userAgent||'').toLowerCase();var vendor=(navigator&&navigator.vendor||'').toLowerCase();/**
 * Test if the browser is firefox.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is firefox.
 */var isFirefox=function isFirefox(){return userAgent.match(/(?:firefox|fxios)\/(\d+)/);};/**
 * Test if the browser is chrome.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is chrome.
 */var isChrome=function isChrome(){return /google inc/.test(vendor)?userAgent.match(/(?:chrome|crios)\/(\d+)/):null;};/**
 * Test if the browser is internet explorer.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is internet explorer.
 */var isIE=function isIE(){return userAgent.match(/(?:msie |trident.+?; rv:)(\d+)/);};/**
 * Test if the browser is edge.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is edge.
 */var isEdge=function isEdge(){return userAgent.match(/edge\/(\d+)/);};/**
 * Test if the browser is opera.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is opera.
 */var isOpera=function isOpera(){return userAgent.match(/(?:^opera.+?version|opr)\/(\d+)/);};/**
 * Test if the browser is safari.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is safari.
 */var isSafari=function isSafari(){return userAgent.match(/version\/(\d+).+?safari/);};/**
 * Browser detection.
 * @private
 */module.exports={/**
	 * Whether or not the browser is firefox.
	 * @constant {boolean}
	 */firefox:!!isFirefox(),/**
	 * Whether or not the browser is chrome.
	 * @constant {boolean}
	 */chrome:!!isChrome(),/**
	 * Whether or not the browser is ie.
	 * @constant {boolean}
	 */ie:!!isIE(),/**
	 * Whether or not the browser is edge.
	 * @constant {boolean}
	 */edge:!!isEdge(),/**
	 * Whether or not the browser is opera.
	 * @constant {boolean}
	 */opera:!!isOpera(),/**
	 * Whether or not the browser is safari.
	 * @constant {boolean}
	 */safari:!!isSafari()};

},{}],187:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var LinkedList=require('./LinkedList');// Constants
/**
 * Max size symbol.
 * @private
 * @constant {Symbol}
 */var CAPACITY=Symbol();/**
 * Dispose function symbol.
 * @private
 * @constant {Symbol}
 */var ON_REMOVE=Symbol();/**
 * Cache symbol.
 * @private
 * @constant {Symbol}
 */var CACHE=Symbol();/**
 * LRU linked list symbol.
 * @private
 * @constant {Symbol}
 */var LRU_LIST=Symbol();/**
 * LRU length symbol.
 * @private
 * @constant {Symbol}
 */var LENGTH=Symbol();// Private Methods
var del=function del(self,node){if(node){var hit=node.value;if(self[ON_REMOVE]){self[ON_REMOVE](hit.value,hit.key);}self[LENGTH]--;self[CACHE].delete(hit.key);self[LRU_LIST].removeNode(node);}};/**
 * Class representing an LRU cache.
 * @private
 */var LRUCache=function(){/**
	 * Instantiates a new LRUCache object.
	 *
	 * @param {Object} options - The options object.
	 * @param {number} options.capacity - The capacity of the cache.
	 * @param {Function} options.onRemove - A function to execute when a value is evicted.
	 */function LRUCache(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,LRUCache);this[CAPACITY]=defaultTo(Math.max(1,options.capacity),256);this[ON_REMOVE]=defaultTo(options.onRemove,null);this.clear();}/**
	 * Returns the capacity of the cache.
	 *
	 * @returns {number} - The capcity of the cache.
	 */_createClass(LRUCache,[{key:'getCapacity',value:function getCapacity(){return this[CAPACITY];}/**
	 * Returns the length of the cache.
	 *
	 * @returns {number} - The length of the cache.
	 */},{key:'getLength',value:function getLength(){return this[LENGTH];}/**
	 * Iterates over and executes the provided function for all values.
	 * NOTE: Does not update recentness of the entries.
	 *
	 * @param {Function} fn - The function to execute on each value and key.
	 */},{key:'forEach',value:function forEach(fn){for(var node=this[LRU_LIST].head;node!==null;){var next=node.next;fn(node.value.value,node.value.key);node=next;}}/**
	 * Clears all entries in the cache.
	 */},{key:'clear',value:function clear(){var _this=this;if(this[ON_REMOVE]&&this[LRU_LIST]){this[LRU_LIST].forEach(function(hit){_this[ON_REMOVE](hit.value,hit.key);});}this[CACHE]=new Map();this[LRU_LIST]=new LinkedList();this[LENGTH]=0;}/**
	 * Set a value under the provided key, removing the previous entry if one
	 * exists.
	 *
	 * @param {string} key - The key string.
	 * @param {*} value - The value.
	 */},{key:'set',value:function set(key,value){if(this[CACHE].has(key)){// if we already have an entry
var node=this[CACHE].get(key);var item=node.value;// execute onRemove for old value before evicting
if(this[ON_REMOVE]){this[ON_REMOVE](item.value,key);}// set the new value
item.value=value;this.get(key);// no need to trim, since the length remained constant
return;}// add new entry
var hit=new Entry(key,value);this[LENGTH]++;this[LRU_LIST].unshift(hit);this[CACHE].set(key,this[LRU_LIST].head);// trim any old entry
if(this[LENGTH]>this[CAPACITY]){// delete oldest entry
del(this,this[LRU_LIST].tail);}}/**
	 * Returns whether or not the entry is in the LRU cache under the provided
	 * key.
	 * NOTE: Does not update recentness of the entry.
	 *
	 * @param {string} key - The key string.
	 *
	 * @returns {boolean} Whether or not the key exists.
	 */},{key:'has',value:function has(key){if(!this[CACHE].has(key)){return false;}return true;}/**
	 * Returns the entry in the LRU cache under the provided key.
	 * NOTE: Updates the recentness of the entry.
	 *
	 * @param {string} key - The key string.
	 *
	 * @returns {*} The value in the cache.
	 */},{key:'get',value:function get(key){var node=this[CACHE].get(key);if(node){// update recentness
this[LRU_LIST].unshiftNode(node);return node.value.value;}return undefined;}/**
	 * Returns the entry in the LRU cache under the provided key.
	 * NOTE: Does not update recentness of the entry.
	 *
	 * @param {string} key - The key string.
	 *
	 * @returns {*} The value in the cache.
	 */},{key:'peek',value:function peek(key){var node=this[CACHE].get(key);if(node){return node.value.value;}return undefined;}/**
	 * Removes the entry in the LRU cache under the provided key.
	 *
	 * @param {string} key - The key string.
	 */},{key:'delete',value:function _delete(key){del(this,this[CACHE].get(key));}}]);return LRUCache;}();/**
 * Class representing an LRU cache entry.
 * @private
 */var Entry=/**
	 * Instantiates a new Entry object.
	 *
	 * @param {string} key - The entry key.
	 * @param {*} value - The entry value.
	 */function Entry(key,value){_classCallCheck(this,Entry);this.key=key;this.value=value;};module.exports=LRUCache;

},{"./LinkedList":188,"lodash/defaultTo":109}],188:[function(require,module,exports){
'use strict';/**
 * Class representing a linked list.
 * @private
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var LinkedList=function(){/**
	 * Instantiates a new LinkedList object.
	 */function LinkedList(){_classCallCheck(this,LinkedList);this.tail=null;this.head=null;this.length=0;}/**
	 * Push an item to the end of the linked list.
	 *
	 * @param {*} item - The item to add.
	 *
	 * @returns {number} The new length of the list.
	 */_createClass(LinkedList,[{key:'push',value:function push(item){this.tail=new Node(item,this.tail,null,this);if(!this.head){this.head=this.tail;}this.length++;return this.length;}/**
	 * Push an item to the front of the linked list.
	 *
	 * @param {*} item - The item to add.
	 *
	 * @returns {number} The new length of the list.
	 */},{key:'unshift',value:function unshift(item){this.head=new Node(item,null,this.head,this);if(!this.tail){this.tail=this.head;}this.length++;return this.length;}/**
	 * Remove an item front the end of the linked list.
	 *
	 * @returns {*} The removed value.
	 */},{key:'pop',value:function pop(){if(!this.tail){return undefined;}var res=this.tail.value;this.tail=this.tail.prev;if(this.tail){this.tail.next=null;}else{this.head=null;}this.length--;return res;}/**
	 * Remove an item from the front of the linked list.
	 *
	 * @returns {*} The removed value.
	 */},{key:'shift',value:function shift(){if(!this.head){return undefined;}var res=this.head.value;this.head=this.head.next;if(this.head){this.head.prev=null;}else{this.tail=null;}this.length--;return res;}/**
	 * Get an item at a particular index in the list.
	 *
	 * @param {number} n - The index of the element.
	 *
	 * @returns {*} The value.
	 */},{key:'get',value:function get(n){var i=void 0;var node=void 0;for(i=0,node=this.head;node!==null&&i<n;i++){// abort out of the list early if we hit a cycle
node=node.next;}if(i===n&&node!==null){return node.value;}}/**
	 * Iterates over and executes the provided function for all values.
	 *
	 * @param {Function} fn - The function to execute on each value.
	 */},{key:'forEach',value:function forEach(fn){for(var node=this.head,i=0;node!==null;i++){fn(node.value,i);node=node.next;}}/**
	 * Iterates over and executes the provided function for all values returning
	 * an array of all mapped values.
	 *
	 * @param {Function} fn - The function to execute on each tile.
	 *
	 * @returns {Array} The array of mapped values.
	 */},{key:'map',value:function map(fn){var arr=new Array(this.length);for(var i=0,node=this.head;node!==null;i++){arr[i]=fn(node.value,i);node=node.next;}return arr;}/**
	 * Push a node to the end of the linked list.
	 *
	 * @param {Node} node - The node to add.
	 *
	 * @returns {number} The new length of the list.
	 */},{key:'pushNode',value:function pushNode(node){if(node===this.tail){return;}if(node.list){node.list.removeNode(node);}var tail=this.tail;node.list=this;node.prev=tail;if(tail){tail.next=node;}this.tail=node;if(!this.head){this.head=node;}this.length++;return this.length;}/**
	 * Push a node to the front of the linked list.
	 *
	 * @param {Node} node - The node to add.
	 *
	 * @returns {number} The new length of the list.
	 */},{key:'unshiftNode',value:function unshiftNode(node){if(node===this.head){return;}if(node.list){node.list.removeNode(node);}var head=this.head;node.list=this;node.next=head;if(head){head.prev=node;}this.head=node;if(!this.tail){this.tail=node;}this.length++;return this.length;}/**
	 * Remove a node from the linked list.
	 *
	 * @param {Node} node - The node to remove.
	 *
	 * @returns {number} The new length of the list.
	 */},{key:'removeNode',value:function removeNode(node){if(node.list!==this){throw'Removing node which does not belong to this list';}var next=node.next;var prev=node.prev;if(next){next.prev=prev;}if(prev){prev.next=next;}if(node===this.head){this.head=next;}if(node===this.tail){this.tail=prev;}node.list.length--;node.next=null;node.prev=null;node.list=null;return this.length;}}]);return LinkedList;}();/**
 * Class representing a linked list node.
 * @private
 */var Node=/**
	 * Instantiates a new Node object.
	 *
	 * @param {*} value - The value of the node.
	 * @param {Node} prev - The previous node.
	 * @param {Node} next - The next node.
	 * @param {LinkedList} list - The linked list.
	 */function Node(value,prev,next,list){_classCallCheck(this,Node);this.list=list;this.value=value;if(prev){prev.next=this;this.prev=prev;}else{this.prev=null;}if(next){next.prev=this;this.next=next;}else{this.next=null;}};module.exports=LinkedList;

},{}],189:[function(require,module,exports){
'use strict';/**
 * Issues a XHR and loads an ArrayBuffer.
 *
 * @param {string} url - The url.
 * @param {Function} done - The callback.
 */module.exports=function(url,done){var req=new XMLHttpRequest();req.open('GET',url,true);req.responseType='arraybuffer';req.onload=function(){var arraybuffer=req.response;if(arraybuffer){done(null,arraybuffer);}else{var err='Unable to load ArrayBuffer from URL: `'+event.path[0].currentSrc+'`';done(err,null);}};req.onerror=function(event){var err='Unable to load ArrayBuffer from URL: `'+event.path[0].currentSrc+'`';done(err,null);};req.withCredentials=true;req.send(null);};

},{}],190:[function(require,module,exports){
'use strict';/**
 * Issues a XHR and loads an Image.
 *
 * @param {string} url - The url.
 * @param {Function} done - The callback.
 */module.exports=function(url,done){var image=new Image();image.onload=function(){done(null,image);};image.onerror=function(event){var err='Unable to load image from URL: `'+event.path[0].currentSrc+'`';done(err,null);};image.crossOrigin='anonymous';image.src=url;};

},{}],191:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Texture=require('./texture/Texture');var Shader=require('./shader/Shader');var VertexBuffer=require('./vertex/VertexBuffer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec3 aVertexPosition;\n\t\tattribute vec2 aTextureCoord;\n\t\tvarying vec2 vTextureCoord;\n\t\tvoid main(void) {\n\t\t\tvTextureCoord = aTextureCoord;\n\t\t\tgl_Position = vec4(aVertexPosition, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform float uOpacity;\n\t\tuniform sampler2D uTextureSampler;\n\t\tvarying vec2 vTextureCoord;\n\t\tvoid main(void) {\n\t\t\tvec4 color = texture2D(uTextureSampler, vTextureCoord);\n\t\t\tgl_FragColor = vec4(color.rgb, color.a * uOpacity);\n\t\t}\n\t\t'};// Private Methods
var createQuad=function createQuad(gl,min,max){var vertices=new Float32Array(24);// positions
vertices[0]=min;vertices[1]=min;vertices[2]=max;vertices[3]=min;vertices[4]=max;vertices[5]=max;vertices[6]=min;vertices[7]=min;vertices[8]=max;vertices[9]=max;vertices[10]=min;vertices[11]=max;// uvs
vertices[12]=0;vertices[13]=0;vertices[14]=1;vertices[15]=0;vertices[16]=1;vertices[17]=1;vertices[18]=0;vertices[19]=0;vertices[20]=1;vertices[21]=1;vertices[22]=0;vertices[23]=1;// create quad buffer
return new VertexBuffer(gl,vertices,{0:{size:2,type:'FLOAT',byteOffset:0},1:{size:2,type:'FLOAT',byteOffset:2*6*4}},{count:6});};var setColorTarget=function setColorTarget(gl,framebuffer,attachment,index){gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl['COLOR_ATTACHMENT'+index],gl.TEXTURE_2D,attachment.texture,0);gl.bindFramebuffer(gl.FRAMEBUFFER,null);};var renderToScreen=function renderToScreen(gl,texture,shader,quad,opacity){// bind shader
shader.use();// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// set uniforms
shader.setUniform('uOpacity',opacity);// set texture sampler unit
shader.setUniform('uTextureSampler',0);// bind texture
texture.bind(0);// draw quad
quad.bind();quad.draw();quad.unbind();};/**
 * Class representing a webgl renderbuffer.
 */var RenderBuffer=function(){/**
	 * Instantiates a RenderBuffer object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {number} width - The width of the renderbuffer.
	 * @param {number} height - The height of the renderbuffer.
	 */function RenderBuffer(gl,width,height){_classCallCheck(this,RenderBuffer);this.gl=gl;this.framebuffer=gl.createFramebuffer();this.shader=new Shader(gl,SHADER_GLSL);this.quad=createQuad(gl,-1,1);this.texture=new Texture(gl,null,{width:width,height:height,filter:'NEAREST',invertY:false,premultiplyAlpha:false});setColorTarget(this.gl,this.framebuffer,this.texture,0);}/**
	 * Binds the renderbuffer for writing.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */_createClass(RenderBuffer,[{key:'bind',value:function bind(){var gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,this.framebuffer);return this;}/**
	 * Unbinds the renderbuffer for writing.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */},{key:'unbind',value:function unbind(){var gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,null);return this;}/**
	 * Clears the renderbuffer buffer color bits.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */},{key:'clear',value:function clear(){this.gl.clearColor(0,0,0,0);this.gl.clear(this.gl.COLOR_BUFFER_BIT);return this;}/**
	 * Blits the renderbuffer texture to the screen.
	 *
	 * @param {number} opacity - The opacity to blit at.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */},{key:'blitToScreen',value:function blitToScreen(opacity){renderToScreen(this.gl,this.texture,this.shader,this.quad,opacity);return this;}/**
	 * Resizes the renderbuffer to the provided height and width.
	 *
	 * @param {number} width - The new width of the renderbuffer.
	 * @param {number} height - The new height of the renderbuffer.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */},{key:'resize',value:function resize(width,height){this.texture.resize(width,height);return this;}}]);return RenderBuffer;}();module.exports=RenderBuffer;

},{"./shader/Shader":192,"./texture/Texture":195,"./vertex/VertexBuffer":199}],192:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var map=require('lodash/map');var parseShader=require('./parseShader');// Constants
var UNIFORM_FUNCTIONS={'bool':'uniform1i','bool[]':'uniform1iv','float':'uniform1f','float[]':'uniform1fv','int':'uniform1i','int[]':'uniform1iv','uint':'uniform1i','uint[]':'uniform1iv','vec2':'uniform2fv','vec2[]':'uniform2fv','ivec2':'uniform2iv','ivec2[]':'uniform2iv','vec3':'uniform3fv','vec3[]':'uniform3fv','ivec3':'uniform3iv','ivec3[]':'uniform3iv','vec4':'uniform4fv','vec4[]':'uniform4fv','ivec4':'uniform4iv','ivec4[]':'uniform4iv','mat2':'uniformMatrix2fv','mat2[]':'uniformMatrix2fv','mat3':'uniformMatrix3fv','mat3[]':'uniformMatrix3fv','mat4':'uniformMatrix4fv','mat4[]':'uniformMatrix4fv','sampler2D':'uniform1i','samplerCube':'uniform1i'};// Private Methods
var setAttributesAndUniforms=function setAttributesAndUniforms(shader,vertSource,fragSource){// parse shader delcarations
var declarations=parseShader([vertSource,fragSource],['uniform','attribute']);// for each declaration in the shader
declarations.forEach(function(declaration){// check if its an attribute or uniform
if(declaration.qualifier==='attribute'){// if attribute, store type and index
shader.attributes.set(declaration.name,{type:declaration.type,index:shader.attributes.size});}else{// if (declaration.qualifier === 'uniform') {
// if uniform, store type and buffer function name
var type=declaration.type+(declaration.count>1?'[]':'');shader.uniforms.set(declaration.name,{type:declaration.type,func:UNIFORM_FUNCTIONS[type]});}});};var formatLine=function formatLine(str,num){str=str.toString();var diff=num-str.length;str+=':';for(var i=0;i<diff;i++){str+=' ';}return str;};var compileShader=function compileShader(gl,shaderSource,type){var shader=gl.createShader(gl[type]);gl.shaderSource(shader,shaderSource);gl.compileShader(shader);if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){var split=shaderSource.split('\n');var maxDigits=split.length.toString().length+1;var srcByLines=split.map(function(line,index){return formatLine(index+1,maxDigits)+' '+line;}).join('\n');var shaderLog=gl.getShaderInfoLog(shader);throw'An error occurred compiling the shader:\n\n'+shaderLog.slice(0,shaderLog.length-1)+'\n'+srcByLines;}return shader;};var bindAttributeLocations=function bindAttributeLocations(shader){var gl=shader.gl;shader.attributes.forEach(function(attribute,name){// bind the attribute location
gl.bindAttribLocation(shader.program,attribute.index,name);});};var getUniformLocations=function getUniformLocations(shader){var gl=shader.gl;var uniforms=shader.uniforms;uniforms.forEach(function(uniform,name){// get the uniform location
var location=gl.getUniformLocation(shader.program,name);// check if null, parse may detect uniform that is compiled out due to
// not being used, or due to a preprocessor evaluation.
if(location===null){uniforms.delete(name);}else{uniform.location=location;}});};var createDefines=function createDefines(defines){return map(defines,function(value,name){return'#define '+name+' '+value;}).join('\n');};var createProgram=function createProgram(shader,sources){// Creates the shader program object from source strings. This includes:
//	1) Compiling and linking the shader program.
//	2) Parsing shader source for attribute and uniform information.
//	3) Binding attribute locations, by order of delcaration.
//	4) Querying and storing uniform location.
var gl=shader.gl;var defines=createDefines(sources.define);var common=defines+(sources.common||'');var vert=common+sources.vert;var frag=common+sources.frag;// compile shaders
var vertexShader=compileShader(gl,vert,'VERTEX_SHADER');var fragmentShader=compileShader(gl,frag,'FRAGMENT_SHADER');// parse source for attribute and uniforms
setAttributesAndUniforms(shader,vert,frag);// create the shader program
shader.program=gl.createProgram();// attach vertex and fragment shaders
gl.attachShader(shader.program,vertexShader);gl.attachShader(shader.program,fragmentShader);// bind vertex attribute locations BEFORE linking
bindAttributeLocations(shader);// link shader
gl.linkProgram(shader.program);// If creating the shader program failed, alert
if(!gl.getProgramParameter(shader.program,gl.LINK_STATUS)){throw'An error occured linking the shader:\n'+gl.getProgramInfoLog(shader.program);}// get shader uniform locations
getUniformLocations(shader);};/**
 * Class representing a shader program.
 */var Shader=function(){/**
	 * Instantiates a Shader object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {Object} params - The shader params object.
	 * @param {string} params.common - Common glsl to be shared by both vertex and fragment shaders.
	 * @param {string} params.vert - The vertex shader glsl.
	 * @param {string} params.frag - The fragment shader glsl.
	 * @param {Object} params.define - Any #define directives to include in the glsl.
	 */function Shader(gl){var params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Shader);// check source arguments
if(!params.vert){throw'Vertex shader argument `vert` has not been provided';}if(!params.frag){throw'Fragment shader argument `frag` has not been provided';}this.gl=gl;this.program=null;this.attributes=new Map();this.uniforms=new Map();// create the shader program
createProgram(this,params);}/**
	 * Binds the shader program for use.
	 *
	 * @returns {Shader} The shader object, for chaining.
	 */_createClass(Shader,[{key:'use',value:function use(){// use the shader
this.gl.useProgram(this.program);return this;}/**
	 * Buffer a uniform value by name.
	 *
	 * @param {string} name - The uniform name in the shader source.
	 * @param {*} value - The uniform value to buffer.
	 *
	 * @returns {Shader} The shader object, for chaining.
	 */},{key:'setUniform',value:function setUniform(name,value){var uniform=this.uniforms.get(name);// ensure that the uniform params exists for the name
if(!uniform){throw'No uniform found under name `'+name+'`';}// check value
if(value===undefined||value===null){// ensure that the uniform argument is defined
throw'Value passed for uniform `'+name+'` is undefined or null';}// set the uniform
// NOTE: checking type by string comparison is faster than wrapping
// the functions.
if(uniform.type==='mat2'||uniform.type==='mat3'||uniform.type==='mat4'){this.gl[uniform.func](uniform.location,false,value);}else{this.gl[uniform.func](uniform.location,value);}return this;}}]);return Shader;}();module.exports=Shader;

},{"./parseShader":193,"lodash/map":127}],193:[function(require,module,exports){
'use strict';var preprocess=require('./preprocess');// Constants
var COMMENTS_REGEXP=/(\/\*([\s\S]*?)\*\/)|(\/\/(.*)$)/gm;var ENDLINE_REGEXP=/(\r\n|\n|\r)/gm;var WHITESPACE_REGEXP=/\s{2,}/g;var BRACKET_WHITESPACE_REGEXP=/(\s*)(\[)(\s*)(\d+)(\s*)(\])(\s*)/g;var NAME_COUNT_REGEXP=/([a-zA-Z_][a-zA-Z0-9_]*)(?:\[(\d+)\])?/;var PRECISION_REGEX=/\bprecision\s+\w+\s+\w+;/g;var INLINE_PRECISION_REGEX=/\b(highp|mediump|lowp)\s+/g;// Private Methods
var stripComments=function stripComments(str){// regex source: https://github.com/moagrius/stripcomments
return str.replace(COMMENTS_REGEXP,'');};var stripPrecision=function stripPrecision(str){return str.replace(PRECISION_REGEX,'')// remove global precision declarations
.replace(INLINE_PRECISION_REGEX,'');// remove inline precision declarations
};var normalizeWhitespace=function normalizeWhitespace(str){return str.replace(ENDLINE_REGEXP,' ')// normalize line endings
.replace(WHITESPACE_REGEXP,' ')// normalize whitespace to single ' '
.replace(BRACKET_WHITESPACE_REGEXP,'$2$4$6');// remove whitespace in brackets
};var parseNameAndCount=function parseNameAndCount(qualifier,type,entry){// determine name and size of variable
var matches=entry.match(NAME_COUNT_REGEXP);var name=matches[1];var count=matches[2]===undefined?1:parseInt(matches[2],10);return{qualifier:qualifier,type:type,name:name,count:count};};var parseStatement=function parseStatement(statement){// split statement on commas
//
// ['uniform mat4 A[10]', 'B', 'C[2]']
//
var split=statement.split(',').map(function(elem){return elem.trim();});// split declaration header from statement
//
// ['uniform', 'mat4', 'A[10]']
//
var header=split.shift().split(' ');// qualifier is always first element
//
// 'uniform'
//
var qualifier=header.shift();// type will be the second element
//
// 'mat4'
//
var type=header.shift();// last part of header will be the first, and possible only variable name
//
// ['A[10]', 'B', 'C[2]']
//
var names=header.concat(split);// if there are other names after a ',' add them as well
return names.map(function(name){return parseNameAndCount(qualifier,type,name);});};var parseSource=function parseSource(source,keywords){// splits the source string by semi-colons and constructs an array of
// declaration objects based on the provided qualifier keywords.
// get individual statements (any sequence ending in ;)
var statements=source.split(';');// build regex for parsing statements with targetted keywords
var keywordStr=keywords.join('|');var keywordRegex=new RegExp('\\b('+keywordStr+')\\b.*');// parse and store global precision statements and any declarations
var matched=[];// for each statement
statements.forEach(function(statement){// check for keywords
//
// ['uniform float uTime']
//
var kmatch=statement.match(keywordRegex);if(kmatch){// parse statement and add to array
matched=matched.concat(parseStatement(kmatch[0]));}});return matched;};var filterDuplicatesByName=function filterDuplicatesByName(declarations){// in cases where the same declarations are present in multiple
// sources, this function will remove duplicates from the results
var seen={};return declarations.filter(function(declaration){if(seen[declaration.name]){return false;}seen[declaration.name]=true;return true;});};/**
 * Parses the provided GLSL source, and returns all declaration statements that
 * contain the provided qualifier types. This can be used to extract the
 * attributes and uniform names / types from a shader.
 * NOTE: This is run only AFTER compilation succeed, so it assumes VALID syntax.
 *
 * Ex, when provided a 'uniform' qualifier, the declaration:
 *
 *    'uniform highp vec3 uSpecularColor;'
 *
 * Would be parsed to:
 *    {
 *        qualifier: 'uniform',
 *        type: 'vec3'
 *        name: 'uSpecularColor',
 *        count: 1
 *    }
 *
 * @private
 * @param {Array} sources - The shader glsl sources.
 * @param {Array} qualifiers - The qualifiers to extract.
 *
 * @returns {Array} The array of qualifier declaration statements.
 */module.exports=function(){var sources=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var qualifiers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];// if no sources or qualifiers are provided, return empty array
if(sources.length===0||qualifiers.length===0){return[];}sources=Array.isArray(sources)?sources:[sources];qualifiers=Array.isArray(qualifiers)?qualifiers:[qualifiers];// parse out targetted declarations
var declarations=[];sources.forEach(function(source){// remove comments
source=stripComments(source);// run preprocessor
source=preprocess(source);// remove precision statements
source=stripPrecision(source);// finally, normalize the whitespace
source=normalizeWhitespace(source);// parse out declarations
declarations=declarations.concat(parseSource(source,qualifiers));});// remove duplicates and return
return filterDuplicatesByName(declarations);};

},{"./preprocess":194}],194:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var DEFINED='__DEFINED__';var DEFINE_REGEX=/#define\b/i;var UNDEF_REGEX=/#undef\b/i;var IF_REGEX=/#if\b/i;var IFDEF_REGEX=/#ifdef\b/i;var IFNDEF_REGEX=/#ifndef\b/i;var ELSE_REGEX=/#else\b/i;var ELIF_REGEX=/#elif\b/i;var ENDIF_REGEX=/#endif\b/i;var PARSE_DEFINE_REGEX=/#define\s+(\w+)(\s(\w*)?)?/i;var PARSE_UNDEF_REGEX=/#undef\s+(\w+)/i;var PARSE_IF_REGEX=/#if\s+\(?\s*(!?\s*\w+)\s*(==|!=|>=|<=|<|>)?\s*(\w*)\s*\)?/i;var PARSE_IFDEF_REGEX=/#ifdef\s+(\w+)/i;var PARSE_IFNDEF_REGEX=/#ifndef\s+(\w+)/i;var PARSE_ELIF_REGEX=/#elif\s+\(?\s*(!?\s*\w+)\s*(==|!=|>=|<=|<|>)?\s*(\w*)\s*\)?/i;var REMAINING_REGEX=/#([\W\w\s\d])(?:.*\\r?\n)*.*$/gm;var evalIf=function evalIf(a,logic,b){if(logic===undefined){if(a[0]==='!'){return!(a==='true'||a>=1);}return a==='true'||a>=1;}switch(logic){case'==':return a===b;case'!=':return a!==b;case'>':return a>b;case'>=':return a>=b;case'<':return a<b;case'<=':return a<=b;}throw'Unrecognized logical operator `'+logic+'`';};var Conditional=function(){function Conditional(type,conditional){_classCallCheck(this,Conditional);this.type=type;this.conditional=conditional.trim();this.body=[];this.children=[];}_createClass(Conditional,[{key:'eval',value:function _eval(){var parsed=void 0;switch(this.type){case'if':parsed=PARSE_IF_REGEX.exec(this.conditional);return evalIf(parsed[1],parsed[2],parsed[3]);case'ifdef':parsed=PARSE_IFDEF_REGEX.exec(this.conditional);return parsed[1]===DEFINED;case'ifndef':parsed=PARSE_IFNDEF_REGEX.exec(this.conditional);return parsed[1]!==DEFINED;case'elif':parsed=PARSE_ELIF_REGEX.exec(this.conditional);return evalIf(parsed[1],parsed[2],parsed[3]);}throw'Unrecognized conditional type `'+this.type+'`';}}]);return Conditional;}();var Block=function(){function Block(type,conditional,lineNum){_classCallCheck(this,Block);this.if=new Conditional(type,conditional);this.elif=[];this.else=null;this.parent=null;this.current=this.if;this.startLine=lineNum;this.endLine=null;}_createClass(Block,[{key:'addElse',value:function addElse(conditional){this.current=new Conditional('else',conditional);this.else=this.current;}},{key:'addElif',value:function addElif(conditional){this.current=new Conditional('elif',conditional);this.elif.push(this.current);}},{key:'addBody',value:function addBody(line,lineNum){this.current.body.push({string:line.trim(),line:lineNum});}},{key:'nest',value:function nest(block){block.parent=this;this.current.children.push(block);}},{key:'extract',value:function extract(){// #if
var body=[];if(this.if.eval()){body=body.concat(this.if.body);this.if.children.forEach(function(child){body=body.concat(child.extract());});return body;}// #elif
for(var i=0;i<this.elif.length;i++){var elif=this.elif[i];if(elif.eval()){body=body.concat(elif.body);for(var j=0;j<elif.children.length;j++){var child=elif.children[j];body=body.concat(child.extract());}return body;}}// #else
if(this.else){body=body.concat(this.else.body);this.else.children.forEach(function(child){body=body.concat(child.extract());});return body;}return[];}},{key:'eval',value:function _eval(){// ensure extract text is ordered correctly
return this.extract().sort(function(a,b){return a.line-b.line;}).map(function(arg){return arg.string;}).join('\n');}}]);return Block;}();var parseLines=function parseLines(lines){var blocks=[];var current=null;lines.forEach(function(line,index){if(line.match(IF_REGEX)){// #if
var block=new Block('if',line,index);if(!current){blocks.push(block);}else{current.nest(block);}current=block;}else if(line.match(IFDEF_REGEX)){// #ifdef
var _block=new Block('ifdef',line,index);if(!current){blocks.push(_block);}else{current.nest(_block);}current=_block;}else if(line.match(IFNDEF_REGEX)){// #ifndef
var _block2=new Block('ifndef',line,index);if(!current){blocks.push(_block2);}else{current.nest(_block2);}current=_block2;}else if(line.match(ELIF_REGEX)){// #elif
if(!current){throw'Invalid preprocessor syntax, unexpected `#elif`';}current.addElif(line);}else if(line.match(ELSE_REGEX)){// #else
if(!current){throw'Invalid preprocessor syntax, unexpected `#else`';}current.addElse(line);}else if(line.match(ENDIF_REGEX)){// #endif
if(!current){throw'Invalid preprocessor syntax, unexpected `#endif`';}current.endLine=index;current=current.parent;}else{// other
if(current){current.addBody(line,index);}}});if(current){throw'Invalid preprocessor syntax, missing expected `#endif`';}return blocks;};var replaceDefines=function replaceDefines(lines){var defines=new Map();var replaced=[];lines.forEach(function(line){if(line.match(DEFINE_REGEX)){// #define
var parsed=PARSE_DEFINE_REGEX.exec(line);defines.set(parsed[1],parsed[2]||DEFINED);}else if(line.match(UNDEF_REGEX)){// #undef
var _parsed=PARSE_UNDEF_REGEX.exec(line);defines.delete(_parsed[1]);}else if(line.match(IFDEF_REGEX)){// #ifdef
var _parsed2=PARSE_IFDEF_REGEX.exec(line);if(defines.has(_parsed2[1])){line=line.replace(_parsed2[1],DEFINED);}replaced.push(line);}else if(line.match(IFNDEF_REGEX)){// #ifndef
var _parsed3=PARSE_IFNDEF_REGEX.exec(line);if(defines.has(_parsed3[1])){line=line.replace(_parsed3[1],DEFINED);}replaced.push(line);}else{// swap defines
defines.forEach(function(val,define){line=line.replace(define,val);});replaced.push(line);}});return replaced;};/**
 * Evaluates GLSL preprocessor statements.
 * NOTE: assumes comments have been stripped, and preprocessors are valid.
 *
 *     Supported:
 *
 *         #define (substitutions only)
 *         #undef
 *         #if (== and != comparisons only)
 *         #ifdef
 *         #ifndef
 *         #elif
 *         #else
 *         #endif
 *
 *     Not Supported:
 *
 *         #define (macros)
 *         #if (&& and || operators, defined() predicate)
 *         #error
 *         #pragma
 *         #extension
 *         #version
 *         #line
 *
 * @private
 * @param {string} glsl - The glsl source code.
 *
 * @returns {string} The processed glsl source code.
 */module.exports=function(glsl){// split lines
var lines=glsl.split('\n');// replace any defines with their values
lines=replaceDefines(lines);// parse them
var blocks=parseLines(lines);// remove blocks in reverse order to preserve line numbers
for(var i=blocks.length-1;i>=0;i--){var block=blocks[i];var replacement=block.eval();if(replacement.length>0){lines.splice(block.startLine,block.endLine-block.startLine+1,replacement);}else{lines.splice(block.startLine,block.endLine-block.startLine+1);}}// strip remaining unsupported preprocessor statements
return lines.join('\n').replace(REMAINING_REGEX,'');};

},{}],195:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');/**
 * Class representing a texture.
 */var Texture=function(){/**
	 * Instantiates a Texture object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {ArrayBuffer|CanvasElement} src - The data to buffer.
	 * @param {Object} options - The texture options.
	 * @param {number} options.width - The width of the texture.
	 * @param {number} options.height - The height of the texture.
	 * @param {string} options.format - The texture pixel format.
	 * @param {string} options.type - The texture pixel component type.
	 * @param {string} options.filter - The min / mag filter used during scaling.
	 * @param {string} options.wrap - The wrapping type over both S and T dimension.
	 * @param {bool} options.invertY - Whether or not invert-y is enabled.
	 * @param {bool} options.premultiplyAlpha - Whether or not alpha premultiplying is enabled.
	 */function Texture(gl){var src=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,Texture);this.gl=gl;this.texture=gl.createTexture();// set texture properties
this.format=defaultTo(options.format,'RGBA');this.type=defaultTo(options.type,'UNSIGNED_BYTE');this.filter=defaultTo(options.filter,'LINEAR');this.wrap=defaultTo(options.wrap,'CLAMP_TO_EDGE');this.invertY=defaultTo(options.invertY,false);this.premultiplyAlpha=defaultTo(options.premultiplyAlpha,false);// buffer the data
this.bufferData(src,options.width,options.height);// set parameters
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl[this.wrap]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl[this.wrap]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl[this.filter]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl[this.filter]);}/**
	 * Binds the texture object to the provided texture unit location.
	 *
	 * @param {number} location - The texture unit location index. Optional.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */_createClass(Texture,[{key:'bind',value:function bind(){var location=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var gl=this.gl;gl.activeTexture(gl['TEXTURE'+location]);gl.bindTexture(gl.TEXTURE_2D,this.texture);return this;}/**
	 * Unbinds the texture object.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */},{key:'unbind',value:function unbind(){var gl=this.gl;gl.bindTexture(gl.TEXTURE_2D,null);return this;}/**
	 * Buffer data into the texture.
	 *
	 * @param {Array|ArrayBufferView|null} data - The data array to buffer.
	 * @param {number} width - The width of the data.
	 * @param {number} height - The height of the data.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */},{key:'bufferData',value:function bufferData(data,width,height){var gl=this.gl;// bind texture
gl.bindTexture(gl.TEXTURE_2D,this.texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,this.invertY);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha);// buffer the data
if(data&&data.width&&data.height){// store width and height
this.width=data.width;this.height=data.height;// buffer the texture
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[this.format],// webgl requires format === internalFormat
gl[this.format],gl[this.type],data);}else{// store width and height
this.width=width||this.width;this.height=height||this.height;// buffer the texture data
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[this.format],// webgl requires format === internalFormat
this.width,this.height,0,// border, must be 0
gl[this.format],gl[this.type],data);}return this;}/**
	 * Buffer partial data into the texture.
	 *
	 * @param {Array|ArrayBufferView|null} data - The data array to buffer.
	 * @param {number} xOffset - The x offset at which to buffer.
	 * @param {number} yOffset - The y offset at which to buffer.
	 * @param {number} width - The width of the data.
	 * @param {number} height - The height of the data.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */},{key:'bufferSubData',value:function bufferSubData(data){var xOffset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var yOffset=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var width=arguments.length>3&&arguments[3]!==undefined?arguments[3]:undefined;var height=arguments.length>4&&arguments[4]!==undefined?arguments[4]:undefined;var gl=this.gl;// bind texture
gl.bindTexture(gl.TEXTURE_2D,this.texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,this.invertY);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha);// buffer the data
if(data.width&&data.height){// buffer the texture
gl.texSubImage2D(gl.TEXTURE_2D,0,// mip-map level
xOffset,yOffset,gl[this.format],gl[this.type],data);}else{// buffer the texture data
gl.texSubImage2D(gl.TEXTURE_2D,0,// mip-map level
xOffset,yOffset,width,height,gl[this.format],gl[this.type],data);}return this;}/**
	 * Resize the underlying texture. This clears the texture data.
	 *
	 * @param {number} width - The new width of the texture.
	 * @param {number} height - The new height of the texture.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */},{key:'resize',value:function resize(width,height){this.bufferData(null,width,height);return this;}}]);return Texture;}();module.exports=Texture;

},{"lodash/defaultTo":109}],196:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');// Private Methods
var createTexture=function createTexture(gl,format,size,type,filter,wrap,invertY,premultiplyAlpha){var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,invertY);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,premultiplyAlpha);// buffer the data
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[format],// webgl requires format === internalFormat
size,size,0,// border, must be 0
gl[format],gl[type],null);// set parameters
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl[wrap]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl[wrap]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl[filter]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl[filter]);return texture;};/**
 * Class representing a texture array.
 */var TextureArray=function(){/**
	 * Instantiates a new TextureArray object.
	 *
	 * NOTE: we use a texture array rather than a texture atlas because of
	 * the sub-pixel bleeding that occurs in the atlas when textures are
	 * not padded. Due to the overhead of padding clientside, the
	 * frequency of load load events, and the average number of tiles on
	 * the screen at any one time, binding individual tile textures
	 * provides a less volatile frame rate compared to padding textures and
	 * using an atlas.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {Object} params - The texture parameters.
	 * @param {string} params.format - The texture pixel format.
	 * @param {string} params.type - The texture pixel component type.
	 * @param {string} params.filter - The min / mag filter used during scaling.
	 * @param {string} params.wrap - The wrapping type over both S and T dimension.
	 * @param {bool} params.invertY - Whether or not invert-y is enabled.
	 * @param {bool} params.premultiplyAlpha - Whether or not alpha premultiplying is enabled.
	 * @param {Object} options - The texture array options.
	 * @param {number} options.chunkSize - The dimension of each texture, in pixels.
	 * @param {number} options.numChunks - The size of the array, in tiles.
	 */function TextureArray(gl){var params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,TextureArray);this.gl=gl;// set array properties
this.chunkSize=defaultTo(options.chunkSize,256);this.numChunks=defaultTo(options.numChunks,256);// set texture parameters
this.format=defaultTo(params.format,'RGBA');this.type=defaultTo(params.type,'UNSIGNED_BYTE');this.filter=defaultTo(params.filter,'LINEAR');this.wrap=defaultTo(params.wrap,'CLAMP_TO_EDGE');this.invertY=defaultTo(params.invertY,false);this.premultiplyAlpha=defaultTo(params.premultiplyAlpha,false);// create textures
this.available=new Array(this.numChunks);for(var i=0;i<this.numChunks;i++){this.available[i]={texture:createTexture(this.gl,this.format,this.chunkSize,this.type,this.filter,this.wrap,this.invertY,this.premultiplyAlpha)};}// create used chunk map
this.used=new Map();}/**
	 * Test whether or not a key is held in the array.
	 *
	 * @param {string} key - The key to test.
	 *
	 * @returns {boolean} Whether or not the coord exists in the pyramid.
	 */_createClass(TextureArray,[{key:'has',value:function has(key){return this.used.has(key);}/**
	 * Returns the chunk matching the provided key. If the chunk does not
	 * exist, returns undefined.
	 *
	 * @param {string} key - The key of the chunk to return.
	 *
	 * @returns {Object} The chunk object.
	 */},{key:'get',value:function get(key){return this.used.get(key);}/**
	 * Set the texture data for the provided key.
	 *
	 * @param {string} key - The key of the texture data.
	 * @param {ArrayBuffer|HTMLCanvasElement|HTMLImageElement} data - The texture data.
	 */},{key:'set',value:function set(key,data){if(this.has(key)){throw'Tile of coord '+key+' already exists in the array';}if(this.available.length===0){throw'No available texture chunks in array';}// get an available chunk
var chunk=this.available.pop();// buffer the data
var gl=this.gl;gl.bindTexture(gl.TEXTURE_2D,chunk.texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,this.invertY);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha);if(data.width&&data.height){// canvas type
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[this.format],// webgl requires format === internalFormat
gl[this.format],gl[this.type],data);}else{// arraybuffer type
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[this.format],// webgl requires format === internalFormat
this.chunkSize,this.chunkSize,0,// border, must be 0
gl[this.format],gl[this.type],data);}// add to used
this.used.set(key,chunk);}/**
	 * Flags the chunk matching the provided key as unused in the array.
	 *
	 * @param {string} key - The key of the chunk to free.
	 *
	 * @returns {TextureArray} The TextureArray object, for chaining.
	 */},{key:'delete',value:function _delete(key){if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the array';}// get chunk
var chunk=this.used.get(key);// remove from used
this.used.delete(key);// add to available
this.available.push(chunk);return this;}/**
	 * Binds the texture array to the provided texture unit.
	 *
	 * @param {string} key - The key of the chunk to bind.
	 * @param {string} location - The texture unit to activate. Optional.
	 *
	 * @returns {TextureArray} The TextureArray object, for chaining.
	 */},{key:'bind',value:function bind(key){var location=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the array';}var gl=this.gl;var chunk=this.used.get(key);gl.activeTexture(gl['TEXTURE'+location]);gl.bindTexture(gl.TEXTURE_2D,chunk.texture);return this;}/**
	 * Unbinds the texture array.
	 *
	 * @returns {TextureArray} The TextureArray object, for chaining.
	 */},{key:'unbind',value:function unbind(){// no-op
return this;}}]);return TextureArray;}();module.exports=TextureArray;

},{"lodash/defaultTo":109}],197:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');/**
 * Class representing an index buffer.
 */var IndexBuffer=function(){/**
	 * Instantiates an IndexBuffer object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {WebGLBuffer|ArrayBuffer|number} arg - The index data to buffer.
	 * @param {Object} options - The rendering options.
	 * @param {string} options.type - The buffer component type.
	 * @param {string} options.mode - The draw mode / primitive type.
	 * @param {string} options.byteOffset - The byte offset into the drawn buffer.
	 * @param {string} options.count - The number of vertices to draw.
	 */function IndexBuffer(gl,arg){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,IndexBuffer);this.gl=gl;this.type=defaultTo(options.type,'UNSIGNED_SHORT');this.mode=defaultTo(options.mode,'TRIANGLES');this.count=defaultTo(options.count,0);this.byteOffset=defaultTo(options.byteOffset,0);// create buffer
if(arg instanceof WebGLBuffer){this.buffer=arg;}else{this.buffer=gl.createBuffer();if(arg){// buffer the data
this.bufferData(arg);}}}/**
	 * Upload index data to the GPU.
	 *
	 * @param {ArrayBuffer|number} arg - The array of data to buffer.
	 *
	 * @returns {IndexBuffer} The index buffer object, for chaining.
	 */_createClass(IndexBuffer,[{key:'bufferData',value:function bufferData(arg){var gl=this.gl;gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,arg,gl.STATIC_DRAW);}/**
	 * Upload partial index data to the GPU.
	 *
	 * @param {ArrayBuffer} array - The array of data to buffer.
	 * @param {number} byteOffset - The byte offset at which to buffer.
	 *
	 * @returns {IndexBuffer} The index buffer object, for chaining.
	 */},{key:'bufferSubData',value:function bufferSubData(array){var byteOffset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var gl=this.gl;gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffer);gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER,byteOffset,array);return this;}/**
	 * Execute the draw command for the bound buffer.
	 *
	 * @returns {IndexBuffer} The index buffer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffer);gl.drawElements(gl[this.mode],this.count,gl[this.type],this.byteOffset);// no need to unbind
return this;}}]);return IndexBuffer;}();module.exports=IndexBuffer;

},{"lodash/defaultTo":109}],198:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var forIn=require('lodash/forIn');// Constants
var BYTES_PER_TYPE={BYTE:1,UNSIGNED_BYTE:1,SHORT:2,UNSIGNED_SHORT:2,FIXED:4,FLOAT:4};// Private Methods
var calcChunkByteSize=function calcChunkByteSize(pointers,chunkSize){var byteSize=0;pointers.forEach(function(pointer){byteSize+=BYTES_PER_TYPE[pointer.type]*pointer.size*chunkSize;});return byteSize;};var calcByteOffsets=function calcByteOffsets(chunk,pointers,chunkByteOffset){var byteOffset=0;pointers.forEach(function(pointer,location){chunk.byteOffsets[location]=chunkByteOffset+byteOffset;byteOffset+=BYTES_PER_TYPE[pointer.type]*pointer.size;});};var calcStride=function calcStride(pointers){var stride=0;pointers.forEach(function(pointer){stride+=pointer.size;});return stride;};var parseAttributePointers=function parseAttributePointers(pointers){var attributePointers=new Map();var byteOffset=0;// convert to map
forIn(pointers,function(pointer,index){attributePointers.set(index,{type:pointer.type,size:pointer.size,byteOffset:byteOffset,byteStride:0});byteOffset+=BYTES_PER_TYPE[pointer.type]*pointer.size;});// add byte stride
attributePointers.forEach(function(pointer){pointer.byteStride=byteOffset;});return attributePointers;};/**
 * Class representing a vertex atlas.
 */var VertexAtlas=function(){/**
	 * Instantiates a new VertexAtlas object.
	 * NOTE: Assumes interleaved vertex format.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {Object} pointers - The vertex attribute pointers.
	 * @param {Object} options - The vertex atlas options.
	 * @param {number} options.chunkSize - The size of a single chunk, in vertices.
	 * @param {number} options.numChunks - The size of the atlas, in tiles.
	 */function VertexAtlas(gl,pointers){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,VertexAtlas);// get context
this.gl=gl;// get the extension for hardware instancing
this.ext=gl.getExtension('ANGLE_instanced_arrays');if(!this.ext){throw'ANGLE_instanced_arrays WebGL extension is not supported';}// set atlas properties
this.chunkSize=defaultTo(options.chunkSize,128*128);this.numChunks=defaultTo(options.numChunks,256);// set the pointers of the atlas
if(!pointers){throw'No attribute pointers provided';}this.pointers=parseAttributePointers(pointers);// calc stride of the atlas
this.stride=calcStride(this.pointers);// create available chunks
this.available=new Array(this.numChunks);// calc the chunk byte size
var chunkByteSize=calcChunkByteSize(this.pointers,this.chunkSize);// for each chunk
for(var i=0;i<this.numChunks;i++){var chunkOffset=i*this.chunkSize;var chunkByteOffset=i*chunkByteSize;var available={count:0,chunkOffset:chunkOffset,chunkByteOffset:chunkByteOffset,byteOffsets:{}};// calculate interleaved offsets / stride, this only needs
// to be done once
calcByteOffsets(available,this.pointers,chunkByteOffset);// add chunk
this.available[i]=available;}// create used chunk map
this.used=new Map();// create buffer
this.buffer=gl.createBuffer();// calc total size of the buffer
var byteSize=chunkByteSize*this.numChunks;// buffer the data
gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);gl.bufferData(gl.ARRAY_BUFFER,byteSize,gl.DYNAMIC_DRAW);}/**
	 * Test whether or not a key is held in the atlas.
	 *
	 * @param {string} key - The key to test.
	 *
	 * @returns {boolean} Whether or not the coord exists in the pyramid.
	 */_createClass(VertexAtlas,[{key:'has',value:function has(key){return this.used.has(key);}/**
	 * Returns the chunk matching the provided key. If the chunk does not
	 * exist, returns undefined.
	 *
	 * @param {string} key - The key of the chunk to return.
	 *
	 * @returns {Object} The chunk object.
	 */},{key:'get',value:function get(key){return this.used.get(key);}/**
	 * Set the vertex data for the provided key.
	 *
	 * @param {string} key - The key of the vertex data.
	 * @param {ArrayBuffer} data - The vertex data.
	 * @param {number} count - The count of vertices added.
	 */},{key:'set',value:function set(key,data,count){if(this.has(key)){throw'Tile of coord '+key+' already exists in the atlas';}if(this.available.length===0){throw'No available vertex chunks in atlas';}if(count>this.chunkSize){throw'Data count of '+count+' is greater that allocated size of '+this.chunkSize;}// get an available chunk
var chunk=this.available.pop();// update chunk count
chunk.count=count;// only actually buffer the data if there is  data
if(count>0){// buffer the data
var gl=this.gl;gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);gl.bufferSubData(gl.ARRAY_BUFFER,chunk.chunkByteOffset,data);}// add to used
this.used.set(key,chunk);}/**
	 * Flags the chunk matching the provided key as unused in the atlas.
	 *
	 * @param {string} key - The key of the chunk to free.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'delete',value:function _delete(key){if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the atlas';}// get chunk
var chunk=this.used.get(key);// remove from used
this.used.delete(key);// add to available
this.available.push(chunk);return this;}/**
	 * Binds the vertex atlas and activates the attribute arrays.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'bind',value:function bind(){var gl=this.gl;// bind the buffer
gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);// for each attribute pointer
this.pointers.forEach(function(pointer,index){// enable attribute index
gl.enableVertexAttribArray(index);// set attribute pointer
gl.vertexAttribPointer(index,pointer.size,gl[pointer.type],false,pointer.byteStride,pointer.byteOffset);});return this;}/**
	 * Binds the vertex atlas and activates the attribute arrays for
	 * instancing.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'bindInstanced',value:function bindInstanced(){var gl=this.gl;var ext=this.ext;// bind the buffer
gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);// for each attribute pointer
this.pointers.forEach(function(pointer,index){// enable attribute index
gl.enableVertexAttribArray(index);// enable instancing this attribute
ext.vertexAttribDivisorANGLE(index,1);});return this;}/**
	 * Unbinds the vertex atlas and disables the vertex arrays.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'unbind',value:function unbind(){var gl=this.gl;// for each attribute pointer
this.pointers.forEach(function(pointer,index){// disable attribute index
gl.disableVertexAttribArray(index);});return this;}/**
	 * Unbinds the vertex atlas and disables the vertex arrays for
	 * instancing.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'unbindInstanced',value:function unbindInstanced(){var gl=this.gl;var ext=this.ext;// for each attribute pointer
this.pointers.forEach(function(pointer,index){// disable attribute index
gl.disableVertexAttribArray(index);// disable instancing this attribute
ext.vertexAttribDivisorANGLE(index,0);});return this;}/**
	 * Execute the draw command at the correct offset and count within the
	 * atlas.
	 *
	 * @param {string} key - The key of the chunk to draw.
	 * @param {string} mode - The primitive drawing mode to use.
	 * @param {number} offset - The offset into the chunk. Optional.
	 * @param {number} count - The count of primitives to render. Optional.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'draw',value:function draw(key,mode){var offset=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var count=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the atlas';}var gl=this.gl;var chunk=this.used.get(key);// only actually draw if count > 0
if(chunk.count>0){// draw the chunk
gl.drawArrays(gl[mode],chunk.chunkOffset+offset,count?count:chunk.count);}}/**
	 * Execute the instanced draw command at the correct offset and count within
	 * the atlas.
	 *
	 * @param {string} key - The key of the chunk to draw.
	 * @param {string} mode - The primitive drawing mode to use.
	 * @param {number} count - The count of primitives to render. Optional.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'drawInstanced',value:function drawInstanced(key,mode,count){if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the atlas';}var gl=this.gl;var ext=this.ext;var chunk=this.used.get(key);// for each attribute pointer
this.pointers.forEach(function(pointer,index){// set attribute pointer
gl.vertexAttribPointer(index,pointer.size,gl[pointer.type],false,pointer.byteStride,chunk.byteOffsets[index]);});// only actually draw if count > 0
if(chunk.count>0){// draw the bound vertex array
ext.drawArraysInstancedANGLE(gl[mode],0,count,chunk.count);}}}]);return VertexAtlas;}();module.exports=VertexAtlas;

},{"lodash/defaultTo":109,"lodash/forIn":111}],199:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var forIn=require('lodash/forIn');// Constants
var BYTES_PER_TYPE={BYTE:1,UNSIGNED_BYTE:1,SHORT:2,UNSIGNED_SHORT:2,FIXED:4,FLOAT:4};// Private Methods
var getStride=function getStride(pointers){// if there is only one attribute pointer assigned to this buffer,
// there is no need for stride, set to default of 0
if(pointers.size===1){return 0;}var maxByteOffset=0;var byteSizeSum=0;var byteStride=0;pointers.forEach(function(pointer){var byteOffset=pointer.byteOffset;var size=pointer.size;var type=pointer.type;// track the sum of each attribute size
byteSizeSum+=size*BYTES_PER_TYPE[type];// track the largest offset to determine the byte stride of the buffer
if(byteOffset>maxByteOffset){maxByteOffset=byteOffset;byteStride=byteOffset+size*BYTES_PER_TYPE[type];}});// check if the max byte offset is greater than or equal to the the sum
// of the sizes. If so this buffer is not interleaved and does not need
// a stride.
if(maxByteOffset>=byteSizeSum){// TODO: test what stride === 0 does for an interleaved buffer of
// length === 1.
return 0;}return byteStride;};var getAttributePointers=function getAttributePointers(attributePointers){// parse pointers to ensure they are valid
var pointers=new Map();forIn(attributePointers,function(pointer,key){// parse index from string to int
var index=parseInt(key,10);// ensure byte offset exists
pointer.byteOffset=defaultTo(pointer.byteOffset,0);// add to map
pointers.set(index,pointer);});return pointers;};/**
 * Class representing a vertex buffer.
 */var VertexBuffer=function(){/**
	 * Instantiates an VertexBuffer object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {WebGLBuffer|ArrayBuffer|number} arg - The buffer or length of the buffer.
	 * @param {Object} pointers - The array pointer map.
	 * @param {Object} options - The vertex buffer options.
	 * @param {string} options.mode - The draw mode / primitive type.
	 * @param {string} options.indexOffset - The index offset into the drawn buffer.
	 * @param {string} options.count - The number of indices to draw.
	 */function VertexBuffer(gl,arg){var pointers=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};_classCallCheck(this,VertexBuffer);this.gl=gl;this.mode=defaultTo(options.mode,'TRIANGLES');this.count=defaultTo(options.count,0);this.indexOffset=defaultTo(options.indexOffset,0);// first, set the attribute pointers
this.pointers=getAttributePointers(pointers);// set the byte stride
this.byteStride=getStride(this.pointers);// create buffer
if(arg instanceof WebGLBuffer){this.buffer=arg;}else{this.buffer=gl.createBuffer();if(arg){// buffer the data
this.bufferData(arg);}}}/**
	 * Upload vertex data to the GPU.
	 *
	 * @param {ArrayBuffer|number} arg - The array of data to buffer, or size of the buffer in bytes.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */_createClass(VertexBuffer,[{key:'bufferData',value:function bufferData(arg){var gl=this.gl;gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);gl.bufferData(gl.ARRAY_BUFFER,arg,gl.STATIC_DRAW);return this;}/**
	 * Upload partial vertex data to the GPU.
	 *
	 * @param {ArrayBuffer} array - The array of data to buffer.
	 * @param {number} byteOffset - The byte offset at which to buffer.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'bufferSubData',value:function bufferSubData(array){var byteOffset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var gl=this.gl;gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);gl.bufferSubData(gl.ARRAY_BUFFER,byteOffset,array);return this;}/**
	 * Binds the vertex buffer object.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'bind',value:function bind(){var _this=this;var gl=this.gl;// bind buffer
gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);// for each attribute pointer
this.pointers.forEach(function(pointer,index){// set attribute pointer
gl.vertexAttribPointer(index,pointer.size,gl[pointer.type],false,_this.byteStride,pointer.byteOffset);// enable attribute index
gl.enableVertexAttribArray(index);});return this;}/**
	 * Unbinds the vertex buffer object.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'unbind',value:function unbind(){var gl=this.gl;this.pointers.forEach(function(pointer,index){// disable attribute index
gl.disableVertexAttribArray(index);});return this;}/**
	 * Execute the draw command for the bound buffer.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;gl.drawArrays(gl[this.mode],this.indexOffset,this.count);return this;}}]);return VertexBuffer;}();module.exports=VertexBuffer;

},{"lodash/defaultTo":109,"lodash/forIn":111}]},{},[145])(145)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXNcXGVhcmN1dFxcc3JjXFxlYXJjdXQuanMiLCJub2RlX21vZHVsZXNcXGV2ZW50c1xcZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9EYXRhVmlldy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfSGFzaC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfTGlzdENhY2hlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9NYXAuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9Qcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9TZXQuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX1NldENhY2hlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9TdGFjay5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9XZWFrTWFwLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9hcnJheUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYXJyYXlNYXAuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2FycmF5UHVzaC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYXJyYXlTb21lLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9hc3NvY0luZGV4T2YuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VDbGFtcC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZUVhY2guanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VGb3IuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VGb3JPd24uanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VHZXQuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VHZXRBbGxLZXlzLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9iYXNlSGFzSW4uanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZUlzRXF1YWwuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZUlzTWF0Y2guanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VJc05hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZUl0ZXJhdGVlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9iYXNlS2V5cy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZU1hcC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZU1hdGNoZXMuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZVByb3BlcnR5RGVlcC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfYmFzZVRpbWVzLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9iYXNlVG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Jhc2VVbmFyeS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfY2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2Nhc3RGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfY2FzdFBhdGguanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2NyZWF0ZUJhc2VFYWNoLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9jcmVhdGVCYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9lcXVhbEFycmF5cy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfZXF1YWxCeVRhZy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfZXF1YWxPYmplY3RzLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXG5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfZ2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfZ2V0TWFwRGF0YS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfZ2V0TWF0Y2hEYXRhLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9nZXROYXRpdmUuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfZ2V0U3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfaGFzUGF0aC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfaGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9oYXNoRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9oYXNoU2V0LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9pc0luZGV4LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9pc0tleS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfaXNLZXlhYmxlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9pc01hc2tlZC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfaXNQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfbGlzdENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2xpc3RDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9saXN0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX2xpc3RDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfbWFwQ2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfbWFwQ2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9tYXBDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfbWFwQ2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX21hcFRvQXJyYXkuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9tZW1vaXplQ2FwcGVkLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9uYXRpdmVDcmVhdGUuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX25hdGl2ZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfbm9kZVV0aWwuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9vdmVyQXJnLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9yb290LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9zZXRDYWNoZUFkZC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfc2V0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX3NldFRvQXJyYXkuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX3N0YWNrQ2xlYXIuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX3N0YWNrRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9zdGFja0dldC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxfc3RhY2tIYXMuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX3N0YWNrU2V0LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF9zdHJpbmdUb1BhdGguanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcX3RvS2V5LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXF90b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxjbGFtcC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxkZWJvdW5jZS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxkZWZhdWx0VG8uanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcZXEuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcZm9ySW4uanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcZ2V0LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXGhhc0luLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXGlkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXGlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXGlzQXJyYXkuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcaXNBcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcaXNCdWZmZXIuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcaXNGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxpc0xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxpc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxpc09iamVjdExpa2UuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcaXNTeW1ib2wuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcaXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXGtleXMuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxca2V5c0luLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXG1hcC5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxtZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXG5vdy5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxwcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlc1xcbG9kYXNoXFxzdHViQXJyYXkuanMiLCJub2RlX21vZHVsZXNcXGxvZGFzaFxcc3R1YkZhbHNlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXHRocm90dGxlLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXHRvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzXFxsb2Rhc2hcXHRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzXFxxdWlja3NlbGVjdFxcaW5kZXguanMiLCJub2RlX21vZHVsZXNcXHJidXNoXFxpbmRleC5qcyIsInNyY1xcZXZlbnRcXEV2ZW50LmpzIiwic3JjXFxldmVudFxcRXZlbnRCcm9hZGNhc3Rlci5qcyIsInNyY1xcZXZlbnRcXEV2ZW50RGVsZWdhdG9yLmpzIiwic3JjXFxldmVudFxcRXZlbnRUeXBlLmpzIiwic3JjXFxldmVudFxcTW91c2VFdmVudC5qcyIsInNyY1xcZXZlbnRcXFJlc2l6ZUV2ZW50LmpzIiwic3JjXFxldmVudFxcVGlsZUV2ZW50LmpzIiwic3JjXFxleHBvcnRzLmpzIiwic3JjXFxnZW9tZXRyeVxcQm91bmRzLmpzIiwic3JjXFxnZW9tZXRyeVxcQ2lyY2xlQ29sbGlkYWJsZS5qcyIsInNyY1xcZ2VvbWV0cnlcXFJUcmVlLmpzIiwic3JjXFxnZW9tZXRyeVxcUlRyZWVQeXJhbWlkLmpzIiwic3JjXFxnZW9tZXRyeVxcUmVjdGFuZ2xlQ29sbGlkYWJsZS5qcyIsInNyY1xcZ2VvbWV0cnlcXFJpbmdDb2xsaWRhYmxlLmpzIiwic3JjXFxsYXllclxcTGF5ZXIuanMiLCJzcmNcXGxheWVyXFxvdmVybGF5XFxPdmVybGF5LmpzIiwic3JjXFxsYXllclxcb3ZlcmxheVxcUG9pbnRPdmVybGF5LmpzIiwic3JjXFxsYXllclxcb3ZlcmxheVxcUG9seWdvbk92ZXJsYXkuanMiLCJzcmNcXGxheWVyXFxvdmVybGF5XFxQb2x5bGluZU92ZXJsYXkuanMiLCJzcmNcXGxheWVyXFx0aWxlXFxUaWxlLmpzIiwic3JjXFxsYXllclxcdGlsZVxcVGlsZUNvb3JkLmpzIiwic3JjXFxsYXllclxcdGlsZVxcVGlsZUxheWVyLmpzIiwic3JjXFxsYXllclxcdGlsZVxcVGlsZVBhcnRpYWwuanMiLCJzcmNcXGxheWVyXFx0aWxlXFxUaWxlUHlyYW1pZC5qcyIsInNyY1xccGxvdFxcQ2VsbC5qcyIsInNyY1xccGxvdFxcUGxvdC5qcyIsInNyY1xccGxvdFxcVmlld3BvcnQuanMiLCJzcmNcXHBsb3RcXGFuaW1hdGlvblxcQW5pbWF0aW9uLmpzIiwic3JjXFxwbG90XFxhbmltYXRpb25cXFBhbkFuaW1hdGlvbi5qcyIsInNyY1xccGxvdFxcYW5pbWF0aW9uXFxab29tQW5pbWF0aW9uLmpzIiwic3JjXFxwbG90XFxoYW5kbGVyXFxDbGlja0hhbmRsZXIuanMiLCJzcmNcXHBsb3RcXGhhbmRsZXJcXERPTUhhbmRsZXIuanMiLCJzcmNcXHBsb3RcXGhhbmRsZXJcXE1vdXNlSGFuZGxlci5qcyIsInNyY1xccGxvdFxcaGFuZGxlclxcUGFuSGFuZGxlci5qcyIsInNyY1xccGxvdFxcaGFuZGxlclxcWm9vbUhhbmRsZXIuanMiLCJzcmNcXHJlbmRlcmVyXFxSZW5kZXJlci5qcyIsInNyY1xccmVuZGVyZXJcXG92ZXJsYXlcXE92ZXJsYXlSZW5kZXJlci5qcyIsInNyY1xccmVuZGVyZXJcXG92ZXJsYXlcXFdlYkdMT3ZlcmxheVJlbmRlcmVyLmpzIiwic3JjXFxyZW5kZXJlclxcb3ZlcmxheVxcc2FtcGxlXFxQb2ludE92ZXJsYXlSZW5kZXJlci5qcyIsInNyY1xccmVuZGVyZXJcXG92ZXJsYXlcXHNhbXBsZVxcUG9seWdvbk92ZXJsYXlSZW5kZXJlci5qcyIsInNyY1xccmVuZGVyZXJcXG92ZXJsYXlcXHNhbXBsZVxcUG9seWxpbmVPdmVybGF5UmVuZGVyZXIuanMiLCJzcmNcXHJlbmRlcmVyXFx0aWxlXFxUaWxlUmVuZGVyYWJsZS5qcyIsInNyY1xccmVuZGVyZXJcXHRpbGVcXFRpbGVSZW5kZXJlci5qcyIsInNyY1xccmVuZGVyZXJcXHRpbGVcXFdlYkdMVGlsZVJlbmRlcmVyLmpzIiwic3JjXFxyZW5kZXJlclxcdGlsZVxcc2FtcGxlXFxJbWFnZVRpbGVSZW5kZXJlci5qcyIsInNyY1xccmVuZGVyZXJcXHRpbGVcXHNhbXBsZVxcSW5zdGFuY2VkVGlsZVJlbmRlcmVyLmpzIiwic3JjXFxyZW5kZXJlclxcdGlsZVxcc2FtcGxlXFxJbnRlcmFjdGl2ZVRpbGVSZW5kZXJlci5qcyIsInNyY1xccmVuZGVyZXJcXHRpbGVcXHNhbXBsZVxcUG9pbnRUaWxlUmVuZGVyZXIuanMiLCJzcmNcXHV0aWxcXEJyb3dzZXIuanMiLCJzcmNcXHV0aWxcXExSVUNhY2hlLmpzIiwic3JjXFx1dGlsXFxMaW5rZWRMaXN0LmpzIiwic3JjXFx1dGlsXFxsb2FkQnVmZmVyLmpzIiwic3JjXFx1dGlsXFxsb2FkSW1hZ2UuanMiLCJzcmNcXHdlYmdsXFxSZW5kZXJCdWZmZXIuanMiLCJzcmNcXHdlYmdsXFxzaGFkZXJcXFNoYWRlci5qcyIsInNyY1xcd2ViZ2xcXHNoYWRlclxccGFyc2VTaGFkZXIuanMiLCJzcmNcXHdlYmdsXFxzaGFkZXJcXHByZXByb2Nlc3MuanMiLCJzcmNcXHdlYmdsXFx0ZXh0dXJlXFxUZXh0dXJlLmpzIiwic3JjXFx3ZWJnbFxcdGV4dHVyZVxcVGV4dHVyZUFycmF5LmpzIiwic3JjXFx3ZWJnbFxcdmVydGV4XFxJbmRleEJ1ZmZlci5qcyIsInNyY1xcd2ViZ2xcXHZlcnRleFxcVmVydGV4QXRsYXMuanMiLCJzcmNcXHdlYmdsXFx2ZXJ0ZXhcXFZlcnRleEJ1ZmZlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBLGFBRUEsT0FBTyxPQUFQLENBQWlCLE1BQWpCLENBQ0EsT0FBTyxPQUFQLENBQWUsT0FBZixDQUF5QixNQUF6QixDQUVBLFFBQVMsT0FBVCxDQUFnQixJQUFoQixDQUFzQixXQUF0QixDQUFtQyxHQUFuQyxDQUF3QyxDQUVwQyxJQUFNLEtBQU8sQ0FBYixDQUVBLEdBQUksVUFBVyxhQUFlLFlBQVksTUFBMUMsQ0FDSSxTQUFXLFNBQVcsWUFBWSxDQUFaLEVBQWlCLEdBQTVCLENBQWtDLEtBQUssTUFEdEQsQ0FFSSxVQUFZLFdBQVcsSUFBWCxDQUFpQixDQUFqQixDQUFvQixRQUFwQixDQUE4QixHQUE5QixDQUFtQyxJQUFuQyxDQUZoQixDQUdJLFVBQVksRUFIaEIsQ0FLQSxHQUFJLENBQUMsU0FBTCxDQUFnQixNQUFPLFVBQVAsQ0FFaEIsR0FBSSxLQUFKLENBQVUsSUFBVixDQUFnQixJQUFoQixDQUFzQixJQUF0QixDQUE0QixDQUE1QixDQUErQixDQUEvQixDQUFrQyxPQUFsQyxDQUVBLEdBQUksUUFBSixDQUFjLFVBQVksZUFBZSxJQUFmLENBQXFCLFdBQXJCLENBQWtDLFNBQWxDLENBQTZDLEdBQTdDLENBQVosQ0FFZDtBQUNBLEdB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SUFBUixDQUFhLEdBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBRUEsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBRUEsUUFBUSxJQUFSLENBQWEsRUFBYixFQUNBLFFBQVEsSUFBUixDQUFhLEdBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxHQUFiLEVBRUEsQ0ExQ0QsSUEwQ08sQ0FFTixVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFFQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsR0FBYixFQUNBLFFBQVEsSUFBUixDQUFhLEdBQWIsRUFFQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFFQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsR0FBYixFQUNBLFFBQVEsSUFBUixDQUFhLEVBQWIsRUFFQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFFQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsQ0FBRSxFQUFHLENBQUwsQ0FBUSxFQUFHLENBQVgsQ0FBYixFQUNBLFFBQVEsSUFBUixDQUFhLEdBQWIsRUFFQSxlQUNDLEVBREQsQ0FFQyxJQUFJLEVBQUosQ0FBUSxFQUFSLENBRkQsQ0FHQyxJQUFJLEVBQUosQ0FBUSxFQUFSLENBSEQsQ0FJQyxJQUFJLEVBQUosQ0FBUSxNQUFSLENBSkQsQ0FLQyxTQUxELENBTUMsT0FORCxFQVFBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUVBLFFBQVEsSUFBUixDQUFhLENBQUUsRUFBRyxDQUFMLENBQVEsRUFBRyxDQUFYLENBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsR0FBYixFQUVBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUVBLFFBQVEsSUFBUixDQUFhLEVBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxHQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsRUFBYixFQUVBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUVBLFFBQVEsSUFBUixDQUFhLEVBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxHQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsR0FBYixFQUNBLENBQ0QsQ0FFRCxHQUFNLGdCQUFpQixRQUFqQixlQUFpQixDQUFTLE1BQVQsQ0FBaUIsT0FBakIsQ0FBMEIsQ0FDaEQsR0FBTSxRQUFTLEdBQUksYUFBSixDQUFpQixPQUFPLE1BQVAsQ0FBZ0IsQ0FBakMsQ0FBZixDQUNBLElBQUssR0FBSSxHQUFFLENBQVgsQ0FBYyxFQUFFLE9BQU8sTUFBdkIsQ0FBK0IsR0FBL0IsQ0FBb0MsQ0FDbkMsR0FBTSxPQUFRLE9BQU8sQ0FBUCxDQUFkLENBQ0EsR0FBTSxRQUFTLFFBQVEsQ0FBUixDQUFmLENBQ0EsT0FBTyxFQUFFLENBQVQsRUFBYyxNQUFNLENBQXBCLENBQ0EsT0FBTyxFQUFFLENBQUYsQ0FBSSxDQUFYLEVBQWdCLE1BQU0sQ0FBdEIsQ0FDQSxPQUFPLEVBQUUsQ0FBRixDQUFJLENBQVgsRUFBZ0IsT0FBTyxDQUF2QixDQUNBLE9BQU8sRUFBRSxDQUFGLENBQUksQ0FBWCxFQUFnQixPQUFPLENBQXZCLENBQ0EsQ0FDRCxNQUFPLE9BQVAsQ0FDQSxDQVhELENBYUEsR0FBTSxvQkFBcUIsUUFBckIsbUJBQXFCLENBQVMsT0FBVCxDQUFrQixNQUFsQixDQUEwQixDQUNwRCxHQUFNLFdBQVksUUFBUSxTQUExQixDQUNBLEdBQU0sVUFBVyxrQkFBa0IsTUFBbEIsQ0FBMEIsU0FBMUIsQ0FBakIsQ0FDQSxHQUFNLE1BQU8sZUFBZSxTQUFTLFNBQXhCLENBQW1DLFNBQVMsT0FBNUMsQ0FBYixDQUNBLE1BQU8sSUFBSSxhQUFKLENBQ04sUUFBUSxFQURGLENBRU4sSUFGTSxDQUdOLENBQ0MsRUFBRyxDQUNGLEtBQU0sQ0FESixDQUVGLEtBQU0sT0FGSixDQUdGLFdBQVksQ0FIVixDQURKLENBTUMsRUFBRyxDQUNGLEtBQU0sQ0FESixDQUVGLEtBQU0sT0FGSixDQUdGLFdBQVksRUFBSSxDQUhkLENBTkosQ0FITSxDQWVOLENBQ0MsS0FBTSxXQURQLENBRUMsTUFBTyxTQUFTLFNBQVQsQ0FBbUIsTUFGM0IsQ0FmTSxDQUFQLENBbUJBLENBdkJELENBeUJBOztNQUdNLHdCLDBGQUVMOzs7Ozs7SUFPQSxrQ0FBMEIsSUFBZCxRQUFjLDJEQUFKLEVBQUksdUxBQ25CLE9BRG1CLEdBRXpCLE1BQUssU0FBTCxDQUFpQixVQUFVLFFBQVEsU0FBbEIsQ0FBNkIsQ0FBRSxHQUFGLENBQU8sR0FBUCxDQUFZLEdBQVosQ0FBaUIsR0FBakIsQ0FBN0IsQ0FBakIsQ0FDQSxNQUFLLFNBQUwsQ0FBaUIsVUFBVSxRQUFRLFNBQWxCLENBQTZCLENBQTdCLENBQWpCLENBQ0EsTUFBSyxNQUFMLENBQWMsSUFBZCxDQUNBLE1BQUssS0FBTCxDQUFhLElBQWIsQ0FMeUIsYUFNekIsQ0FFRDs7Ozs7OzRFQU9NLEksQ0FBTSxDQUNYLG1JQUFZLElBQVosRUFDQSxLQUFLLE1BQUwsQ0FBYyxLQUFLLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBZCxDQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7Ozs4Q0FPUyxJLENBQU0sQ0FDZCxzSUFBZSxJQUFmLEVBQ0EsS0FBSyxNQUFMLENBQWMsSUFBZCxDQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7MkRBS2lCLGlCQUNoQixHQUFNLFNBQVUsS0FBSyxPQUFMLENBQWEsa0JBQWIsRUFBaEIsQ0FDQSxHQUFJLE9BQUosQ0FBYSxDQUNaLEtBQUssS0FBTCxDQUFhLFFBQVEsR0FBUixDQUFZLGdCQUFVLENBQ2xDO0FBQ0EsTUFBTywyQkFBeUIsTUFBekIsQ0FBUCxDQUNBLENBSFksQ0FBYixDQUlBLENBTEQsSUFLTyxDQUNOLEtBQUssS0FBTCxDQUFhLElBQWIsQ0FDQSxDQUNELENBRUQ7Ozs7dUNBS08sQ0FDTixHQUFJLENBQUMsS0FBSyxLQUFWLENBQWlCLENBQ2hCLE1BQU8sS0FBUCxDQUNBLENBRUQsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFNLFFBQVMsS0FBSyxNQUFwQixDQUNBLEdBQU0sT0FBUSxLQUFLLEtBQW5CLENBQ0EsR0FBTSxNQUFPLEtBQUssT0FBTCxDQUFhLElBQTFCLENBQ0EsR0FBTSxNQUFPLEtBQUssSUFBbEIsQ0FDQSxHQUFNLE1BQU8sS0FBSyxjQUFMLEVBQWIsQ0FDQSxHQUFNLE9BQVEsS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFZLEtBQUssSUFBTCxDQUFZLEtBQUssSUFBN0IsQ0FBZCxDQUNBLEdBQU0sU0FBVSxLQUFLLE9BQUwsQ0FBYSxPQUE3QixDQUVBO0FBQ0EsR0FBTSxRQUFTLEtBQUssT0FBTCxDQUFhLEtBQUssUUFBbEIsQ0FBNEIsS0FBSyxJQUFqQyxDQUFmLENBRUE7QUFDQSxHQUFHLE1BQUgsQ0FBVSxHQUFHLEtBQWIsRUFDQSxHQUFHLFNBQUgsQ0FBYSxHQUFHLFNBQWhCLENBQTJCLEdBQUcsbUJBQTlCLEVBRUE7QUFDQSxPQUFPLEdBQVAsR0FFQTtBQUNBLE9BQU8sVUFBUCxDQUFrQixtQkFBbEIsQ0FBdUMsSUFBdkMsRUFDQSxPQUFPLFVBQVAsQ0FBa0IsYUFBbEIsQ0FBaUMsQ0FBRSxPQUFPLENBQVQsQ0FBWSxPQUFPLENBQW5CLENBQWpDLEVBQ0EsT0FBTyxVQUFQLENBQWtCLFFBQWxCLENBQTRCLEtBQTVCLEVBQ0EsT0FBTyxVQUFQLENBQWtCLFlBQWxCLENBQWdDLEtBQUssU0FBTCxDQUFpQixDQUFqRCxFQUNBLE9BQU8sVUFBUCxDQUFrQixZQUFsQixDQUFnQyxLQUFLLFNBQXJDLEVBQ0EsT0FBTyxVQUFQLENBQWtCLFVBQWxCLENBQThCLE9BQTlCLEVBRUE7QUFDQSxNQUFNLE9BQU4sQ0FBYyxnQkFBVSxDQUN2QjtBQUNBLE9BQU8sSUFBUCxHQUNBLE9BQU8sSUFBUCxHQUNBLENBSkQsRUFNQSxNQUFPLEtBQVAsQ0FDQSxDLHFDQXpHb0Msb0IsRUE0R3RDLE9BQU8sT0FBUCxDQUFpQix1QkFBakI7OztBQ3hqQkEsYUFFQTsrb0JBRUEsR0FBTSxhQUFjLFFBQWQsWUFBYyxDQUFTLFFBQVQsQ0FBbUIsVUFBbkIsQ0FBK0IsQ0FDbEQsR0FBTSxPQUFRLEVBQUksS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFZLFdBQVcsQ0FBWCxDQUFlLFNBQVMsQ0FBcEMsQ0FBbEIsQ0FDQSxNQUFPLENBQ0wsV0FBVyxDQUFYLENBQWUsS0FBaEIsQ0FBeUIsU0FBUyxDQUQ1QixDQUVMLFdBQVcsQ0FBWCxDQUFlLEtBQWhCLENBQXlCLFNBQVMsQ0FGNUIsQ0FHTixLQUhNLENBSU4sS0FKTSxDQUFQLENBTUEsQ0FSRCxDQVVBOztNQUdNLGUsWUFFTDs7Ozs7OztJQVFBLHdCQUFZLElBQVosQ0FBa0IsS0FBbEIsQ0FBeUIsVUFBekIsQ0FBcUMsUUFBckMsQ0FBK0Msc0NBQzlDLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxLQUFLLElBQUwsQ0FBWSxLQUFLLEtBQUwsQ0FBVyxJQUF2QixDQUNBLEtBQUssS0FBTCxDQUFhLEtBQWIsQ0FDQSxLQUFLLFVBQUwsQ0FBa0IsVUFBbEIsQ0FDQSxLQUFLLFFBQUwsQ0FBZ0IsUUFBaEIsQ0FDQSxDQUVEOzs7Ozs7Ozs7O2lEQThKQTs7Ozs7Ozs7OzRCQVVTLFEsQ0FBVSxRLENBQVUsQ0FDNUI7QUFDQSxHQUFNLFVBQVcsS0FBSyxRQUF0QixDQUNBLFNBQVMsQ0FBVCxFQUFlLEVBQUksU0FBUyxDQUFULENBQUosQ0FBa0IsU0FBUyxDQUFULENBQWpDLENBQ0E7QUFDQSxHQUFNLFlBQWEsS0FBSyxVQUF4QixDQUNBLFdBQVcsQ0FBWCxFQUFnQixTQUFTLE1BQVQsQ0FBa0IsV0FBVyxDQUFYLENBQWxCLENBQW1DLFNBQVcsS0FBSyxLQUFuRSxDQUNBLE1BQU8sS0FBUCxDQUNBLEMsNENBcktlLEksQ0FBTSxLLENBQU8sSyxDQUFPLFEsQ0FBVSxjLENBQWdCLENBQzdELEdBQU0sZ0JBQWlCLE1BQVEsUUFBL0IsQ0FDQSxHQUFNLFlBQWEsQ0FDakIsTUFBTSxDQUFOLENBQVUsY0FBWCxDQUE2QixlQUFlLENBRDFCLENBRWpCLE1BQU0sQ0FBTixDQUFVLGNBQVgsQ0FBNkIsZUFBZSxDQUYxQixDQUFuQixDQUlBLE1BQU8sSUFBSSxlQUFKLENBQ04sSUFETSxDQUVOLEtBRk0sQ0FHTixVQUhNLENBSU4sQ0FBRSxDQUFGLENBQUssQ0FBTCxDQUFRLENBQVIsQ0FBVyxDQUFYLENBSk0sQ0FBUCxDQUtBLENBRUQ7Ozs7Ozs7Ozs7OztzREFhb0IsSSxDQUFNLEssQ0FBTyxLLENBQU8sUSxDQUFVLGMsQ0FBZ0IsTSxDQUFRLFUsQ0FBWSxDQUNyRixHQUFNLGdCQUFpQixNQUFRLFFBQS9CLENBQ0EsR0FBTSxZQUFhLENBQUUsQ0FBRixDQUFLLENBQUwsQ0FBbkIsQ0FDQSxHQUFJLGFBQWUsTUFBbkIsQ0FBMkIsQ0FDMUI7QUFDQTtBQUNBLFdBQVcsQ0FBWCxFQUFpQixNQUFNLENBQU4sQ0FBVSxjQUFYLENBQTZCLGVBQWUsQ0FBNUQsQ0FDQSxXQUFXLENBQVgsRUFBaUIsTUFBTSxDQUFOLENBQVUsY0FBWCxDQUE2QixlQUFlLENBQTVELENBQ0EsQ0FMRCxJQUtPLENBQ047QUFDQTtBQUNBLEdBQU0sYUFBYyxFQUFJLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBWSxXQUFXLENBQVgsQ0FBZSxPQUFPLENBQWxDLENBQXhCLENBQ0EsR0FBTSxTQUFXLFdBQVcsQ0FBWCxDQUFlLFdBQWhCLENBQStCLE9BQU8sQ0FBdEQsQ0FDQSxHQUFNLFNBQVcsV0FBVyxDQUFYLENBQWUsV0FBaEIsQ0FBK0IsT0FBTyxDQUF0RCxDQUNBLFdBQVcsQ0FBWCxFQUFpQixDQUFDLE1BQU0sQ0FBTixDQUFVLE9BQVgsRUFBc0IsY0FBdkIsQ0FBeUMsZUFBZSxDQUF4RSxDQUNBLFdBQVcsQ0FBWCxFQUFpQixDQUFDLE1BQU0sQ0FBTixDQUFVLE9BQVgsRUFBc0IsY0FBdkIsQ0FBeUMsZUFBZSxDQUF4RSxDQUNBLE9BQVMsV0FBVCxDQUNBLENBQ0QsTUFBTyxJQUFJLGVBQUosQ0FDTixJQURNLENBRU4sS0FGTSxDQUdOLFVBSE0sQ0FJTixZQUFZLEtBQUssS0FBakIsQ0FBd0IsVUFBeEIsQ0FKTSxDQUFQLENBS0EsQ0FFRDs7Ozs7Ozs7Ozs7MERBWXNCLEksQ0FBTSxLLENBQU8sSyxDQUFPLFEsQ0FBVSxjLENBQWdCLE0sQ0FBUSxDQUMzRSxHQUFNLGdCQUFpQixNQUFRLFFBQS9CLENBQ0EsR0FBTSxhQUFjLEVBQUksS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFZLEtBQUssS0FBTCxDQUFXLENBQVgsQ0FBZSxPQUFPLENBQWxDLENBQXhCLENBQ0EsR0FBTSxTQUFXLEtBQUssS0FBTCxDQUFXLENBQVgsQ0FBZSxXQUFoQixDQUErQixPQUFPLENBQXRELENBQ0EsR0FBTSxTQUFXLEtBQUssS0FBTCxDQUFXLENBQVgsQ0FBZSxXQUFoQixDQUErQixPQUFPLENBQXRELENBQ0EsR0FBTSxZQUFhLENBQ2pCLENBQUMsTUFBTSxDQUFOLENBQVUsT0FBWCxFQUFzQixjQUF2QixDQUF5QyxlQUFlLENBRHRDLENBRWpCLENBQUMsTUFBTSxDQUFOLENBQVUsT0FBWCxFQUFzQixjQUF2QixDQUF5QyxlQUFlLENBRnRDLENBQW5CLENBSUEsTUFBTyxJQUFJLGVBQUosQ0FDTixJQURNLENBRU4sTUFBUSxXQUZGLENBR04sVUFITSxDQUlOLENBQUUsQ0FBRixDQUFLLENBQUwsQ0FBUSxDQUFSLENBQVcsQ0FBWCxDQUpNLENBQVAsQ0FLQSxDQUVEOzs7Ozs7Ozs7O29FQVcyQixPLENBQVMsSyxDQUFPLEssQ0FBTyxRLENBQVUsYyxDQUFnQixDQUMzRSxHQUFNLE1BQU8sUUFBUSxJQUFyQixDQUEyQjtBQUMzQixHQUFNLFFBQVMsUUFBUSxNQUF2QixDQUErQjtBQUMvQixHQUFNLFVBQVcsUUFBUSxRQUF6QixDQUFtQztBQUNuQyxHQUFNLGdCQUFpQixNQUFRLFFBQS9CLENBQ0EsR0FBTSxZQUFhLENBQUUsQ0FBRixDQUFLLENBQUwsQ0FBbkIsQ0FDQSxHQUFJLFdBQWEsUUFBUSxNQUF6QixDQUFpQyxDQUNoQztBQUNBO0FBQ0EsV0FBVyxDQUFYLEVBQWlCLE1BQU0sQ0FBTixDQUFVLGNBQVgsQ0FBNkIsZUFBZSxDQUE1RCxDQUNBLFdBQVcsQ0FBWCxFQUFpQixNQUFNLENBQU4sQ0FBVSxjQUFYLENBQTZCLGVBQWUsQ0FBNUQsQ0FDQSxDQUxELElBS08sQ0FDTjtBQUNBO0FBQ0EsR0FBTSxhQUFjLEVBQUksS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFZLFNBQVMsQ0FBVCxDQUFhLE9BQU8sQ0FBaEMsQ0FBeEIsQ0FDQSxHQUFNLFNBQVcsU0FBUyxDQUFULENBQWEsV0FBZCxDQUE2QixPQUFPLENBQXBELENBQ0EsR0FBTSxTQUFXLFNBQVMsQ0FBVCxDQUFhLFdBQWQsQ0FBNkIsT0FBTyxDQUFwRCxDQUNBLFdBQVcsQ0FBWCxFQUFpQixDQUFDLE1BQU0sQ0FBTixDQUFVLE9BQVgsRUFBc0IsY0FBdkIsQ0FBeUMsZUFBZSxDQUF4RSxDQUNBLFdBQVcsQ0FBWCxFQUFpQixDQUFDLE1BQU0sQ0FBTixDQUFVLE9BQVgsRUFBc0IsY0FBdkIsQ0FBeUMsZUFBZSxDQUF4RSxDQUNBLE9BQVMsV0FBVCxDQUNBLENBQ0QsTUFBTyxJQUFJLGVBQUosQ0FDTixJQURNLENBRU4sS0FGTSxDQUdOLFVBSE0sQ0FJTixZQUFZLEtBQUssS0FBakIsQ0FBd0IsUUFBeEIsQ0FKTSxDQUFQLENBS0EsQ0FFRDs7Ozs7Ozs7Ozt3RUFXNkIsTyxDQUFTLEssQ0FBTyxLLENBQU8sUSxDQUFVLGMsQ0FBZ0IsQ0FDN0UsR0FBTSxNQUFPLFFBQVEsSUFBckIsQ0FBMkI7QUFDM0IsR0FBTSxRQUFTLFFBQVEsTUFBdkIsQ0FBK0I7QUFDL0IsR0FBTSxnQkFBaUIsTUFBUSxRQUEvQixDQUNBLEdBQU0sYUFBYyxFQUFJLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBWSxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQWUsT0FBTyxDQUFsQyxDQUF4QixDQUNBLEdBQU0sU0FBVyxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQWUsV0FBaEIsQ0FBK0IsT0FBTyxDQUF0RCxDQUNBLEdBQU0sU0FBVyxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQWUsV0FBaEIsQ0FBK0IsT0FBTyxDQUF0RCxDQUNBLEdBQU0sWUFBYSxDQUNqQixDQUFDLE1BQU0sQ0FBTixDQUFVLE9BQVgsRUFBc0IsY0FBdkIsQ0FBeUMsZUFBZSxDQUR0QyxDQUVqQixDQUFDLE1BQU0sQ0FBTixDQUFVLE9BQVgsRUFBc0IsY0FBdkIsQ0FBeUMsZUFBZSxDQUZ0QyxDQUFuQixDQUlBLE1BQU8sSUFBSSxlQUFKLENBQ04sSUFETSxDQUVOLE1BQVEsV0FGRixDQUdOLFVBSE0sQ0FJTixDQUFFLENBQUYsQ0FBSyxDQUFMLENBQVEsQ0FBUixDQUFXLENBQVgsQ0FKTSxDQUFQLENBS0EsQyw4QkF1QkYsT0FBTyxPQUFQLENBQWlCLGNBQWpCOzs7QUN0TkEsYSw0eUNBRUEsR0FBTSxXQUFZLFFBQVEsdUJBQVIsQ0FBbEIsQ0FDQSxHQUFNLGNBQWUsUUFBUSw2QkFBUixDQUFyQixDQUNBLEdBQU0sVUFBVyxRQUFRLGFBQVIsQ0FBakIsQ0FDQSxHQUFNLGdCQUFpQixRQUFRLGtCQUFSLENBQXZCLENBRUE7QUFFQTs7OztHQUtBLEdBQU0sWUFBYSxRQUFuQixDQUVBOzs7O0dBS0EsR0FBTSxjQUFlLFFBQXJCLENBRUE7O01BR00sYSx1REFFTDs7SUFHQSx1QkFBYyx3SkFFYixNQUFLLFVBQUwsRUFBbUIsR0FBSSxJQUFKLEVBQW5CLENBQ0EsTUFBSyxZQUFMLEVBQXFCLEdBQUksSUFBSixFQUFyQixDQUNBLE1BQUssS0FBTCxDQUFhLElBQWIsQ0FKYSxhQUtiLENBRUQ7Ozs7OztpRUFPTSxLLENBQU8sQ0FDWixHQUFJLENBQUMsS0FBTCxDQUFZLENBQ1gsS0FBTSwrQkFBTixDQUNBLENBQ0QsS0FBSyxLQUFMLENBQWEsS0FBYixDQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7Ozs4Q0FPUyxLLENBQU8sQ0FDZixHQUFJLENBQUMsS0FBTCxDQUFZLENBQ1gsS0FBTSwrQkFBTixDQUNBLENBQ0QsS0FBSyxLQUFMLENBQWEsSUFBYixDQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7Ozs7OzttRUFVaUMsb0JBQWQsUUFBYywyREFBSixFQUFJLENBQ2hDLEdBQU0sbUJBQW9CLFFBQVEsaUJBQWxDLENBQ0EsR0FBSSxDQUFDLGlCQUFMLENBQXdCLENBQ3ZCLEtBQU0saURBQU4sQ0FDQSxDQUNEO0FBQ0EsR0FBTSxTQUFVLEdBQUksYUFBSixDQUFpQixDQUNoQyxhQUFjLFFBQVEsWUFEVSxDQUFqQixDQUFoQixDQUdBO0FBQ0EsR0FBTSxPQUFRLFFBQVIsTUFBUSxPQUFTLENBQ3RCLEdBQU0sTUFBTyxNQUFNLElBQW5CLENBQ0EsR0FBTSxPQUFRLEtBQUssS0FBbkIsQ0FDQSxHQUFNLFVBQVcsT0FBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixRQUFqQyxDQUNBLEdBQU0sU0FBVSxNQUFNLENBQU4sQ0FBVSxRQUExQixDQUNBLEdBQU0sU0FBVSxNQUFNLENBQU4sQ0FBVSxRQUExQixDQUNBLEdBQU0sYUFBYyxrQkFBa0IsSUFBbEIsQ0FBd0IsT0FBeEIsQ0FBaUMsT0FBakMsQ0FBcEIsQ0FDQSxRQUFRLE1BQVIsQ0FBZSxLQUFmLENBQXNCLFdBQXRCLEVBQ0EsQ0FSRCxDQVNBLEdBQU0sU0FBVSxRQUFWLFFBQVUsT0FBUyxDQUN4QixRQUFRLE1BQVIsQ0FBZSxNQUFNLElBQU4sQ0FBVyxLQUExQixFQUNBLENBRkQsQ0FHQTtBQUNBLEtBQUssS0FBTCxDQUFXLEVBQVgsQ0FBYyxVQUFVLFFBQXhCLENBQWtDLEtBQWxDLEVBQ0EsS0FBSyxLQUFMLENBQVcsRUFBWCxDQUFjLFVBQVUsV0FBeEIsQ0FBcUMsT0FBckMsRUFDQTtBQUNBLEtBQUssVUFBTCxFQUFpQixHQUFqQixDQUFxQixPQUFyQixDQUE4QixLQUE5QixFQUNBLEtBQUssWUFBTCxFQUFtQixHQUFuQixDQUF1QixPQUF2QixDQUFnQyxPQUFoQyxFQUNBLE1BQU8sUUFBUCxDQUNBLENBRUQ7Ozs7O29FQU1vQixPLENBQVMsQ0FDNUI7QUFDQSxLQUFLLEtBQUwsQ0FBVyxjQUFYLENBQTBCLFVBQVUsUUFBcEMsQ0FBOEMsS0FBSyxVQUFMLEVBQWlCLEdBQWpCLENBQXFCLE9BQXJCLENBQTlDLEVBQ0EsS0FBSyxLQUFMLENBQVcsY0FBWCxDQUEwQixVQUFVLFdBQXBDLENBQWlELEtBQUssWUFBTCxFQUFtQixHQUFuQixDQUF1QixPQUF2QixDQUFqRCxFQUNBO0FBQ0EsS0FBSyxVQUFMLEVBQWlCLE1BQWpCLENBQXdCLE9BQXhCLEVBQ0EsS0FBSyxZQUFMLEVBQW1CLE1BQW5CLENBQTBCLE9BQTFCLEVBQ0EsQ0FFRDs7OzsyREFLaUIsQ0FDaEIsR0FBTSxNQUFPLEtBQUssS0FBTCxDQUFXLElBQXhCLENBQ0EsR0FBTSxTQUFVLEtBQUssS0FBTCxDQUFXLE9BQTNCLENBQ0EsR0FBTSxVQUFXLEtBQUssUUFBdEIsQ0FDQSxHQUFNLE1BQU8sS0FBSyxJQUFsQixDQUNBLEdBQU0sVUFBVyxLQUFLLHNCQUFMLEVBQWpCLENBQ0EsR0FBTSxRQUFTLEtBQUssZ0JBQUwsRUFBZixDQUNBLEdBQU0sYUFBYyxFQUFwQixDQUNBLElBQUssR0FBSSxHQUFFLENBQVgsQ0FBYyxFQUFFLE9BQU8sTUFBdkIsQ0FBK0IsR0FBL0IsQ0FBb0MsQ0FDbkMsR0FBTSxPQUFRLE9BQU8sQ0FBUCxDQUFkLENBQ0EsR0FBTSxRQUFTLE1BQU0sU0FBTixFQUFmLENBQ0E7QUFDQSxHQUFNLE1BQU8sUUFBUSxHQUFSLENBQVksTUFBWixDQUFiLENBQ0EsR0FBSSxJQUFKLENBQVUsQ0FDVCxHQUFNLE9BQVEsS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFZLEtBQU8sTUFBTSxDQUF6QixDQUFkLENBQ0EsR0FBTSxZQUFhLGVBQWUsUUFBZixDQUNsQixJQURrQixDQUVsQixLQUZrQixDQUdsQixLQUhrQixDQUlsQixRQUprQixDQUtsQixRQUxrQixDQUFuQixDQU1BLFlBQVksSUFBWixDQUFpQixVQUFqQixFQUNBLENBQ0QsQ0FDRCxNQUFPLFlBQVAsQ0FDQSxDQUVEOzs7OztpRUFNb0IsQ0FDbkIsR0FBTSxNQUFPLEtBQUssS0FBTCxDQUFXLElBQXhCLENBQ0EsR0FBTSxTQUFVLEtBQUssS0FBTCxDQUFXLE9BQTNCLENBQ0EsR0FBTSxVQUFXLEtBQUssUUFBdEIsQ0FDQSxHQUFNLE1BQU8sS0FBSyxJQUFsQixDQUNBLEdBQU0sVUFBVyxLQUFLLHNCQUFMLEVBQWpCLENBQ0EsR0FBTSxRQUFTLEtBQUssZ0JBQUwsRUFBZixDQUNBLEdBQU0sYUFBYyxFQUFwQixDQUNBLElBQUssR0FBSSxHQUFFLENBQVgsQ0FBYyxFQUFFLE9BQU8sTUFBdkIsQ0FBK0IsR0FBL0IsQ0FBb0MsQ0FDbkMsR0FBTSxPQUFRLE9BQU8sQ0FBUCxDQUFkLENBQ0EsR0FBTSxRQUFTLE1BQU0sU0FBTixFQUFmLENBQ0EsR0FBTSxPQUFRLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBWSxLQUFPLE1BQU0sQ0FBekIsQ0FBZCxDQUNBO0FBQ0EsR0FBTSxVQUFXLFFBQVEsZUFBUixDQUF3QixNQUF4QixDQUFqQixDQUNBLEdBQUksUUFBSixDQUFjLENBQ2IsSUFBSyxHQUFJLEdBQUUsQ0FBWCxDQUFjLEVBQUUsU0FBUyxNQUF6QixDQUFpQyxHQUFqQyxDQUFzQyxDQUNyQyxHQUFNLFNBQVUsU0FBUyxDQUFULENBQWhCLENBQ0EsR0FBTSxNQUFPLFFBQVEsSUFBckIsQ0FDQSxHQUFJLGtCQUFKLENBQ0EsR0FBSSxLQUFLLEtBQUwsQ0FBVyxDQUFYLEdBQWlCLE1BQU0sQ0FBM0IsQ0FBOEIsQ0FDN0I7QUFDQSxXQUFhLGVBQWUsUUFBZixDQUNaLElBRFksQ0FFWixLQUZZLENBR1osS0FIWSxDQUlaLFFBSlksQ0FLWixRQUxZLENBQWIsQ0FNQSxDQVJELElBUU8sSUFBSSxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQWUsTUFBTSxDQUF6QixDQUE0QixDQUNsQztBQUNBLFdBQWEsZUFBZSxtQkFBZixDQUNaLE9BRFksQ0FFWixLQUZZLENBR1osS0FIWSxDQUlaLFFBSlksQ0FLWixRQUxZLENBQWIsQ0FNQSxDQVJNLElBUUEsQ0FDTjtBQUNBLFdBQWEsZUFBZSxxQkFBZixDQUNaLE9BRFksQ0FFWixLQUZZLENBR1osS0FIWSxDQUlaLFFBSlksQ0FLWixRQUxZLENBQWIsQ0FNQSxDQUNELFlBQVksSUFBWixDQUFpQixVQUFqQixFQUNBLENBQ0QsQ0FDRCxDQUNELE1BQU8sWUFBUCxDQUNBLEMsMEJBekx5QixRLEVBNEwzQixPQUFPLE9BQVAsQ0FBaUIsWUFBakI7OztBQ3ROQSxhLDR0REFFQSxHQUFNLFdBQVksUUFBUSxrQkFBUixDQUFsQixDQUNBLEdBQU0sV0FBWSxRQUFRLHVCQUFSLENBQWxCLENBQ0EsR0FBTSxRQUFTLFFBQVEsMkJBQVIsQ0FBZixDQUNBLEdBQU0sY0FBZSxRQUFRLGtDQUFSLENBQXJCLENBQ0EsR0FBTSxhQUFjLFFBQVEsZ0NBQVIsQ0FBcEIsQ0FDQSxHQUFNLGNBQWUsUUFBUSxnQkFBUixDQUFyQixDQUVBO0FBRUE7Ozs7R0FLQSxHQUFNLFVBQVcsUUFBakIsQ0FFQTs7OztHQUtBLEdBQU0sYUFBYyxRQUFwQixDQUVBO0FBRUEsR0FBTSx1QkFBd0IsUUFBeEIsc0JBQXdCLENBQVMsS0FBVCxDQUFnQixJQUFoQixDQUFzQixDQUNuRCxNQUFNLEdBQU4sQ0FBVSxLQUFLLEtBQUwsQ0FBVyxJQUFyQixDQUEyQixLQUFLLElBQWhDLEVBQ0EsQ0FGRCxDQUlBLEdBQU0sNEJBQTZCLFFBQTdCLDJCQUE2QixDQUFTLEtBQVQsQ0FBZ0IsSUFBaEIsQ0FBc0IsQ0FDeEQsTUFBTSxNQUFOLENBQWEsS0FBSyxLQUFMLENBQVcsSUFBeEIsRUFDQSxDQUZELENBSUEsR0FBTSxzQkFBdUIsUUFBdkIscUJBQXVCLENBQVMsS0FBVCxDQUFnQixJQUFoQixDQUFzQixDQUNsRCxNQUFNLEdBQU4sQ0FDQyxLQUFLLEtBQUwsQ0FBVyxJQURaLENBRUMsS0FBSyxJQUZOLENBR0MsS0FBSyxJQUFMLENBQVUsTUFBVixDQUFtQixNQUFNLE1BSDFCLEVBSUEsQ0FMRCxDQU9BLEdBQU0sMkJBQTRCLFFBQTVCLDBCQUE0QixDQUFTLEtBQVQsQ0FBZ0IsSUFBaEIsQ0FBc0IsQ0FDdkQsTUFBTSxNQUFOLENBQWEsS0FBSyxLQUFMLENBQVcsSUFBeEIsRUFDQSxDQUZELENBSUE7O01BR00sa0Isb0VBRUw7O0lBR0EsNEJBQWMsdUtBRWIsTUFBSyxFQUFMLENBQVUsSUFBVixDQUNBLE1BQUssUUFBTCxFQUFpQixHQUFJLElBQUosRUFBakIsQ0FDQSxNQUFLLFdBQUwsRUFBb0IsR0FBSSxJQUFKLEVBQXBCLENBSmEsYUFLYixDQUVEOzs7Ozs7c0VBT00sSyxDQUFPLENBQ1osdUhBQVksS0FBWixFQUNBLEtBQUssRUFBTCxDQUFVLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsbUJBQWhCLEVBQVYsQ0FDQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7Ozs7OENBT1MsSyxDQUFPLENBQ2YsS0FBSyxFQUFMLENBQVUsSUFBVixDQUNBLDBIQUFlLEtBQWYsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7OzJEQUtpQixDQUNoQixNQUFPLE1BQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsY0FBaEIsRUFBUCxDQUNBLENBRUQ7Ozs7Ozs7Ozs7c0RBV2EsTSxDQUFRLENBQ3BCLE1BQU8sSUFBSSxPQUFKLENBQVcsS0FBSyxFQUFoQixDQUFvQixNQUFwQixDQUFQLENBQ0EsQ0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7bUVBa0JpQyxJQUFkLFFBQWMsMkRBQUosRUFBSSxDQUNoQztBQUNBLEdBQU0sT0FBUSxHQUFJLGFBQUosQ0FDYixLQUFLLEVBRFEsQ0FFYixDQUNDO0FBQ0EsT0FBUSxRQUFRLE1BRmpCLENBR0MsS0FBTSxRQUFRLElBSGYsQ0FJQyxPQUFRLFFBQVEsTUFKakIsQ0FLQyxRQUFTLFFBQVEsT0FMbEIsQ0FNQyxpQkFBa0IsUUFBUSxnQkFOM0IsQ0FGYSxDQVViLENBQ0M7QUFDQSxVQUFXLEtBQUssS0FBTCxDQUFXLE9BQVgsQ0FBbUIsV0FBbkIsRUFGWixDQUdDLFVBQVcsUUFBUSxTQUhwQixDQVZhLENBQWQsQ0FlQTtBQUNBLEdBQU0sT0FBUSxVQUFVLFFBQVEsS0FBbEIsQ0FBeUIscUJBQXpCLENBQWQsQ0FDQSxHQUFNLFVBQVcsVUFBVSxRQUFRLFFBQWxCLENBQTRCLDBCQUE1QixDQUFqQixDQUNBLEdBQU0sS0FBTSxRQUFOLElBQU0sT0FBUyxDQUNwQixNQUFNLEtBQU4sQ0FBYSxNQUFNLElBQW5CLEVBQ0EsQ0FGRCxDQUdBLEdBQU0sUUFBUyxRQUFULE9BQVMsT0FBUyxDQUN2QixTQUFTLEtBQVQsQ0FBZ0IsTUFBTSxJQUF0QixFQUNBLENBRkQsQ0FHQTtBQUNBLEtBQUssS0FBTCxDQUFXLEVBQVgsQ0FBYyxVQUFVLFFBQXhCLENBQWtDLEdBQWxDLEVBQ0EsS0FBSyxLQUFMLENBQVcsRUFBWCxDQUFjLFVBQVUsV0FBeEIsQ0FBcUMsTUFBckMsRUFDQTtBQUNBLEtBQUssUUFBTCxFQUFlLEdBQWYsQ0FBbUIsS0FBbkIsQ0FBMEIsR0FBMUIsRUFDQSxLQUFLLFdBQUwsRUFBa0IsR0FBbEIsQ0FBc0IsS0FBdEIsQ0FBNkIsTUFBN0IsRUFDQSxNQUFPLE1BQVAsQ0FDQSxDQUVEOzs7OztvRUFNb0IsSyxDQUFPLENBQzFCO0FBQ0EsS0FBSyxLQUFMLENBQVcsY0FBWCxDQUEwQixVQUFVLFFBQXBDLENBQThDLEtBQUssUUFBTCxFQUFlLEdBQWYsQ0FBbUIsS0FBbkIsQ0FBOUMsRUFDQSxLQUFLLEtBQUwsQ0FBVyxjQUFYLENBQTBCLFVBQVUsV0FBcEMsQ0FBaUQsS0FBSyxXQUFMLEVBQWtCLEdBQWxCLENBQXNCLEtBQXRCLENBQWpELEVBQ0E7QUFDQSxLQUFLLFFBQUwsRUFBZSxNQUFmLENBQXNCLEtBQXRCLEVBQ0EsS0FBSyxXQUFMLEVBQWtCLE1BQWxCLENBQXlCLEtBQXpCLEVBQ0EsQ0FFRDs7Ozs7Ozs7Ozs7O2lFQWFnQyxJQUFkLFFBQWMsMkRBQUosRUFBSSxDQUMvQjtBQUNBLEdBQU0sT0FBUSxHQUFJLFlBQUosQ0FDYixLQUFLLEVBRFEsQ0FFYixRQUFRLGlCQUZLLENBR2IsQ0FDQztBQUNBLFVBQVcsS0FBSyxLQUFMLENBQVcsT0FBWCxDQUFtQixXQUFuQixFQUZaLENBR0MsVUFBVyxRQUFRLFNBSHBCLENBSGEsQ0FBZCxDQVFBO0FBQ0EsR0FBTSxPQUFRLFVBQVUsUUFBUSxLQUFsQixDQUF5QixvQkFBekIsQ0FBZCxDQUNBLEdBQU0sVUFBVyxVQUFVLFFBQVEsUUFBbEIsQ0FBNEIseUJBQTVCLENBQWpCLENBQ0EsR0FBTSxLQUFNLFFBQU4sSUFBTSxPQUFTLENBQ3BCLE1BQU0sS0FBTixDQUFhLE1BQU0sSUFBbkIsRUFDQSxDQUZELENBR0EsR0FBTSxRQUFTLFFBQVQsT0FBUyxPQUFTLENBQ3ZCLFNBQVMsS0FBVCxDQUFnQixNQUFNLElBQXRCLEVBQ0EsQ0FGRCxDQUdBO0FBQ0EsS0FBSyxLQUFMLENBQVcsRUFBWCxDQUFjLFVBQVUsUUFBeEIsQ0FBa0MsR0FBbEMsRUFDQSxLQUFLLEtBQUwsQ0FBVyxFQUFYLENBQWMsVUFBVSxXQUF4QixDQUFxQyxNQUFyQyxFQUNBO0FBQ0EsS0FBSyxRQUFMLEVBQWUsR0FBZixDQUFtQixLQUFuQixDQUEwQixHQUExQixFQUNBLEtBQUssV0FBTCxFQUFrQixHQUFsQixDQUFzQixLQUF0QixDQUE2QixNQUE3QixFQUNBLE1BQU8sTUFBUCxDQUNBLENBRUQ7Ozs7O2tFQU1tQixLLENBQU8sQ0FDekI7QUFDQSxLQUFLLEtBQUwsQ0FBVyxjQUFYLENBQTBCLFVBQVUsUUFBcEMsQ0FBOEMsS0FBSyxRQUFMLEVBQWUsR0FBZixDQUFtQixLQUFuQixDQUE5QyxFQUNBLEtBQUssS0FBTCxDQUFXLGNBQVgsQ0FBMEIsVUFBVSxXQUFwQyxDQUFpRCxLQUFLLFdBQUwsRUFBa0IsR0FBbEIsQ0FBc0IsS0FBdEIsQ0FBakQsRUFDQTtBQUNBLEtBQUssUUFBTCxFQUFlLE1BQWYsQ0FBc0IsS0FBdEIsRUFDQSxLQUFLLFdBQUwsRUFBa0IsTUFBbEIsQ0FBeUIsS0FBekIsRUFDQSxDLCtCQXhMOEIsWSxFQTJMaEMsT0FBTyxPQUFQLENBQWlCLGlCQUFqQjs7O0FDNU9BLGEsNHREQUVBLEdBQU0sY0FBZSxRQUFRLG9DQUFSLENBQXJCLENBQ0EsR0FBTSxtQkFBb0IsUUFBUSxzQkFBUixDQUExQixDQUVBO0FBRUE7Ozs7R0FLQSxHQUFNLGFBQWMsQ0FDbkIsa21CQURtQixDQW1CbkIsa1VBbkJtQixDQUFwQixDQWdDQSxHQUFNLFlBQWEsUUFBYixXQUFhLENBQVMsRUFBVCxDQUFhLEdBQWIsQ0FBa0IsR0FBbEIsQ0FBdUIsQ0FDekMsR0FBTSxVQUFXLEdBQUksYUFBSixDQUFpQixFQUFqQixDQUFqQixDQUNBO0FBQ0EsU0FBUyxDQUFULEVBQWMsR0FBZCxDQUNBLFNBQVMsQ0FBVCxFQUFjLEdBQWQsQ0FDQSxTQUFTLENBQVQsRUFBYyxHQUFkLENBQ0EsU0FBUyxDQUFULEVBQWMsR0FBZCxDQUNBLFNBQVMsQ0FBVCxFQUFjLEdBQWQsQ0FDQSxTQUFTLENBQVQsRUFBYyxHQUFkLENBQ0EsU0FBUyxDQUFULEVBQWMsR0FBZCxDQUNBLFNBQVMsQ0FBVCxFQUFjLEdBQWQsQ0FDQSxTQUFTLENBQVQsRUFBYyxHQUFkLENBQ0EsU0FBUyxDQUFULEVBQWMsR0FBZCxDQUNBLFNBQVMsRUFBVCxFQUFlLEdBQWYsQ0FDQSxTQUFTLEVBQVQsRUFBZSxHQUFmLENBQ0E7QUFDQSxTQUFTLEVBQVQsRUFBZSxDQUFmLENBQ0EsU0FBUyxFQUFULEVBQWUsQ0FBZixDQUNBLFNBQVMsRUFBVCxFQUFlLENBQWYsQ0FDQSxTQUFTLEVBQVQsRUFBZSxDQUFmLENBQ0EsU0FBUyxFQUFULEVBQWUsQ0FBZixDQUNBLFNBQVMsRUFBVCxFQUFlLENBQWYsQ0FDQSxTQUFTLEVBQVQsRUFBZSxDQUFmLENBQ0EsU0FBUyxFQUFULEVBQWUsQ0FBZixDQUNBLFNBQVMsRUFBVCxFQUFlLENBQWYsQ0FDQSxTQUFTLEVBQVQsRUFBZSxDQUFmLENBQ0EsU0FBUyxFQUFULEVBQWUsQ0FBZixDQUNBLFNBQVMsRUFBVCxFQUFlLENBQWYsQ0FDQTtBQUNBLE1BQU8sSUFBSSxhQUFKLENBQ04sRUFETSxDQUVOLFFBRk0sQ0FHTixDQUNDLEVBQUcsQ0FDRixLQUFNLENBREosQ0FFRixLQUFNLE9BRkosQ0FHRixXQUFZLENBSFYsQ0FESixDQU1DLEVBQUcsQ0FDRixLQUFNLENBREosQ0FFRixLQUFNLE9BRkosQ0FHRixXQUFZLEVBQUksQ0FBSixDQUFRLENBSGxCLENBTkosQ0FITSxDQWVOLENBQ0MsTUFBTyxDQURSLENBZk0sQ0FBUCxDQWtCQSxDQS9DRCxDQWlEQTs7TUFHTSxrQiw4RUFFTDs7SUFHQSw0QkFBYyx1S0FFYixNQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsTUFBSyxNQUFMLENBQWMsSUFBZCxDQUNBLE1BQUssS0FBTCxDQUFhLElBQWIsQ0FKYSxhQUtiLENBRUQ7Ozs7OztzRUFPTSxLLENBQU8sQ0FDWix1SEFBWSxLQUFaLEVBQ0EsS0FBSyxJQUFMLENBQVksV0FBVyxLQUFLLEVBQWhCLENBQW9CLENBQXBCLENBQXVCLE1BQU0sSUFBTixDQUFXLFFBQWxDLENBQVosQ0FDQSxLQUFLLE1BQUwsQ0FBYyxLQUFLLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBZCxDQUNBLEtBQUssS0FBTCxDQUFhLEtBQUssa0JBQUwsQ0FBd0IsQ0FDcEMsVUFBVyxNQUFNLElBQU4sQ0FBVyxRQURjLENBQXhCLENBQWIsQ0FHQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7Ozs7OENBT1MsSyxDQUFPLENBQ2YsS0FBSyxtQkFBTCxDQUF5QixLQUFLLEtBQTlCLEVBQ0EsS0FBSyxLQUFMLENBQWEsSUFBYixDQUNBLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxLQUFLLE1BQUwsQ0FBYyxJQUFkLENBQ0EsMEhBQWUsS0FBZixFQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7dUNBS08sQ0FDTixHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBLEdBQU0sUUFBUyxLQUFLLE1BQXBCLENBQ0EsR0FBTSxPQUFRLEtBQUssS0FBbkIsQ0FDQSxHQUFNLE1BQU8sS0FBSyxJQUFsQixDQUNBLEdBQU0sYUFBYyxLQUFLLGlCQUFMLEVBQXBCLENBQ0EsR0FBTSxNQUFPLEtBQUssY0FBTCxFQUFiLENBRUE7QUFDQSxPQUFPLEdBQVAsR0FDQTtBQUNBLE9BQU8sVUFBUCxDQUFrQixtQkFBbEIsQ0FBdUMsSUFBdkMsRUFDQSxPQUFPLFVBQVAsQ0FBa0IsaUJBQWxCLENBQXFDLENBQXJDLEVBQ0EsT0FBTyxVQUFQLENBQWtCLFVBQWxCLENBQThCLEtBQUssS0FBTCxDQUFXLE9BQXpDLEVBRUE7QUFDQSxHQUFHLE1BQUgsQ0FBVSxHQUFHLEtBQWIsRUFDQSxHQUFHLFNBQUgsQ0FBYSxHQUFHLFNBQWhCLENBQTJCLEdBQUcsbUJBQTlCLEVBRUE7QUFDQSxLQUFLLElBQUwsR0FFQTtBQUNBLElBQUssR0FBSSxHQUFFLENBQVgsQ0FBYyxFQUFFLFlBQVksTUFBNUIsQ0FBb0MsR0FBcEMsQ0FBeUMsQ0FDeEMsR0FBTSxZQUFhLFlBQVksQ0FBWixDQUFuQixDQUNBLE1BQU0sSUFBTixDQUFXLFdBQVcsSUFBdEIsQ0FBNEIsQ0FBNUIsRUFDQTtBQUNBLE9BQU8sVUFBUCxDQUFrQixxQkFBbEIsQ0FBeUMsV0FBVyxRQUFwRCxFQUNBLE9BQU8sVUFBUCxDQUFrQixRQUFsQixDQUE0QixXQUFXLEtBQXZDLEVBQ0EsT0FBTyxVQUFQLENBQWtCLGFBQWxCLENBQWlDLFdBQVcsVUFBNUMsRUFDQTtBQUNBLEtBQUssSUFBTCxHQUNBO0FBQ0EsQ0FFRDtBQUNBLEtBQUssTUFBTCxHQUNBLE1BQU8sS0FBUCxDQUNBLEMsK0JBeEY4QixpQixFQTJGaEMsT0FBTyxPQUFQLENBQWlCLGlCQUFqQjs7O0FDM0xBLGEsNHREQUVBLEdBQU0sV0FBWSxRQUFRLGtCQUFSLENBQWxCLENBQ0EsR0FBTSxjQUFlLFFBQVEsb0NBQVIsQ0FBckIsQ0FDQSxHQUFNLG1CQUFvQixRQUFRLHNCQUFSLENBQTFCLENBRUE7QUFFQTs7OztHQUtBLEdBQU0sWUFBYSxJQUFNLEdBQXpCLENBRUE7Ozs7R0FLQSxHQUFNLG1CQUFvQixHQUExQixDQUVBOzs7O0dBS0EsR0FBTSxtQkFBb0IsR0FBMUIsQ0FFQTs7OztHQUtBLEdBQU0saUJBQWtCLENBQXhCLENBRUE7Ozs7R0FLQSxHQUFNLGFBQWMsQ0FDbkIsa1pBRG1CLENBZW5CLDJIQWZtQixDQUFwQixDQXlCQTtBQUVBLEdBQU0sWUFBYSxRQUFiLFdBQWEsQ0FBUyxFQUFULENBQWEsQ0FDL0IsR0FBTSxPQUFTLEVBQUksS0FBSyxFQUFWLENBQWdCLGVBQTlCLENBQ0EsR0FBTSxRQUFTLE1BQVEsR0FBdkIsQ0FDQSxHQUFNLFFBQVMsTUFBUSxHQUF2QixDQUNBLEdBQU0sV0FBWSxHQUFJLGFBQUosQ0FBa0IsZ0JBQWtCLENBQW5CLENBQXdCLENBQXhCLENBQTRCLENBQTdDLENBQWxCLENBQ0EsVUFBVSxDQUFWLEVBQWUsQ0FBZixDQUNBLFVBQVUsQ0FBVixFQUFlLENBQWYsQ0FDQSxJQUFLLEdBQUksR0FBRSxDQUFYLENBQWMsRUFBRSxlQUFoQixDQUFpQyxHQUFqQyxDQUFzQyxDQUNyQyxHQUFNLE9BQVEsRUFBSSxLQUFsQixDQUNBLEdBQUksSUFBSyxLQUFLLEdBQUwsQ0FBUyxNQUFRLE1BQWpCLEVBQTJCLGlCQUFwQyxDQUNBLEdBQUksSUFBSyxLQUFLLEdBQUwsQ0FBUyxNQUFRLE1BQWpCLEVBQTJCLGlCQUFwQyxDQUNBLFVBQVUsRUFBRSxDQUFGLENBQUksQ0FBZCxFQUFtQixFQUFuQixDQUNBLFVBQVUsRUFBRSxDQUFGLENBQUksQ0FBSixDQUFNLENBQWhCLEVBQXFCLEVBQXJCLENBQ0EsR0FBSyxLQUFLLEdBQUwsQ0FBUyxNQUFRLE1BQVIsQ0FBaUIsTUFBMUIsRUFBb0MsaUJBQXpDLENBQ0EsR0FBSyxLQUFLLEdBQUwsQ0FBUyxNQUFRLE1BQVIsQ0FBaUIsTUFBMUIsRUFBb0MsaUJBQXpDLENBQ0EsVUFBVSxFQUFFLENBQUYsQ0FBSSxDQUFKLENBQU0sQ0FBaEIsRUFBcUIsRUFBckIsQ0FDQSxVQUFVLEVBQUUsQ0FBRixDQUFJLENBQUosQ0FBTSxDQUFoQixFQUFxQixFQUFyQixDQUNBLENBQ0QsVUFBVSxVQUFVLE1BQVYsQ0FBaUIsQ0FBM0IsRUFBZ0MsVUFBVSxDQUFWLENBQWhDLENBQ0EsVUFBVSxVQUFVLE1BQVYsQ0FBaUIsQ0FBM0IsRUFBZ0MsVUFBVSxDQUFWLENBQWhDLENBQ0EsTUFBTyxJQUFJLGFBQUosQ0FDTixFQURNLENBRU4sU0FGTSxDQUdOLENBQ0MsRUFBRyxDQUNGLEtBQU0sQ0FESixDQUVGLEtBQU0sT0FGSixDQURKLENBSE0sQ0FTTixDQUNDLEtBQU0sY0FEUCxDQUVDLE1BQU8sVUFBVSxNQUFWLENBQW1CLENBRjNCLENBVE0sQ0FBUCxDQWFBLENBakNELENBbUNBOztNQUdNLHNCLGtGQUVMOzs7OztJQU1BLGdDQUEwQixJQUFkLFFBQWMsMkRBQUosRUFBSSxtTEFFekIsTUFBSyxLQUFMLENBQWEsVUFBVSxRQUFRLEtBQWxCLENBQXlCLENBQUUsR0FBRixDQUFPLEdBQVAsQ0FBWSxHQUFaLENBQWlCLEdBQWpCLENBQXpCLENBQWIsQ0FDQSxNQUFLLEtBQUwsQ0FBYSxJQUFiLENBQ0EsTUFBSyxNQUFMLENBQWMsSUFBZCxDQUNBLE1BQUssS0FBTCxDQUFhLElBQWIsQ0FMeUIsYUFNekIsQ0FFRDs7Ozs7OzBFQU9NLEssQ0FBTyxDQUNaLCtIQUFZLEtBQVosRUFDQSxLQUFLLEtBQUwsQ0FBYSxXQUFXLEtBQUssRUFBaEIsQ0FBYixDQUNBLEtBQUssTUFBTCxDQUFjLEtBQUssWUFBTCxDQUFrQixXQUFsQixDQUFkLENBQ0EsS0FBSyxLQUFMLENBQWEsS0FBSyxpQkFBTCxDQUF1QixDQUNuQyxVQUFXLFVBRHdCLENBRW5DLGtCQUFtQixDQUNsQjtBQUNBLEVBQUcsQ0FDRixLQUFNLENBREosQ0FFRixLQUFNLE9BRkosQ0FGZSxDQU1sQjtBQUNBLEVBQUcsQ0FDRixLQUFNLENBREosQ0FFRixLQUFNLE9BRkosQ0FQZSxDQUZnQixDQUF2QixDQUFiLENBZUEsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozs7OzhDQU9TLEssQ0FBTyxDQUNmLEtBQUssa0JBQUwsQ0FBd0IsS0FBSyxLQUE3QixFQUNBLEtBQUssS0FBTCxDQUFhLElBQWIsQ0FDQSxLQUFLLEtBQUwsQ0FBYSxJQUFiLENBQ0EsS0FBSyxNQUFMLENBQWMsSUFBZCxDQUNBLGtJQUFlLEtBQWYsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7O3VDQUtPLENBQ04sR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFNLFFBQVMsS0FBSyxNQUFwQixDQUNBLEdBQU0sT0FBUSxLQUFLLEtBQW5CLENBQ0EsR0FBTSxPQUFRLEtBQUssS0FBbkIsQ0FDQSxHQUFNLGFBQWMsS0FBSyxjQUFMLEVBQXBCLENBQ0EsR0FBTSxNQUFPLEtBQUssY0FBTCxFQUFiLENBRUE7QUFDQSxHQUFHLE1BQUgsQ0FBVSxHQUFHLEtBQWIsRUFDQSxHQUFHLFNBQUgsQ0FBYSxHQUFHLFNBQWhCLENBQTJCLEdBQUcsbUJBQTlCLEVBRUE7QUFDQSxPQUFPLEdBQVAsR0FFQTtBQUNBLE9BQU8sVUFBUCxDQUFrQixtQkFBbEIsQ0FBdUMsSUFBdkMsRUFDQSxPQUFPLFVBQVAsQ0FBa0IsUUFBbEIsQ0FBNEIsS0FBSyxLQUFqQyxFQUVBO0FBQ0EsTUFBTSxJQUFOLEdBRUE7QUFDQSxNQUFNLGFBQU4sR0FFQTtBQUNBLElBQUssR0FBSSxHQUFFLENBQVgsQ0FBYyxFQUFFLFlBQVksTUFBNUIsQ0FBb0MsR0FBcEMsQ0FBeUMsQ0FDeEMsR0FBTSxZQUFhLFlBQVksQ0FBWixDQUFuQixDQUNBO0FBQ0EsT0FBTyxVQUFQLENBQWtCLFFBQWxCLENBQTRCLFdBQVcsS0FBdkMsRUFDQSxPQUFPLFVBQVAsQ0FBa0IsYUFBbEIsQ0FBaUMsV0FBVyxVQUE1QyxFQUNBO0FBQ0EsTUFBTSxhQUFOLENBQW9CLFdBQVcsSUFBL0IsQ0FBcUMsTUFBTSxJQUEzQyxDQUFpRCxNQUFNLEtBQXZELEVBQ0EsQ0FFRDtBQUNBLE1BQU0sZUFBTixHQUVBO0FBQ0EsTUFBTSxNQUFOLEdBRUEsTUFBTyxLQUFQLENBQ0EsQyxtQ0E1R2tDLGlCLEVBK0dwQyxPQUFPLE9BQVAsQ0FBaUIscUJBQWpCOzs7QUN6TkEsYSw0dERBRUEsR0FBTSxXQUFZLFFBQVEsa0JBQVIsQ0FBbEIsQ0FDQSxHQUFNLGtCQUFtQixRQUFRLG9DQUFSLENBQXpCLENBQ0EsR0FBTSxjQUFlLFFBQVEsb0NBQVIsQ0FBckIsQ0FDQSxHQUFNLG1CQUFvQixRQUFRLHNCQUFSLENBQTFCLENBRUE7QUFFQTs7OztHQUtBLEdBQU0sWUFBYSxJQUFNLEdBQXpCLENBRUE7Ozs7R0FLQSxHQUFNLDJCQUE0QixDQUFsQyxDQUVBOzs7O0dBS0EsR0FBTSx3QkFBeUIsQ0FBL0IsQ0FFQTs7OztHQUtBLEdBQU0sZUFBZ0IsRUFBdEIsQ0FFQTs7OztHQUtBLEdBQU0sYUFBYyxDQUNuQiwrZUFEbUIsQ0FpQm5CLDJsQkFqQm1CLENBQXBCLENBeUNBO0FBRUEsR0FBTSxhQUFjLFFBQWQsWUFBYyxDQUFTLEVBQVQsQ0FBYSxDQUNoQyxHQUFNLFVBQVcsR0FBSSxhQUFKLENBQWlCLENBQWpCLENBQWpCLENBQ0EsU0FBUyxDQUFULEVBQWMsR0FBZCxDQUNBLFNBQVMsQ0FBVCxFQUFjLEdBQWQsQ0FDQTtBQUNBLE1BQU8sSUFBSSxhQUFKLENBQ04sRUFETSxDQUVOLFFBRk0sQ0FHTixDQUNDLEVBQUcsQ0FDRixLQUFNLENBREosQ0FFRixLQUFNLE9BRkosQ0FESixDQUhNLENBU04sQ0FDQyxLQUFNLFFBRFAsQ0FFQyxNQUFPLENBRlIsQ0FUTSxDQUFQLENBYUEsQ0FsQkQsQ0FvQkEsR0FBTSxtQkFBb0IsUUFBcEIsa0JBQW9CLENBQVMsSUFBVCxDQUFlLE9BQWYsQ0FBd0IsT0FBeEIsQ0FBaUMsQ0FDMUQsR0FBTSxNQUFPLEtBQUssSUFBbEIsQ0FDQSxHQUFNLGFBQWMsR0FBSSxNQUFKLENBQVUsS0FBSyxNQUFMLENBQWMsQ0FBeEIsQ0FBcEIsQ0FDQSxJQUFLLEdBQUksR0FBRSxDQUFYLENBQWMsRUFBRSxLQUFLLE1BQXJCLENBQTZCLEdBQUcsQ0FBaEMsQ0FBbUMsQ0FDbEM7QUFDQSxZQUFZLEVBQUUsQ0FBZCxFQUFtQixHQUFJLGlCQUFKLENBQ2xCLEtBQUssQ0FBTCxDQURrQixDQUNUO0FBQ1QsS0FBSyxFQUFFLENBQVAsQ0FGa0IsQ0FFUDtBQUNYLEtBQUssRUFBRSxDQUFQLENBSGtCLENBR1A7QUFDWCxPQUprQixDQUtsQixPQUxrQixDQU1sQixJQU5rQixDQUFuQixDQU9BLENBQ0QsTUFBTyxZQUFQLENBQ0EsQ0FkRCxDQWdCQSxHQUFNLGFBQWMsUUFBZCxZQUFjLENBQVMsS0FBVCxDQUFnQixNQUFoQixDQUF3QixXQUF4QixDQUFxQyxLQUFyQyxDQUE0QyxDQUMvRDtBQUNBLE9BQU8sVUFBUCxDQUFrQixRQUFsQixDQUE0QixLQUE1QixFQUNBLE9BQU8sVUFBUCxDQUFrQixlQUFsQixDQUFtQyxDQUFuQyxFQUVBO0FBQ0EsTUFBTSxJQUFOLEdBRUE7QUFDQSxJQUFLLEdBQUksR0FBRSxDQUFYLENBQWMsRUFBRSxZQUFZLE1BQTVCLENBQW9DLEdBQXBDLENBQXlDLENBQ3hDLEdBQU0sWUFBYSxZQUFZLENBQVosQ0FBbkIsQ0FDQTtBQUNBLE9BQU8sVUFBUCxDQUFrQixRQUFsQixDQUE0QixXQUFXLEtBQXZDLEVBQ0EsT0FBTyxVQUFQLENBQWtCLGFBQWxCLENBQWlDLFdBQVcsVUFBNUMsRUFDQTtBQUNBLE1BQU0sSUFBTixDQUFXLFdBQVcsSUFBdEIsQ0FBNEIsUUFBNUIsRUFDQSxDQUVEO0FBQ0EsTUFBTSxNQUFOLEdBQ0EsQ0FwQkQsQ0FzQkEsR0FBTSxhQUFjLFFBQWQsWUFBYyxDQUFTLEtBQVQsQ0FBZ0IsTUFBaEIsQ0FBd0IsSUFBeEIsQ0FBOEIsTUFBOUIsQ0FBc0MsS0FBdEMsQ0FBNkMsTUFBN0MsQ0FBcUQsQ0FDeEU7QUFDQSxHQUFNLE9BQVEsT0FBTyxJQUFQLENBQVksS0FBMUIsQ0FDQSxHQUFNLE9BQVEsS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFZLEtBQUssSUFBTCxDQUFZLE1BQU0sQ0FBOUIsQ0FBZCxDQUNBLEdBQU0sVUFBVyxLQUFLLHNCQUFMLEVBQWpCLENBQ0EsR0FBTSxZQUFhLENBQ2pCLENBQUUsTUFBTSxDQUFOLENBQVUsS0FBSyxRQUFoQixDQUE0QixPQUFPLENBQXBDLEVBQXlDLEtBQTFDLENBQW1ELFNBQVMsQ0FEMUMsQ0FFakIsQ0FBRSxNQUFNLENBQU4sQ0FBVSxLQUFLLFFBQWhCLENBQTRCLE9BQU8sQ0FBcEMsRUFBeUMsS0FBMUMsQ0FBbUQsU0FBUyxDQUYxQyxDQUFuQixDQUlBO0FBQ0EsT0FBTyxVQUFQLENBQWtCLGFBQWxCLENBQWlDLFVBQWpDLEVBQ0EsT0FBTyxVQUFQLENBQWtCLFFBQWxCLENBQTRCLEtBQTVCLEVBQ0EsT0FBTyxVQUFQLENBQWtCLFFBQWxCLENBQTRCLEtBQTVCLEVBQ0EsT0FBTyxVQUFQLENBQWtCLGVBQWxCLENBQW1DLE9BQVMsT0FBTyxNQUFuRCxFQUNBO0FBQ0EsTUFBTSxJQUFOLEdBQ0E7QUFDQSxNQUFNLElBQU4sR0FDQTtBQUNBLE1BQU0sTUFBTixHQUNBLENBcEJELENBc0JBOztNQUdNLHdCLG9GQUVMOzs7OztJQU1BLGtDQUEwQixJQUFkLFFBQWMsMkRBQUosRUFBSSx5TEFFekIsTUFBSyxLQUFMLENBQWEsVUFBVSxRQUFRLEtBQWxCLENBQXlCLENBQUUsR0FBRixDQUFPLEdBQVAsQ0FBWSxHQUFaLENBQWlCLEdBQWpCLENBQXpCLENBQWIsQ0FDQSxNQUFLLE1BQUwsQ0FBYyxJQUFkLENBQ0EsTUFBSyxLQUFMLENBQWEsSUFBYixDQUNBLE1BQUssSUFBTCxDQUFZLElBQVosQ0FDQSxNQUFLLEtBQUwsQ0FBYSxJQUFiLENBQ0EsTUFBSyxHQUFMLENBQVcsSUFBWCxDQVB5QixhQVF6QixDQUVEOzs7Ozs7NEVBT00sSyxDQUFPLENBQ1osbUlBQVksS0FBWixFQUNBO0FBQ0EsS0FBSyxHQUFMLENBQVcsS0FBSyxFQUFMLENBQVEsWUFBUixDQUFxQiwwQkFBckIsQ0FBWCxDQUNBLEtBQUssS0FBTCxDQUFhLFlBQVksS0FBSyxFQUFqQixDQUFiLENBQ0EsS0FBSyxNQUFMLENBQWMsS0FBSyxZQUFMLENBQWtCLFdBQWxCLENBQWQsQ0FDQSxLQUFLLElBQUwsQ0FBWSxLQUFLLGtCQUFMLENBQXdCLENBQ25DLGFBQWMsYUFEcUIsQ0FFbkMsa0JBQW1CLGlCQUZnQixDQUF4QixDQUFaLENBSUEsS0FBSyxLQUFMLENBQWEsS0FBSyxpQkFBTCxDQUF1QixDQUNuQyxVQUFXLFVBRHdCLENBRW5DLGtCQUFtQixDQUNsQjtBQUNBLEVBQUcsQ0FDRixLQUFNLENBREosQ0FFRixLQUFNLE9BRkosQ0FGZSxDQU1sQjtBQUNBLEVBQUcsQ0FDRixLQUFNLENBREosQ0FFRixLQUFNLE9BRkosQ0FQZSxDQUZnQixDQUF2QixDQUFiLENBZUEsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozs7OzhDQU9TLEssQ0FBTyxDQUNmLEtBQUssa0JBQUwsQ0FBd0IsS0FBSyxLQUE3QixFQUNBLEtBQUssbUJBQUwsQ0FBeUIsS0FBSyxJQUE5QixFQUNBLEtBQUssS0FBTCxDQUFhLElBQWIsQ0FDQSxLQUFLLE1BQUwsQ0FBYyxJQUFkLENBQ0EsS0FBSyxLQUFMLENBQWEsSUFBYixDQUNBLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxLQUFLLEdBQUwsQ0FBVyxJQUFYLENBQ0Esc0lBQWUsS0FBZixFQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7OztzQ0FPSyxHLENBQUssQ0FDVCxHQUFJLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsU0FBaEIsRUFBSixDQUFpQyxDQUNoQyxNQUFPLEtBQVAsQ0FDQSxDQUNELE1BQU8sTUFBSyxJQUFMLENBQVUsV0FBVixDQUNOLElBQUksQ0FERSxDQUVOLElBQUksQ0FGRSxDQUdOLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsSUFIVixDQUlOLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsY0FBaEIsRUFKTSxDQUFQLENBS0EsQ0FFRDs7Ozt1Q0FLTyxpQkFDTixHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBLEdBQU0sT0FBUSxLQUFLLEtBQW5CLENBQ0EsR0FBTSxNQUFPLE1BQU0sSUFBbkIsQ0FDQSxHQUFNLFlBQWEsS0FBSyxjQUFMLEVBQW5CLENBQ0EsR0FBTSxRQUFTLEtBQUssTUFBcEIsQ0FFQTtBQUNBLEtBQUssWUFBTCxDQUFrQixJQUFsQixHQUNBO0FBQ0EsS0FBSyxZQUFMLENBQWtCLEtBQWxCLEdBRUE7QUFDQSxHQUFHLE1BQUgsQ0FBVSxHQUFHLEtBQWIsRUFDQSxHQUFHLFNBQUgsQ0FBYSxHQUFHLFNBQWhCLENBQTJCLEdBQUcsR0FBOUIsRUFFQTtBQUNBLE9BQU8sR0FBUCxHQUVBO0FBQ0EsT0FBTyxVQUFQLENBQWtCLG1CQUFsQixDQUF1QyxVQUF2QyxFQUNBLE9BQU8sVUFBUCxDQUFrQixhQUFsQixDQUFpQyxLQUFLLFVBQXRDLEVBRUE7QUFDQSxZQUNDLEtBQUssS0FETixDQUVDLE1BRkQsQ0FHQyxLQUFLLGNBQUwsRUFIRCxDQUlDLEtBQUssS0FKTixFQU1BO0FBQ0EsTUFBTSxXQUFOLEdBQW9CLE9BQXBCLENBQTRCLGtCQUFZLENBQ3ZDLFlBQ0MsT0FBSyxLQUROLENBRUMsTUFGRCxDQUdDLElBSEQsQ0FJQyxRQUpELENBS0MsT0FBSyxLQUxOLENBTUMsc0JBTkQsRUFPQSxDQVJELEVBVUE7QUFDQSxHQUFNLGFBQWMsTUFBTSxjQUFOLEVBQXBCLENBQ0EsR0FBSSxhQUFlLENBQUMsTUFBTSxVQUFOLENBQWlCLFdBQWpCLENBQXBCLENBQW1ELENBQ2xELFlBQ0MsS0FBSyxLQUROLENBRUMsTUFGRCxDQUdDLElBSEQsQ0FJQyxXQUpELENBS0MsS0FBSyxLQUxOLENBTUMseUJBTkQsRUFPQSxDQUVEO0FBQ0EsS0FBSyxZQUFMLENBQWtCLE1BQWxCLEdBRUE7QUFDQSxLQUFLLFlBQUwsQ0FBa0IsWUFBbEIsQ0FBK0IsS0FBSyxLQUFMLENBQVcsT0FBMUMsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDLHFDQTFKb0MsaUIsRUE2SnRDLE9BQU8sT0FBUCxDQUFpQix1QkFBakI7OztBQ3JVQSxhLDR0REFFQSxHQUFNLFdBQVksUUFBUSxrQkFBUixDQUFsQixDQUNBLEdBQU0sbUJBQW9CLFFBQVEsc0JBQVIsQ0FBMUIsQ0FFQTtBQUVBOzs7O0dBS0EsR0FBTSxZQUFhLElBQU0sR0FBekIsQ0FFQTs7OztHQUtBLEdBQU0sYUFBYyxDQUNuQixrYkFEbUIsQ0FnQm5CLDJsQkFoQm1CLENBQXBCLENBd0NBOztNQUdNLGtCLDhFQUVMOzs7OztJQU1BLDRCQUEwQixJQUFkLFFBQWMsMkRBQUosRUFBSSx1S0FFekIsTUFBSyxLQUFMLENBQWEsVUFBVSxRQUFRLEtBQWxCLENBQXlCLENBQUUsR0FBRixDQUFPLEdBQVAsQ0FBWSxHQUFaLENBQWlCLEdBQWpCLENBQXpCLENBQWIsQ0FDQSxNQUFLLE1BQUwsQ0FBYyxJQUFkLENBQ0EsTUFBSyxLQUFMLENBQWEsSUFBYixDQUNBLE1BQUssR0FBTCxDQUFXLElBQVgsQ0FMeUIsYUFNekIsQ0FFRDs7Ozs7O3NFQU9NLEssQ0FBTyxDQUNaLHVIQUFZLEtBQVosRUFDQTtBQUNBLEtBQUssR0FBTCxDQUFXLEtBQUssRUFBTCxDQUFRLFlBQVIsQ0FBcUIsMEJBQXJCLENBQVgsQ0FDQSxLQUFLLE1BQUwsQ0FBYyxLQUFLLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBZCxDQUNBLEtBQUssS0FBTCxDQUFhLEtBQUssaUJBQUwsQ0FBdUIsQ0FDbkMsVUFBVyxVQUR3QixDQUVuQyxrQkFBbUIsQ0FDbEI7QUFDQSxFQUFHLENBQ0YsS0FBTSxDQURKLENBRUYsS0FBTSxPQUZKLENBRmUsQ0FNbEI7QUFDQSxFQUFHLENBQ0YsS0FBTSxDQURKLENBRUYsS0FBTSxPQUZKLENBUGUsQ0FGZ0IsQ0FBdkIsQ0FBYixDQWVBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7Ozs4Q0FPUyxLLENBQU8sQ0FDZixLQUFLLGtCQUFMLENBQXdCLEtBQUssS0FBN0IsRUFDQSxLQUFLLEtBQUwsQ0FBYSxJQUFiLENBQ0EsS0FBSyxNQUFMLENBQWMsSUFBZCxDQUNBLEtBQUssR0FBTCxDQUFXLElBQVgsQ0FDQSwwSEFBZSxLQUFmLEVBQ0EsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozt1Q0FLTyxDQUNOLEdBQU0sSUFBSyxLQUFLLEVBQWhCLENBQ0EsR0FBTSxRQUFTLEtBQUssTUFBcEIsQ0FDQSxHQUFNLE9BQVEsS0FBSyxLQUFuQixDQUNBLEdBQU0sTUFBTyxLQUFLLEtBQUwsQ0FBVyxJQUF4QixDQUNBLEdBQU0sYUFBYyxLQUFLLGNBQUwsRUFBcEIsQ0FDQSxHQUFNLE1BQU8sS0FBSyxjQUFMLEVBQWIsQ0FFQTtBQUNBLEtBQUssWUFBTCxDQUFrQixJQUFsQixHQUNBO0FBQ0EsS0FBSyxZQUFMLENBQWtCLEtBQWxCLEdBRUE7QUFDQSxHQUFHLE1BQUgsQ0FBVSxHQUFHLEtBQWIsRUFDQSxHQUFHLFNBQUgsQ0FBYSxHQUFHLFNBQWhCLENBQTJCLEdBQUcsR0FBOUIsRUFFQTtBQUNBLE9BQU8sR0FBUCxHQUVBO0FBQ0EsT0FBTyxVQUFQLENBQWtCLG1CQUFsQixDQUF1QyxJQUF2QyxFQUNBLE9BQU8sVUFBUCxDQUFrQixRQUFsQixDQUE0QixLQUFLLEtBQWpDLEVBQ0EsT0FBTyxVQUFQLENBQWtCLGFBQWxCLENBQWlDLEtBQUssVUFBdEMsRUFFQTtBQUNBLE1BQU0sSUFBTixHQUVBO0FBQ0EsSUFBSyxHQUFJLEdBQUUsQ0FBWCxDQUFjLEVBQUUsWUFBWSxNQUE1QixDQUFvQyxHQUFwQyxDQUF5QyxDQUN4QyxHQUFNLFlBQWEsWUFBWSxDQUFaLENBQW5CLENBQ0E7QUFDQSxPQUFPLFVBQVAsQ0FBa0IsUUFBbEIsQ0FBNEIsV0FBVyxLQUF2QyxFQUNBLE9BQU8sVUFBUCxDQUFrQixhQUFsQixDQUFpQyxXQUFXLFVBQTVDLEVBQ0E7QUFDQSxNQUFNLElBQU4sQ0FBVyxXQUFXLElBQXRCLENBQTRCLFFBQTVCLEVBQ0EsQ0FFRDtBQUNBLE1BQU0sTUFBTixHQUVBO0FBQ0EsS0FBSyxZQUFMLENBQWtCLE1BQWxCLEdBRUE7QUFDQSxLQUFLLFlBQUwsQ0FBa0IsWUFBbEIsQ0FBK0IsS0FBSyxLQUFMLENBQVcsT0FBMUMsRUFFQSxNQUFPLEtBQVAsQ0FDQSxDLCtCQW5IOEIsaUIsRUFzSGhDLE9BQU8sT0FBUCxDQUFpQixpQkFBakI7OztBQ3BMQSxhQUVBO0FBRUEsR0FBTSxXQUFZLENBQUMsV0FBYSxVQUFVLFNBQXZCLEVBQW9DLEVBQXJDLEVBQXlDLFdBQXpDLEVBQWxCLENBQ0EsR0FBTSxRQUFTLENBQUMsV0FBYSxVQUFVLE1BQXZCLEVBQWlDLEVBQWxDLEVBQXNDLFdBQXRDLEVBQWYsQ0FFQTs7Ozs7O0dBT0EsR0FBTSxXQUFZLFFBQVosVUFBWSxFQUFXLENBQzVCLE1BQU8sV0FBVSxLQUFWLENBQWdCLDBCQUFoQixDQUFQLENBQ0EsQ0FGRCxDQUlBOzs7Ozs7R0FPQSxHQUFNLFVBQVcsUUFBWCxTQUFXLEVBQVcsQ0FDM0IsTUFBTyxjQUFhLElBQWIsQ0FBa0IsTUFBbEIsRUFBNEIsVUFBVSxLQUFWLENBQWdCLHlCQUFoQixDQUE1QixDQUF5RSxJQUFoRixDQUNBLENBRkQsQ0FJQTs7Ozs7O0dBT0EsR0FBTSxNQUFPLFFBQVAsS0FBTyxFQUFXLENBQ3ZCLE1BQU8sV0FBVSxLQUFWLENBQWdCLGdDQUFoQixDQUFQLENBQ0EsQ0FGRCxDQUlBOzs7Ozs7R0FPQSxHQUFNLFFBQVMsUUFBVCxPQUFTLEVBQVcsQ0FDekIsTUFBTyxXQUFVLEtBQVYsQ0FBZ0IsYUFBaEIsQ0FBUCxDQUNBLENBRkQsQ0FJQTs7Ozs7O0dBT0EsR0FBTSxTQUFVLFFBQVYsUUFBVSxFQUFXLENBQzFCLE1BQU8sV0FBVSxLQUFWLENBQWdCLGlDQUFoQixDQUFQLENBQ0EsQ0FGRCxDQUlBOzs7Ozs7R0FPQSxHQUFNLFVBQVcsUUFBWCxTQUFXLEVBQVcsQ0FDM0IsTUFBTyxXQUFVLEtBQVYsQ0FBZ0IseUJBQWhCLENBQVAsQ0FDQSxDQUZELENBSUE7OztHQUlBLE9BQU8sT0FBUCxDQUFpQixDQUVoQjs7O0lBSUEsUUFBUyxDQUFDLENBQUMsV0FOSyxDQVFoQjs7O0lBSUEsT0FBUSxDQUFDLENBQUMsVUFaTSxDQWNoQjs7O0lBSUEsR0FBSSxDQUFDLENBQUMsTUFsQlUsQ0FvQmhCOzs7SUFJQSxLQUFNLENBQUMsQ0FBQyxRQXhCUSxDQTBCaEI7OztJQUlBLE1BQU8sQ0FBQyxDQUFDLFNBOUJPLENBZ0NoQjs7O0lBSUEsT0FBUSxDQUFDLENBQUMsVUFwQ00sQ0FBakI7OztBQzdFQSxhLCtvQkFFQSxHQUFNLFdBQVksUUFBUSxrQkFBUixDQUFsQixDQUNBLEdBQU0sWUFBYSxRQUFRLGNBQVIsQ0FBbkIsQ0FFQTtBQUVBOzs7O0dBS0EsR0FBTSxVQUFXLFFBQWpCLENBRUE7Ozs7R0FLQSxHQUFNLFdBQVksUUFBbEIsQ0FFQTs7OztHQUtBLEdBQU0sT0FBUSxRQUFkLENBRUE7Ozs7R0FLQSxHQUFNLFVBQVcsUUFBakIsQ0FFQTs7OztHQUtBLEdBQU0sUUFBUyxRQUFmLENBRUE7QUFFQSxHQUFNLEtBQU0sUUFBTixJQUFNLENBQVMsSUFBVCxDQUFlLElBQWYsQ0FBcUIsQ0FDaEMsR0FBSSxJQUFKLENBQVUsQ0FDVCxHQUFNLEtBQU0sS0FBSyxLQUFqQixDQUNBLEdBQUksS0FBSyxTQUFMLENBQUosQ0FBcUIsQ0FDcEIsS0FBSyxTQUFMLEVBQWdCLElBQUksS0FBcEIsQ0FBMkIsSUFBSSxHQUEvQixFQUNBLENBQ0QsS0FBSyxNQUFMLElBQ0EsS0FBSyxLQUFMLEVBQVksTUFBWixDQUFtQixJQUFJLEdBQXZCLEVBQ0EsS0FBSyxRQUFMLEVBQWUsVUFBZixDQUEwQixJQUExQixFQUNBLENBQ0QsQ0FWRCxDQVlBOzs7TUFJTSxTLFlBRUw7Ozs7OztJQU9BLG1CQUEwQixJQUFkLFFBQWMsMkRBQUosRUFBSSxnQ0FDekIsS0FBSyxRQUFMLEVBQWlCLFVBQVUsS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFZLFFBQVEsUUFBcEIsQ0FBVixDQUF5QyxHQUF6QyxDQUFqQixDQUNBLEtBQUssU0FBTCxFQUFrQixVQUFVLFFBQVEsUUFBbEIsQ0FBNEIsSUFBNUIsQ0FBbEIsQ0FDQSxLQUFLLEtBQUwsR0FDQSxDQUVEOzs7OzBFQUtjLENBQ2IsTUFBTyxNQUFLLFFBQUwsQ0FBUCxDQUNBLENBRUQ7Ozs7aURBS1ksQ0FDWCxNQUFPLE1BQUssTUFBTCxDQUFQLENBQ0EsQ0FFRDs7Ozs7NENBTVEsRSxDQUFJLENBQ1gsSUFBSyxHQUFJLE1BQU8sS0FBSyxRQUFMLEVBQWUsSUFBL0IsQ0FBcUMsT0FBUyxJQUE5QyxFQUFxRCxDQUNwRCxHQUFNLE1BQU8sS0FBSyxJQUFsQixDQUNBLEdBQUcsS0FBSyxLQUFMLENBQVcsS0FBZCxDQUFxQixLQUFLLEtBQUwsQ0FBVyxHQUFoQyxFQUNBLEtBQU8sSUFBUCxDQUNBLENBQ0QsQ0FFRDs7eUNBR1EsZ0JBQ1AsR0FBSSxLQUFLLFNBQUwsR0FBbUIsS0FBSyxRQUFMLENBQXZCLENBQXVDLENBQ3RDLEtBQUssUUFBTCxFQUFlLE9BQWYsQ0FBdUIsYUFBTyxDQUM3QixNQUFLLFNBQUwsRUFBZ0IsSUFBSSxLQUFwQixDQUEyQixJQUFJLEdBQS9CLEVBQ0EsQ0FGRCxFQUdBLENBQ0QsS0FBSyxLQUFMLEVBQWMsR0FBSSxJQUFKLEVBQWQsQ0FDQSxLQUFLLFFBQUwsRUFBaUIsR0FBSSxXQUFKLEVBQWpCLENBQ0EsS0FBSyxNQUFMLEVBQWUsQ0FBZixDQUNBLENBRUQ7Ozs7OztvQ0FPSSxHLENBQUssSyxDQUFPLENBQ2YsR0FBSSxLQUFLLEtBQUwsRUFBWSxHQUFaLENBQWdCLEdBQWhCLENBQUosQ0FBMEIsQ0FDekI7QUFDQSxHQUFNLE1BQU8sS0FBSyxLQUFMLEVBQVksR0FBWixDQUFnQixHQUFoQixDQUFiLENBQ0EsR0FBTSxNQUFPLEtBQUssS0FBbEIsQ0FDQTtBQUNBLEdBQUksS0FBSyxTQUFMLENBQUosQ0FBcUIsQ0FDcEIsS0FBSyxTQUFMLEVBQWdCLEtBQUssS0FBckIsQ0FBNEIsR0FBNUIsRUFDQSxDQUNEO0FBQ0EsS0FBSyxLQUFMLENBQWEsS0FBYixDQUNBLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFDQTtBQUNBLE9BQ0EsQ0FDRDtBQUNBLEdBQU0sS0FBTSxHQUFJLE1BQUosQ0FBVSxHQUFWLENBQWUsS0FBZixDQUFaLENBQ0EsS0FBSyxNQUFMLElBQ0EsS0FBSyxRQUFMLEVBQWUsT0FBZixDQUF1QixHQUF2QixFQUNBLEtBQUssS0FBTCxFQUFZLEdBQVosQ0FBZ0IsR0FBaEIsQ0FBcUIsS0FBSyxRQUFMLEVBQWUsSUFBcEMsRUFDQTtBQUNBLEdBQUksS0FBSyxNQUFMLEVBQWUsS0FBSyxRQUFMLENBQW5CLENBQW1DLENBQ2xDO0FBQ0EsSUFBSSxJQUFKLENBQVUsS0FBSyxRQUFMLEVBQWUsSUFBekIsRUFDQSxDQUNELENBRUQ7Ozs7Ozs7O29DQVNJLEcsQ0FBSyxDQUNSLEdBQUksQ0FBQyxLQUFLLEtBQUwsRUFBWSxHQUFaLENBQWdCLEdBQWhCLENBQUwsQ0FBMkIsQ0FDMUIsTUFBTyxNQUFQLENBQ0EsQ0FDRCxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7Ozs7O29DQVFJLEcsQ0FBSyxDQUNSLEdBQU0sTUFBTyxLQUFLLEtBQUwsRUFBWSxHQUFaLENBQWdCLEdBQWhCLENBQWIsQ0FDQSxHQUFJLElBQUosQ0FBVSxDQUNUO0FBQ0EsS0FBSyxRQUFMLEVBQWUsV0FBZixDQUEyQixJQUEzQixFQUNBLE1BQU8sTUFBSyxLQUFMLENBQVcsS0FBbEIsQ0FDQSxDQUNELE1BQU8sVUFBUCxDQUNBLENBRUQ7Ozs7Ozs7c0NBUUssRyxDQUFLLENBQ1QsR0FBTSxNQUFPLEtBQUssS0FBTCxFQUFZLEdBQVosQ0FBZ0IsR0FBaEIsQ0FBYixDQUNBLEdBQUksSUFBSixDQUFVLENBQ1QsTUFBTyxNQUFLLEtBQUwsQ0FBVyxLQUFsQixDQUNBLENBQ0QsTUFBTyxVQUFQLENBQ0EsQ0FFRDs7OzsyQ0FLTyxHLENBQUssQ0FDWCxJQUFJLElBQUosQ0FBVSxLQUFLLEtBQUwsRUFBWSxHQUFaLENBQWdCLEdBQWhCLENBQVYsRUFDQSxDLHdCQUdGOzs7TUFJTSxNLENBRUw7Ozs7O0lBTUEsZUFBWSxHQUFaLENBQWlCLEtBQWpCLENBQXdCLDZCQUN2QixLQUFLLEdBQUwsQ0FBVyxHQUFYLENBQ0EsS0FBSyxLQUFMLENBQWEsS0FBYixDQUNBLEMsQ0FHRixPQUFPLE9BQVAsQ0FBaUIsUUFBakI7OztBQ3pPQSxhQUVBOzs7cXBCQUlNLFcsWUFFTDs7SUFHQSxxQkFBYyxrQ0FDYixLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLEtBQUssTUFBTCxDQUFjLENBQWQsQ0FDQSxDQUVEOzs7Ozs7NkRBT0ssSSxDQUFNLENBQ1YsS0FBSyxJQUFMLENBQVksR0FBSSxLQUFKLENBQVMsSUFBVCxDQUFlLEtBQUssSUFBcEIsQ0FBMEIsSUFBMUIsQ0FBZ0MsSUFBaEMsQ0FBWixDQUNBLEdBQUksQ0FBQyxLQUFLLElBQVYsQ0FBZ0IsQ0FDZixLQUFLLElBQUwsQ0FBWSxLQUFLLElBQWpCLENBQ0EsQ0FDRCxLQUFLLE1BQUwsR0FDQSxNQUFPLE1BQUssTUFBWixDQUNBLENBRUQ7Ozs7Ozs0Q0FPUSxJLENBQU0sQ0FDYixLQUFLLElBQUwsQ0FBWSxHQUFJLEtBQUosQ0FBUyxJQUFULENBQWUsSUFBZixDQUFxQixLQUFLLElBQTFCLENBQWdDLElBQWhDLENBQVosQ0FDQSxHQUFJLENBQUMsS0FBSyxJQUFWLENBQWdCLENBQ2YsS0FBSyxJQUFMLENBQVksS0FBSyxJQUFqQixDQUNBLENBQ0QsS0FBSyxNQUFMLEdBQ0EsTUFBTyxNQUFLLE1BQVosQ0FDQSxDQUVEOzs7O3FDQUtNLENBQ0wsR0FBSSxDQUFDLEtBQUssSUFBVixDQUFnQixDQUNmLE1BQU8sVUFBUCxDQUNBLENBQ0QsR0FBTSxLQUFNLEtBQUssSUFBTCxDQUFVLEtBQXRCLENBQ0EsS0FBSyxJQUFMLENBQVksS0FBSyxJQUFMLENBQVUsSUFBdEIsQ0FDQSxHQUFJLEtBQUssSUFBVCxDQUFlLENBQ2QsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFpQixJQUFqQixDQUNBLENBRkQsSUFFTyxDQUNOLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxDQUNELEtBQUssTUFBTCxHQUNBLE1BQU8sSUFBUCxDQUNBLENBRUQ7Ozs7eUNBS1EsQ0FDUCxHQUFJLENBQUMsS0FBSyxJQUFWLENBQWdCLENBQ2YsTUFBTyxVQUFQLENBQ0EsQ0FDRCxHQUFNLEtBQU0sS0FBSyxJQUFMLENBQVUsS0FBdEIsQ0FDQSxLQUFLLElBQUwsQ0FBWSxLQUFLLElBQUwsQ0FBVSxJQUF0QixDQUNBLEdBQUksS0FBSyxJQUFULENBQWUsQ0FDZCxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWlCLElBQWpCLENBQ0EsQ0FGRCxJQUVPLENBQ04sS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLENBQ0QsS0FBSyxNQUFMLEdBQ0EsTUFBTyxJQUFQLENBQ0EsQ0FFRDs7Ozs7O29DQU9JLEMsQ0FBRyxDQUNOLEdBQUksU0FBSixDQUNBLEdBQUksWUFBSixDQUNBLElBQUssRUFBSSxDQUFKLENBQU8sS0FBTyxLQUFLLElBQXhCLENBQThCLE9BQVMsSUFBVCxFQUFpQixFQUFJLENBQW5ELENBQXNELEdBQXRELENBQTJELENBQzFEO0FBQ0EsS0FBTyxLQUFLLElBQVosQ0FDQSxDQUNELEdBQUksSUFBTSxDQUFOLEVBQVcsT0FBUyxJQUF4QixDQUE4QixDQUM3QixNQUFPLE1BQUssS0FBWixDQUNBLENBQ0QsQ0FFRDs7Ozs0Q0FLUSxFLENBQUksQ0FDWCxJQUFLLEdBQUksTUFBTyxLQUFLLElBQWhCLENBQXNCLEVBQUksQ0FBL0IsQ0FBa0MsT0FBUyxJQUEzQyxDQUFpRCxHQUFqRCxDQUFzRCxDQUNyRCxHQUFHLEtBQUssS0FBUixDQUFlLENBQWYsRUFDQSxLQUFPLEtBQUssSUFBWixDQUNBLENBQ0QsQ0FFRDs7Ozs7OztvQ0FRSSxFLENBQUksQ0FDUCxHQUFNLEtBQU0sR0FBSSxNQUFKLENBQVUsS0FBSyxNQUFmLENBQVosQ0FDQSxJQUFLLEdBQUksR0FBSSxDQUFSLENBQVcsS0FBTyxLQUFLLElBQTVCLENBQWtDLE9BQVMsSUFBM0MsQ0FBaUQsR0FBakQsQ0FBc0QsQ0FDckQsSUFBSSxDQUFKLEVBQVMsR0FBRyxLQUFLLEtBQVIsQ0FBZSxDQUFmLENBQVQsQ0FDQSxLQUFPLEtBQUssSUFBWixDQUNBLENBQ0QsTUFBTyxJQUFQLENBQ0EsQ0FFRDs7Ozs7OzhDQU9TLEksQ0FBTSxDQUNkLEdBQUksT0FBUyxLQUFLLElBQWxCLENBQXdCLENBQ3ZCLE9BQ0EsQ0FDRCxHQUFJLEtBQUssSUFBVCxDQUFlLENBQ2QsS0FBSyxJQUFMLENBQVUsVUFBVixDQUFxQixJQUFyQixFQUNBLENBQ0QsR0FBTSxNQUFPLEtBQUssSUFBbEIsQ0FDQSxLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLEdBQUksSUFBSixDQUFVLENBQ1QsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLENBQ0QsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLEdBQUksQ0FBQyxLQUFLLElBQVYsQ0FBZ0IsQ0FDZixLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsQ0FDRCxLQUFLLE1BQUwsR0FDQSxNQUFPLE1BQUssTUFBWixDQUNBLENBRUQ7Ozs7OztvREFPWSxJLENBQU0sQ0FDakIsR0FBSSxPQUFTLEtBQUssSUFBbEIsQ0FBd0IsQ0FDdkIsT0FDQSxDQUNELEdBQUksS0FBSyxJQUFULENBQWUsQ0FDZCxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQXFCLElBQXJCLEVBQ0EsQ0FDRCxHQUFNLE1BQU8sS0FBSyxJQUFsQixDQUNBLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsR0FBSSxJQUFKLENBQVUsQ0FDVCxLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsQ0FDRCxLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsR0FBSSxDQUFDLEtBQUssSUFBVixDQUFnQixDQUNmLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxDQUNELEtBQUssTUFBTCxHQUNBLE1BQU8sTUFBSyxNQUFaLENBQ0EsQ0FFRDs7Ozs7O2tEQU9XLEksQ0FBTSxDQUNoQixHQUFJLEtBQUssSUFBTCxHQUFjLElBQWxCLENBQXdCLENBQ3ZCLEtBQU0sa0RBQU4sQ0FDQSxDQUNELEdBQU0sTUFBTyxLQUFLLElBQWxCLENBQ0EsR0FBTSxNQUFPLEtBQUssSUFBbEIsQ0FDQSxHQUFJLElBQUosQ0FBVSxDQUNULEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxDQUNELEdBQUksSUFBSixDQUFVLENBQ1QsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLENBQ0QsR0FBSSxPQUFTLEtBQUssSUFBbEIsQ0FBd0IsQ0FDdkIsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLENBQ0QsR0FBSSxPQUFTLEtBQUssSUFBbEIsQ0FBd0IsQ0FDdkIsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLENBQ0QsS0FBSyxJQUFMLENBQVUsTUFBVixHQUNBLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLE1BQU8sTUFBSyxNQUFaLENBQ0EsQywwQkFHRjs7O01BSU0sSyxDQUVMOzs7Ozs7O0lBUUEsY0FBWSxLQUFaLENBQW1CLElBQW5CLENBQXlCLElBQXpCLENBQStCLElBQS9CLENBQXFDLDRCQUNwQyxLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsS0FBSyxLQUFMLENBQWEsS0FBYixDQUNBLEdBQUksSUFBSixDQUFVLENBQ1QsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxDQUhELElBR08sQ0FDTixLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsQ0FDRCxHQUFJLElBQUosQ0FBVSxDQUNULEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsQ0FIRCxJQUdPLENBQ04sS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLENBQ0QsQyxDQUdGLE9BQU8sT0FBUCxDQUFpQixVQUFqQjs7O0FDbFFBLGFBRUE7Ozs7O0dBTUEsT0FBTyxPQUFQLENBQWlCLFNBQVMsR0FBVCxDQUFjLElBQWQsQ0FBb0IsQ0FDcEMsR0FBTSxLQUFNLEdBQUksZUFBSixFQUFaLENBQ0EsSUFBSSxJQUFKLENBQVMsS0FBVCxDQUFnQixHQUFoQixDQUFxQixJQUFyQixFQUNBLElBQUksWUFBSixDQUFtQixhQUFuQixDQUNBLElBQUksTUFBSixDQUFhLFVBQU0sQ0FDbEIsR0FBTSxhQUFjLElBQUksUUFBeEIsQ0FDQSxHQUFJLFdBQUosQ0FBaUIsQ0FDaEIsS0FBSyxJQUFMLENBQVcsV0FBWCxFQUNBLENBRkQsSUFFTyxDQUNOLEdBQU0sOENBQWdELE1BQU0sSUFBTixDQUFXLENBQVgsRUFBYyxVQUE5RCxJQUFOLENBQ0EsS0FBSyxHQUFMLENBQVUsSUFBVixFQUNBLENBQ0QsQ0FSRCxDQVNBLElBQUksT0FBSixDQUFjLFNBQUMsS0FBRCxDQUFXLENBQ3hCLEdBQU0sOENBQWdELE1BQU0sSUFBTixDQUFXLENBQVgsRUFBYyxVQUE5RCxJQUFOLENBQ0EsS0FBSyxHQUFMLENBQVUsSUFBVixFQUNBLENBSEQsQ0FJQSxJQUFJLGVBQUosQ0FBc0IsSUFBdEIsQ0FDQSxJQUFJLElBQUosQ0FBUyxJQUFULEVBQ0EsQ0FuQkQ7OztBQ1JBLGFBRUE7Ozs7O0dBTUEsT0FBTyxPQUFQLENBQWlCLFNBQVMsR0FBVCxDQUFjLElBQWQsQ0FBb0IsQ0FDcEMsR0FBTSxPQUFRLEdBQUksTUFBSixFQUFkLENBQ0EsTUFBTSxNQUFOLENBQWUsVUFBTSxDQUNwQixLQUFLLElBQUwsQ0FBVyxLQUFYLEVBQ0EsQ0FGRCxDQUdBLE1BQU0sT0FBTixDQUFnQixTQUFDLEtBQUQsQ0FBVyxDQUMxQixHQUFNLHdDQUEwQyxNQUFNLElBQU4sQ0FBVyxDQUFYLEVBQWMsVUFBeEQsSUFBTixDQUNBLEtBQUssR0FBTCxDQUFVLElBQVYsRUFDQSxDQUhELENBSUEsTUFBTSxXQUFOLENBQW9CLFdBQXBCLENBQ0EsTUFBTSxHQUFOLENBQVksR0FBWixDQUNBLENBWEQ7OztBQ1JBLGEsK29CQUVBLEdBQU0sU0FBVSxRQUFRLG1CQUFSLENBQWhCLENBQ0EsR0FBTSxRQUFTLFFBQVEsaUJBQVIsQ0FBZixDQUNBLEdBQU0sY0FBZSxRQUFRLHVCQUFSLENBQXJCLENBRUE7QUFFQTs7OztHQUtBLEdBQU0sYUFBYyxDQUNuQix1UUFEbUIsQ0FZbkIsdVNBWm1CLENBQXBCLENBeUJBO0FBRUEsR0FBTSxZQUFhLFFBQWIsV0FBYSxDQUFTLEVBQVQsQ0FBYSxHQUFiLENBQWtCLEdBQWxCLENBQXVCLENBQ3pDLEdBQU0sVUFBVyxHQUFJLGFBQUosQ0FBaUIsRUFBakIsQ0FBakIsQ0FDQTtBQUNBLFNBQVMsQ0FBVCxFQUFjLEdBQWQsQ0FDQSxTQUFTLENBQVQsRUFBYyxHQUFkLENBQ0EsU0FBUyxDQUFULEVBQWMsR0FBZCxDQUNBLFNBQVMsQ0FBVCxFQUFjLEdBQWQsQ0FDQSxTQUFTLENBQVQsRUFBYyxHQUFkLENBQ0EsU0FBUyxDQUFULEVBQWMsR0FBZCxDQUNBLFNBQVMsQ0FBVCxFQUFjLEdBQWQsQ0FDQSxTQUFTLENBQVQsRUFBYyxHQUFkLENBQ0EsU0FBUyxDQUFULEVBQWMsR0FBZCxDQUNBLFNBQVMsQ0FBVCxFQUFjLEdBQWQsQ0FDQSxTQUFTLEVBQVQsRUFBZSxHQUFmLENBQ0EsU0FBUyxFQUFULEVBQWUsR0FBZixDQUNBO0FBQ0EsU0FBUyxFQUFULEVBQWUsQ0FBZixDQUNBLFNBQVMsRUFBVCxFQUFlLENBQWYsQ0FDQSxTQUFTLEVBQVQsRUFBZSxDQUFmLENBQ0EsU0FBUyxFQUFULEVBQWUsQ0FBZixDQUNBLFNBQVMsRUFBVCxFQUFlLENBQWYsQ0FDQSxTQUFTLEVBQVQsRUFBZSxDQUFmLENBQ0EsU0FBUyxFQUFULEVBQWUsQ0FBZixDQUNBLFNBQVMsRUFBVCxFQUFlLENBQWYsQ0FDQSxTQUFTLEVBQVQsRUFBZSxDQUFmLENBQ0EsU0FBUyxFQUFULEVBQWUsQ0FBZixDQUNBLFNBQVMsRUFBVCxFQUFlLENBQWYsQ0FDQSxTQUFTLEVBQVQsRUFBZSxDQUFmLENBQ0E7QUFDQSxNQUFPLElBQUksYUFBSixDQUNOLEVBRE0sQ0FFTixRQUZNLENBR04sQ0FDQyxFQUFHLENBQ0YsS0FBTSxDQURKLENBRUYsS0FBTSxPQUZKLENBR0YsV0FBWSxDQUhWLENBREosQ0FNQyxFQUFHLENBQ0YsS0FBTSxDQURKLENBRUYsS0FBTSxPQUZKLENBR0YsV0FBWSxFQUFJLENBQUosQ0FBUSxDQUhsQixDQU5KLENBSE0sQ0FlTixDQUNDLE1BQU8sQ0FEUixDQWZNLENBQVAsQ0FrQkEsQ0EvQ0QsQ0FpREEsR0FBTSxnQkFBaUIsUUFBakIsZUFBaUIsQ0FBUyxFQUFULENBQWEsV0FBYixDQUEwQixVQUExQixDQUFzQyxLQUF0QyxDQUE2QyxDQUNuRSxHQUFHLGVBQUgsQ0FBbUIsR0FBRyxXQUF0QixDQUFtQyxXQUFuQyxFQUNBLEdBQUcsb0JBQUgsQ0FDQyxHQUFHLFdBREosQ0FFQyxzQkFBc0IsS0FBdEIsQ0FGRCxDQUdDLEdBQUcsVUFISixDQUlDLFdBQVcsT0FKWixDQUtDLENBTEQsRUFNQSxHQUFHLGVBQUgsQ0FBbUIsR0FBRyxXQUF0QixDQUFtQyxJQUFuQyxFQUNBLENBVEQsQ0FXQSxHQUFNLGdCQUFpQixRQUFqQixlQUFpQixDQUFTLEVBQVQsQ0FBYSxPQUFiLENBQXNCLE1BQXRCLENBQThCLElBQTlCLENBQW9DLE9BQXBDLENBQTZDLENBQ25FO0FBQ0EsT0FBTyxHQUFQLEdBQ0E7QUFDQSxHQUFHLE1BQUgsQ0FBVSxHQUFHLEtBQWIsRUFDQSxHQUFHLFNBQUgsQ0FBYSxHQUFHLFNBQWhCLENBQTJCLEdBQUcsbUJBQTlCLEVBQ0E7QUFDQSxPQUFPLFVBQVAsQ0FBa0IsVUFBbEIsQ0FBOEIsT0FBOUIsRUFDQTtBQUNBLE9BQU8sVUFBUCxDQUFrQixpQkFBbEIsQ0FBcUMsQ0FBckMsRUFDQTtBQUNBLFFBQVEsSUFBUixDQUFhLENBQWIsRUFDQTtBQUNBLEtBQUssSUFBTCxHQUNBLEtBQUssSUFBTCxHQUNBLEtBQUssTUFBTCxHQUNBLENBaEJELENBa0JBOztNQUdNLGEsWUFFTDs7Ozs7O0lBT0Msc0JBQVksRUFBWixDQUFnQixLQUFoQixDQUF1QixNQUF2QixDQUErQixvQ0FDL0IsS0FBSyxFQUFMLENBQVUsRUFBVixDQUNBLEtBQUssV0FBTCxDQUFtQixHQUFHLGlCQUFILEVBQW5CLENBQ0EsS0FBSyxNQUFMLENBQWMsR0FBSSxPQUFKLENBQVcsRUFBWCxDQUFlLFdBQWYsQ0FBZCxDQUNBLEtBQUssSUFBTCxDQUFZLFdBQVcsRUFBWCxDQUFlLENBQUMsQ0FBaEIsQ0FBbUIsQ0FBbkIsQ0FBWixDQUNBLEtBQUssT0FBTCxDQUFlLEdBQUksUUFBSixDQUFZLEVBQVosQ0FBZ0IsSUFBaEIsQ0FBc0IsQ0FDcEMsTUFBTyxLQUQ2QixDQUVwQyxPQUFRLE1BRjRCLENBR3BDLE9BQVEsU0FINEIsQ0FJcEMsUUFBUyxLQUoyQixDQUtwQyxpQkFBa0IsS0FMa0IsQ0FBdEIsQ0FBZixDQU9BLGVBQ0MsS0FBSyxFQUROLENBRUMsS0FBSyxXQUZOLENBR0MsS0FBSyxPQUhOLENBSUMsQ0FKRCxFQUtBLENBRUQ7Ozs7Z0VBS08sQ0FDTixHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBLEdBQUcsZUFBSCxDQUFtQixHQUFHLFdBQXRCLENBQW1DLEtBQUssV0FBeEMsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7OzJDQUtTLENBQ1IsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFHLGVBQUgsQ0FBbUIsR0FBRyxXQUF0QixDQUFtQyxJQUFuQyxFQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7eUNBS1EsQ0FDUCxLQUFLLEVBQUwsQ0FBUSxVQUFSLENBQW1CLENBQW5CLENBQXNCLENBQXRCLENBQXlCLENBQXpCLENBQTRCLENBQTVCLEVBQ0EsS0FBSyxFQUFMLENBQVEsS0FBUixDQUFjLEtBQUssRUFBTCxDQUFRLGdCQUF0QixFQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7OztzREFPYSxPLENBQVMsQ0FDckIsZUFDQyxLQUFLLEVBRE4sQ0FFQyxLQUFLLE9BRk4sQ0FHQyxLQUFLLE1BSE4sQ0FJQyxLQUFLLElBSk4sQ0FLQyxPQUxELEVBTUEsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozs7OzswQ0FRTyxLLENBQU8sTSxDQUFRLENBQ3JCLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBb0IsS0FBcEIsQ0FBMkIsTUFBM0IsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDLDRCQUdGLE9BQU8sT0FBUCxDQUFpQixZQUFqQjs7O0FDck5BLGEsK29CQUVBLEdBQU0sS0FBTSxRQUFRLFlBQVIsQ0FBWixDQUNBLEdBQU0sYUFBYyxRQUFRLGVBQVIsQ0FBcEIsQ0FFQTtBQUVBLEdBQU0sbUJBQW9CLENBQ3pCLE9BQVEsV0FEaUIsQ0FFekIsU0FBVSxZQUZlLENBR3pCLFFBQVMsV0FIZ0IsQ0FJekIsVUFBVyxZQUpjLENBS3pCLE1BQU8sV0FMa0IsQ0FNekIsUUFBUyxZQU5nQixDQU96QixPQUFRLFdBUGlCLENBUXpCLFNBQVUsWUFSZSxDQVN6QixPQUFRLFlBVGlCLENBVXpCLFNBQVUsWUFWZSxDQVd6QixRQUFTLFlBWGdCLENBWXpCLFVBQVcsWUFaYyxDQWF6QixPQUFRLFlBYmlCLENBY3pCLFNBQVUsWUFkZSxDQWV6QixRQUFTLFlBZmdCLENBZ0J6QixVQUFXLFlBaEJjLENBaUJ6QixPQUFRLFlBakJpQixDQWtCekIsU0FBVSxZQWxCZSxDQW1CekIsUUFBUyxZQW5CZ0IsQ0FvQnpCLFVBQVcsWUFwQmMsQ0FxQnpCLE9BQVEsa0JBckJpQixDQXNCekIsU0FBVSxrQkF0QmUsQ0F1QnpCLE9BQVEsa0JBdkJpQixDQXdCekIsU0FBVSxrQkF4QmUsQ0F5QnpCLE9BQVEsa0JBekJpQixDQTBCekIsU0FBVSxrQkExQmUsQ0EyQnpCLFlBQWEsV0EzQlksQ0E0QnpCLGNBQWUsV0E1QlUsQ0FBMUIsQ0ErQkE7QUFFQSxHQUFNLDBCQUEyQixRQUEzQix5QkFBMkIsQ0FBUyxNQUFULENBQWlCLFVBQWpCLENBQTZCLFVBQTdCLENBQXlDLENBQ3pFO0FBQ0EsR0FBTSxjQUFlLFlBQ3BCLENBQUUsVUFBRixDQUFjLFVBQWQsQ0FEb0IsQ0FFcEIsQ0FBRSxTQUFGLENBQWEsV0FBYixDQUZvQixDQUFyQixDQUdBO0FBQ0EsYUFBYSxPQUFiLENBQXFCLHFCQUFlLENBQ25DO0FBQ0EsR0FBSSxZQUFZLFNBQVosR0FBMEIsV0FBOUIsQ0FBMkMsQ0FDMUM7QUFDQSxPQUFPLFVBQVAsQ0FBa0IsR0FBbEIsQ0FBc0IsWUFBWSxJQUFsQyxDQUF3QyxDQUN2QyxLQUFNLFlBQVksSUFEcUIsQ0FFdkMsTUFBTyxPQUFPLFVBQVAsQ0FBa0IsSUFGYyxDQUF4QyxFQUlBLENBTkQsSUFNTyxDQUFFO0FBQ1I7QUFDQSxHQUFNLE1BQU8sWUFBWSxJQUFaLEVBQW9CLFlBQVksS0FBWixDQUFvQixDQUFwQixDQUF3QixJQUF4QixDQUErQixFQUFuRCxDQUFiLENBQ0EsT0FBTyxRQUFQLENBQWdCLEdBQWhCLENBQW9CLFlBQVksSUFBaEMsQ0FBc0MsQ0FDckMsS0FBTSxZQUFZLElBRG1CLENBRXJDLEtBQU0sa0JBQWtCLElBQWxCLENBRitCLENBQXRDLEVBSUEsQ0FDRCxDQWhCRCxFQWlCQSxDQXZCRCxDQXlCQSxHQUFNLFlBQWEsUUFBYixXQUFhLENBQVMsR0FBVCxDQUFjLEdBQWQsQ0FBbUIsQ0FDckMsSUFBTSxJQUFJLFFBQUosRUFBTixDQUNBLEdBQU0sTUFBTyxJQUFNLElBQUksTUFBdkIsQ0FDQSxLQUFPLEdBQVAsQ0FDQSxJQUFLLEdBQUksR0FBRSxDQUFYLENBQWMsRUFBRSxJQUFoQixDQUFzQixHQUF0QixDQUEyQixDQUMxQixLQUFPLEdBQVAsQ0FDQSxDQUNELE1BQU8sSUFBUCxDQUNBLENBUkQsQ0FVQSxHQUFNLGVBQWdCLFFBQWhCLGNBQWdCLENBQVMsRUFBVCxDQUFhLFlBQWIsQ0FBMkIsSUFBM0IsQ0FBaUMsQ0FDdEQsR0FBTSxRQUFTLEdBQUcsWUFBSCxDQUFnQixHQUFHLElBQUgsQ0FBaEIsQ0FBZixDQUNBLEdBQUcsWUFBSCxDQUFnQixNQUFoQixDQUF3QixZQUF4QixFQUNBLEdBQUcsYUFBSCxDQUFpQixNQUFqQixFQUNBLEdBQUksQ0FBQyxHQUFHLGtCQUFILENBQXNCLE1BQXRCLENBQThCLEdBQUcsY0FBakMsQ0FBTCxDQUF1RCxDQUN0RCxHQUFNLE9BQVEsYUFBYSxLQUFiLENBQW1CLElBQW5CLENBQWQsQ0FDQSxHQUFNLFdBQWEsTUFBTSxNQUFQLENBQWUsUUFBZixHQUEwQixNQUExQixDQUFtQyxDQUFyRCxDQUNBLEdBQU0sWUFBYSxNQUFNLEdBQU4sQ0FBVSxTQUFDLElBQUQsQ0FBTyxLQUFQLENBQWlCLENBQzdDLE1BQVUsWUFBVyxNQUFNLENBQWpCLENBQW9CLFNBQXBCLENBQVYsS0FBNEMsSUFBNUMsQ0FDQSxDQUZrQixFQUVoQixJQUZnQixDQUVYLElBRlcsQ0FBbkIsQ0FHQSxHQUFNLFdBQVksR0FBRyxnQkFBSCxDQUFvQixNQUFwQixDQUFsQixDQUNBLG1EQUFvRCxVQUFVLEtBQVYsQ0FBZ0IsQ0FBaEIsQ0FBbUIsVUFBVSxNQUFWLENBQWlCLENBQXBDLENBQXBELE1BQStGLFVBQS9GLENBQ0EsQ0FDRCxNQUFPLE9BQVAsQ0FDQSxDQWRELENBZ0JBLEdBQU0sd0JBQXlCLFFBQXpCLHVCQUF5QixDQUFTLE1BQVQsQ0FBaUIsQ0FDL0MsR0FBTSxJQUFLLE9BQU8sRUFBbEIsQ0FDQSxPQUFPLFVBQVAsQ0FBa0IsT0FBbEIsQ0FBMEIsU0FBQyxTQUFELENBQVksSUFBWixDQUFxQixDQUM5QztBQUNBLEdBQUcsa0JBQUgsQ0FBc0IsT0FBTyxPQUE3QixDQUFzQyxVQUFVLEtBQWhELENBQXVELElBQXZELEVBQ0EsQ0FIRCxFQUlBLENBTkQsQ0FRQSxHQUFNLHFCQUFzQixRQUF0QixvQkFBc0IsQ0FBUyxNQUFULENBQWlCLENBQzVDLEdBQU0sSUFBSyxPQUFPLEVBQWxCLENBQ0EsR0FBTSxVQUFXLE9BQU8sUUFBeEIsQ0FDQSxTQUFTLE9BQVQsQ0FBaUIsU0FBQyxPQUFELENBQVUsSUFBVixDQUFtQixDQUNuQztBQUNBLEdBQU0sVUFBVyxHQUFHLGtCQUFILENBQXNCLE9BQU8sT0FBN0IsQ0FBc0MsSUFBdEMsQ0FBakIsQ0FDQTtBQUNBO0FBQ0EsR0FBSSxXQUFhLElBQWpCLENBQXVCLENBQ3RCLFNBQVMsTUFBVCxDQUFnQixJQUFoQixFQUNBLENBRkQsSUFFTyxDQUNOLFFBQVEsUUFBUixDQUFtQixRQUFuQixDQUNBLENBQ0QsQ0FWRCxFQVdBLENBZEQsQ0FnQkEsR0FBTSxlQUFnQixRQUFoQixjQUFnQixDQUFTLE9BQVQsQ0FBa0IsQ0FDdkMsTUFBTyxLQUFJLE9BQUosQ0FBYSxTQUFDLEtBQUQsQ0FBUSxJQUFSLENBQWlCLENBQ3BDLGlCQUFrQixJQUFsQixLQUEwQixLQUExQixDQUNBLENBRk0sRUFFSixJQUZJLENBRUMsSUFGRCxDQUFQLENBR0EsQ0FKRCxDQU1BLEdBQU0sZUFBZ0IsUUFBaEIsY0FBZ0IsQ0FBUyxNQUFULENBQWlCLE9BQWpCLENBQTBCLENBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFNLElBQUssT0FBTyxFQUFsQixDQUNBLEdBQU0sU0FBVSxjQUFjLFFBQVEsTUFBdEIsQ0FBaEIsQ0FDQSxHQUFNLFFBQVMsU0FBVyxRQUFRLE1BQVIsRUFBa0IsRUFBN0IsQ0FBZixDQUNBLEdBQU0sTUFBTyxPQUFTLFFBQVEsSUFBOUIsQ0FDQSxHQUFNLE1BQU8sT0FBUyxRQUFRLElBQTlCLENBQ0E7QUFDQSxHQUFNLGNBQWUsY0FBYyxFQUFkLENBQWtCLElBQWxCLENBQXdCLGVBQXhCLENBQXJCLENBQ0EsR0FBTSxnQkFBaUIsY0FBYyxFQUFkLENBQWtCLElBQWxCLENBQXdCLGlCQUF4QixDQUF2QixDQUNBO0FBQ0EseUJBQXlCLE1BQXpCLENBQWlDLElBQWpDLENBQXVDLElBQXZDLEVBQ0E7QUFDQSxPQUFPLE9BQVAsQ0FBaUIsR0FBRyxhQUFILEVBQWpCLENBQ0E7QUFDQSxHQUFHLFlBQUgsQ0FBZ0IsT0FBTyxPQUF2QixDQUFnQyxZQUFoQyxFQUNBLEdBQUcsWUFBSCxDQUFnQixPQUFPLE9BQXZCLENBQWdDLGNBQWhDLEVBQ0E7QUFDQSx1QkFBdUIsTUFBdkIsRUFDQTtBQUNBLEdBQUcsV0FBSCxDQUFlLE9BQU8sT0FBdEIsRUFDQTtBQUNBLEdBQUksQ0FBQyxHQUFHLG1CQUFILENBQXVCLE9BQU8sT0FBOUIsQ0FBdUMsR0FBRyxXQUExQyxDQUFMLENBQTZELENBQzVELDhDQUErQyxHQUFHLGlCQUFILENBQXFCLE9BQU8sT0FBNUIsQ0FBL0MsQ0FDQSxDQUNEO0FBQ0Esb0JBQW9CLE1BQXBCLEVBQ0EsQ0EvQkQsQ0FpQ0E7O01BR00sTyxZQUVMOzs7Ozs7Ozs7SUFVQSxnQkFBWSxFQUFaLENBQTZCLElBQWIsT0FBYSwyREFBSixFQUFJLDhCQUM1QjtBQUNBLEdBQUksQ0FBQyxPQUFPLElBQVosQ0FBa0IsQ0FDakIsS0FBTSxxREFBTixDQUNBLENBQ0QsR0FBSSxDQUFDLE9BQU8sSUFBWixDQUFrQixDQUNqQixLQUFNLHVEQUFOLENBQ0EsQ0FDRCxLQUFLLEVBQUwsQ0FBVSxFQUFWLENBQ0EsS0FBSyxPQUFMLENBQWUsSUFBZixDQUNBLEtBQUssVUFBTCxDQUFrQixHQUFJLElBQUosRUFBbEIsQ0FDQSxLQUFLLFFBQUwsQ0FBZ0IsR0FBSSxJQUFKLEVBQWhCLENBQ0E7QUFDQSxjQUFjLElBQWQsQ0FBb0IsTUFBcEIsRUFDQSxDQUVEOzs7O3dEQUtNLENBQ0w7QUFDQSxLQUFLLEVBQUwsQ0FBUSxVQUFSLENBQW1CLEtBQUssT0FBeEIsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7Ozs7O2tEQVFXLEksQ0FBTSxLLENBQU8sQ0FDdkIsR0FBTSxTQUFVLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBa0IsSUFBbEIsQ0FBaEIsQ0FDQTtBQUNBLEdBQUksQ0FBQyxPQUFMLENBQWMsQ0FDYixxQ0FBdUMsSUFBdkMsS0FDQSxDQUNEO0FBQ0EsR0FBSSxRQUFVLFNBQVYsRUFBdUIsUUFBVSxJQUFyQyxDQUEyQyxDQUMxQztBQUNBLGtDQUFvQyxJQUFwQywwQkFDQSxDQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUksUUFBUSxJQUFSLEdBQWlCLE1BQWpCLEVBQTJCLFFBQVEsSUFBUixHQUFpQixNQUE1QyxFQUFzRCxRQUFRLElBQVIsR0FBaUIsTUFBM0UsQ0FBbUYsQ0FDbEYsS0FBSyxFQUFMLENBQVEsUUFBUSxJQUFoQixFQUFzQixRQUFRLFFBQTlCLENBQXdDLEtBQXhDLENBQStDLEtBQS9DLEVBQ0EsQ0FGRCxJQUVPLENBQ04sS0FBSyxFQUFMLENBQVEsUUFBUSxJQUFoQixFQUFzQixRQUFRLFFBQTlCLENBQXdDLEtBQXhDLEVBQ0EsQ0FDRCxNQUFPLEtBQVAsQ0FDQSxDLHNCQUdGLE9BQU8sT0FBUCxDQUFpQixNQUFqQjs7O0FDbk9BLGFBRUEsR0FBTSxZQUFhLFFBQVEsY0FBUixDQUFuQixDQUVBO0FBRUEsR0FBTSxpQkFBa0Isb0NBQXhCLENBQ0EsR0FBTSxnQkFBaUIsZ0JBQXZCLENBQ0EsR0FBTSxtQkFBb0IsU0FBMUIsQ0FDQSxHQUFNLDJCQUE0QixvQ0FBbEMsQ0FDQSxHQUFNLG1CQUFvQix3Q0FBMUIsQ0FDQSxHQUFNLGlCQUFrQiwyQkFBeEIsQ0FDQSxHQUFNLHdCQUF5Qiw0QkFBL0IsQ0FFQTtBQUVBLEdBQU0sZUFBZ0IsUUFBaEIsY0FBZ0IsQ0FBUyxHQUFULENBQWMsQ0FDbkM7QUFDQSxNQUFPLEtBQUksT0FBSixDQUFZLGVBQVosQ0FBNkIsRUFBN0IsQ0FBUCxDQUNBLENBSEQsQ0FLQSxHQUFNLGdCQUFpQixRQUFqQixlQUFpQixDQUFTLEdBQVQsQ0FBYyxDQUNwQyxNQUFPLEtBQ0wsT0FESyxDQUNHLGVBREgsQ0FDb0IsRUFEcEIsQ0FDd0I7QUFEeEIsQ0FFTCxPQUZLLENBRUcsc0JBRkgsQ0FFMkIsRUFGM0IsQ0FBUCxDQUV1QztBQUN2QyxDQUpELENBTUEsR0FBTSxxQkFBc0IsUUFBdEIsb0JBQXNCLENBQVMsR0FBVCxDQUFjLENBQ3pDLE1BQU8sS0FDTCxPQURLLENBQ0csY0FESCxDQUNtQixHQURuQixDQUN3QjtBQUR4QixDQUVMLE9BRkssQ0FFRyxpQkFGSCxDQUVzQixHQUZ0QixDQUUyQjtBQUYzQixDQUdMLE9BSEssQ0FHRyx5QkFISCxDQUc4QixRQUg5QixDQUFQLENBR2dEO0FBQ2hELENBTEQsQ0FPQSxHQUFNLG1CQUFvQixRQUFwQixrQkFBb0IsQ0FBUyxTQUFULENBQW9CLElBQXBCLENBQTBCLEtBQTFCLENBQWlDLENBQzFEO0FBQ0EsR0FBTSxTQUFVLE1BQU0sS0FBTixDQUFZLGlCQUFaLENBQWhCLENBQ0EsR0FBTSxNQUFPLFFBQVEsQ0FBUixDQUFiLENBQ0EsR0FBTSxPQUFTLFFBQVEsQ0FBUixJQUFlLFNBQWhCLENBQTZCLENBQTdCLENBQWlDLFNBQVMsUUFBUSxDQUFSLENBQVQsQ0FBcUIsRUFBckIsQ0FBL0MsQ0FDQSxNQUFPLENBQ04sVUFBVyxTQURMLENBRU4sS0FBTSxJQUZBLENBR04sS0FBTSxJQUhBLENBSU4sTUFBTyxLQUpELENBQVAsQ0FNQSxDQVhELENBYUEsR0FBTSxnQkFBaUIsUUFBakIsZUFBaUIsQ0FBUyxTQUFULENBQW9CLENBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBTSxPQUFRLFVBQVUsS0FBVixDQUFnQixHQUFoQixFQUFxQixHQUFyQixDQUF5QixjQUFRLENBQzlDLE1BQU8sTUFBSyxJQUFMLEVBQVAsQ0FDQSxDQUZhLENBQWQsQ0FJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQU0sUUFBUyxNQUFNLEtBQU4sR0FBYyxLQUFkLENBQW9CLEdBQXBCLENBQWYsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQU0sV0FBWSxPQUFPLEtBQVAsRUFBbEIsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQU0sTUFBTyxPQUFPLEtBQVAsRUFBYixDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBTSxPQUFRLE9BQU8sTUFBUCxDQUFjLEtBQWQsQ0FBZCxDQUVBO0FBQ0EsTUFBTyxPQUFNLEdBQU4sQ0FBVSxjQUFRLENBQ3hCLE1BQU8sbUJBQWtCLFNBQWxCLENBQTZCLElBQTdCLENBQW1DLElBQW5DLENBQVAsQ0FDQSxDQUZNLENBQVAsQ0FHQSxDQXJDRCxDQXVDQSxHQUFNLGFBQWMsUUFBZCxZQUFjLENBQVMsTUFBVCxDQUFpQixRQUFqQixDQUEyQixDQUM5QztBQUNBO0FBRUE7QUFDQSxHQUFNLFlBQWEsT0FBTyxLQUFQLENBQWEsR0FBYixDQUFuQixDQUNBO0FBQ0EsR0FBTSxZQUFhLFNBQVMsSUFBVCxDQUFjLEdBQWQsQ0FBbkIsQ0FDQSxHQUFNLGNBQWUsR0FBSSxPQUFKLENBQVcsT0FBUyxVQUFULENBQXNCLFFBQWpDLENBQXJCLENBQ0E7QUFDQSxHQUFJLFNBQVUsRUFBZCxDQUNBO0FBQ0EsV0FBVyxPQUFYLENBQW1CLG1CQUFhLENBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBTSxRQUFTLFVBQVUsS0FBVixDQUFnQixZQUFoQixDQUFmLENBQ0EsR0FBSSxNQUFKLENBQVksQ0FDWDtBQUNBLFFBQVUsUUFBUSxNQUFSLENBQWUsZUFBZSxPQUFPLENBQVAsQ0FBZixDQUFmLENBQVYsQ0FDQSxDQUNELENBVkQsRUFXQSxNQUFPLFFBQVAsQ0FDQSxDQXhCRCxDQTBCQSxHQUFNLHdCQUF5QixRQUF6Qix1QkFBeUIsQ0FBUyxZQUFULENBQXVCLENBQ3JEO0FBQ0E7QUFDQSxHQUFNLE1BQU8sRUFBYixDQUNBLE1BQU8sY0FBYSxNQUFiLENBQW9CLHFCQUFlLENBQ3pDLEdBQUksS0FBSyxZQUFZLElBQWpCLENBQUosQ0FBNEIsQ0FDM0IsTUFBTyxNQUFQLENBQ0EsQ0FDRCxLQUFLLFlBQVksSUFBakIsRUFBeUIsSUFBekIsQ0FDQSxNQUFPLEtBQVAsQ0FDQSxDQU5NLENBQVAsQ0FPQSxDQVhELENBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0JBLE9BQU8sT0FBUCxDQUFpQixVQUF3QyxJQUEvQixRQUErQiwyREFBckIsRUFBcUIsSUFBakIsV0FBaUIsMkRBQUosRUFBSSxDQUN4RDtBQUNBLEdBQUksUUFBUSxNQUFSLEdBQW1CLENBQW5CLEVBQXdCLFdBQVcsTUFBWCxHQUFzQixDQUFsRCxDQUFxRCxDQUNwRCxNQUFPLEVBQVAsQ0FDQSxDQUNELFFBQVUsTUFBTSxPQUFOLENBQWMsT0FBZCxFQUF5QixPQUF6QixDQUFtQyxDQUFDLE9BQUQsQ0FBN0MsQ0FDQSxXQUFhLE1BQU0sT0FBTixDQUFjLFVBQWQsRUFBNEIsVUFBNUIsQ0FBeUMsQ0FBQyxVQUFELENBQXRELENBQ0E7QUFDQSxHQUFJLGNBQWUsRUFBbkIsQ0FDQSxRQUFRLE9BQVIsQ0FBZ0IsZ0JBQVUsQ0FDekI7QUFDQSxPQUFTLGNBQWMsTUFBZCxDQUFULENBQ0E7QUFDQSxPQUFTLFdBQVcsTUFBWCxDQUFULENBQ0E7QUFDQSxPQUFTLGVBQWUsTUFBZixDQUFULENBQ0E7QUFDQSxPQUFTLG9CQUFvQixNQUFwQixDQUFULENBQ0E7QUFDQSxhQUFlLGFBQWEsTUFBYixDQUFvQixZQUFZLE1BQVosQ0FBb0IsVUFBcEIsQ0FBcEIsQ0FBZixDQUNBLENBWEQsRUFZQTtBQUNBLE1BQU8sd0JBQXVCLFlBQXZCLENBQVAsQ0FDQSxDQXZCRDs7O0FDckpBLGEsK29CQUVBLEdBQU0sU0FBVSxhQUFoQixDQUVBLEdBQU0sY0FBZSxZQUFyQixDQUNBLEdBQU0sYUFBYyxXQUFwQixDQUNBLEdBQU0sVUFBVyxRQUFqQixDQUNBLEdBQU0sYUFBYyxXQUFwQixDQUNBLEdBQU0sY0FBZSxZQUFyQixDQUNBLEdBQU0sWUFBYSxVQUFuQixDQUNBLEdBQU0sWUFBYSxVQUFuQixDQUNBLEdBQU0sYUFBYyxXQUFwQixDQUVBLEdBQU0sb0JBQXFCLDZCQUEzQixDQUNBLEdBQU0sbUJBQW9CLGlCQUExQixDQUNBLEdBQU0sZ0JBQWlCLDREQUF2QixDQUNBLEdBQU0sbUJBQW9CLGlCQUExQixDQUNBLEdBQU0sb0JBQXFCLGtCQUEzQixDQUNBLEdBQU0sa0JBQW1CLDhEQUF6QixDQUNBLEdBQU0saUJBQWtCLGlDQUF4QixDQUVBLEdBQU0sUUFBUyxRQUFULE9BQVMsQ0FBUyxDQUFULENBQVksS0FBWixDQUFtQixDQUFuQixDQUFzQixDQUNwQyxHQUFJLFFBQVUsU0FBZCxDQUF5QixDQUN4QixHQUFJLEVBQUUsQ0FBRixJQUFTLEdBQWIsQ0FBa0IsQ0FDakIsTUFBTyxFQUFFLElBQU0sTUFBTixFQUFnQixHQUFLLENBQXZCLENBQVAsQ0FDQSxDQUNELE1BQU8sS0FBTSxNQUFOLEVBQWdCLEdBQUssQ0FBNUIsQ0FDQSxDQUNELE9BQVEsS0FBUixFQUNDLElBQUssSUFBTCxDQUNDLE1BQU8sS0FBTSxDQUFiLENBQ0QsSUFBSyxJQUFMLENBQ0MsTUFBTyxLQUFNLENBQWIsQ0FDRCxJQUFLLEdBQUwsQ0FDQyxNQUFPLEdBQUksQ0FBWCxDQUNELElBQUssSUFBTCxDQUNDLE1BQU8sSUFBSyxDQUFaLENBQ0QsSUFBSyxHQUFMLENBQ0MsTUFBTyxHQUFJLENBQVgsQ0FDRCxJQUFLLElBQUwsQ0FDQyxNQUFPLElBQUssQ0FBWixDQVpGLENBY0EsdUNBQXlDLEtBQXpDLEtBQ0EsQ0F0QkQsQyxHQXdCTSxZLFlBQ0wscUJBQVksSUFBWixDQUFrQixXQUFsQixDQUErQixtQ0FDOUIsS0FBSyxJQUFMLENBQVksSUFBWixDQUNBLEtBQUssV0FBTCxDQUFtQixZQUFZLElBQVosRUFBbkIsQ0FDQSxLQUFLLElBQUwsQ0FBWSxFQUFaLENBQ0EsS0FBSyxRQUFMLENBQWdCLEVBQWhCLENBQ0EsQyw0REFDTSxDQUNOLEdBQUksY0FBSixDQUNBLE9BQVEsS0FBSyxJQUFiLEVBQ0MsSUFBSyxJQUFMLENBQ0MsT0FBUyxlQUFlLElBQWYsQ0FBb0IsS0FBSyxXQUF6QixDQUFULENBQ0EsTUFBTyxRQUFPLE9BQU8sQ0FBUCxDQUFQLENBQWtCLE9BQU8sQ0FBUCxDQUFsQixDQUE2QixPQUFPLENBQVAsQ0FBN0IsQ0FBUCxDQUNELElBQUssT0FBTCxDQUNDLE9BQVMsa0JBQWtCLElBQWxCLENBQXVCLEtBQUssV0FBNUIsQ0FBVCxDQUNBLE1BQU8sUUFBTyxDQUFQLElBQWMsT0FBckIsQ0FDRCxJQUFLLFFBQUwsQ0FDQyxPQUFTLG1CQUFtQixJQUFuQixDQUF3QixLQUFLLFdBQTdCLENBQVQsQ0FDQSxNQUFPLFFBQU8sQ0FBUCxJQUFjLE9BQXJCLENBQ0QsSUFBSyxNQUFMLENBQ0MsT0FBUyxpQkFBaUIsSUFBakIsQ0FBc0IsS0FBSyxXQUEzQixDQUFULENBQ0EsTUFBTyxRQUFPLE9BQU8sQ0FBUCxDQUFQLENBQWtCLE9BQU8sQ0FBUCxDQUFsQixDQUE2QixPQUFPLENBQVAsQ0FBN0IsQ0FBUCxDQVpGLENBY0EsdUNBQXlDLEtBQUssSUFBOUMsS0FDQSxDLDhCQUdJLE0sWUFDTCxlQUFZLElBQVosQ0FBa0IsV0FBbEIsQ0FBK0IsT0FBL0IsQ0FBd0MsNkJBQ3ZDLEtBQUssRUFBTCxDQUFVLEdBQUksWUFBSixDQUFnQixJQUFoQixDQUFzQixXQUF0QixDQUFWLENBQ0EsS0FBSyxJQUFMLENBQVksRUFBWixDQUNBLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxLQUFLLE1BQUwsQ0FBYyxJQUFkLENBQ0EsS0FBSyxPQUFMLENBQWUsS0FBSyxFQUFwQixDQUNBLEtBQUssU0FBTCxDQUFpQixPQUFqQixDQUNBLEtBQUssT0FBTCxDQUFlLElBQWYsQ0FDQSxDLDBEQUNPLFcsQ0FBYSxDQUNwQixLQUFLLE9BQUwsQ0FBZSxHQUFJLFlBQUosQ0FBZ0IsTUFBaEIsQ0FBd0IsV0FBeEIsQ0FBZixDQUNBLEtBQUssSUFBTCxDQUFZLEtBQUssT0FBakIsQ0FDQSxDLHdDQUNPLFcsQ0FBYSxDQUNwQixLQUFLLE9BQUwsQ0FBZSxHQUFJLFlBQUosQ0FBZ0IsTUFBaEIsQ0FBd0IsV0FBeEIsQ0FBZixDQUNBLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBZSxLQUFLLE9BQXBCLEVBQ0EsQyx3Q0FDTyxJLENBQU0sTyxDQUFTLENBQ3RCLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEIsQ0FBdUIsQ0FDdEIsT0FBUSxLQUFLLElBQUwsRUFEYyxDQUV0QixLQUFNLE9BRmdCLENBQXZCLEVBSUEsQyxrQ0FDSSxLLENBQU8sQ0FDWCxNQUFNLE1BQU4sQ0FBZSxJQUFmLENBQ0EsS0FBSyxPQUFMLENBQWEsUUFBYixDQUFzQixJQUF0QixDQUEyQixLQUEzQixFQUNBLEMseUNBQ1MsQ0FDVDtBQUNBLEdBQUksTUFBTyxFQUFYLENBQ0EsR0FBSSxLQUFLLEVBQUwsQ0FBUSxJQUFSLEVBQUosQ0FBb0IsQ0FDbkIsS0FBTyxLQUFLLE1BQUwsQ0FBWSxLQUFLLEVBQUwsQ0FBUSxJQUFwQixDQUFQLENBQ0EsS0FBSyxFQUFMLENBQVEsUUFBUixDQUFpQixPQUFqQixDQUF5QixlQUFTLENBQ2pDLEtBQU8sS0FBSyxNQUFMLENBQVksTUFBTSxPQUFOLEVBQVosQ0FBUCxDQUNBLENBRkQsRUFHQSxNQUFPLEtBQVAsQ0FDQSxDQUNEO0FBQ0EsSUFBSyxHQUFJLEdBQUUsQ0FBWCxDQUFjLEVBQUUsS0FBSyxJQUFMLENBQVUsTUFBMUIsQ0FBa0MsR0FBbEMsQ0FBdUMsQ0FDdEMsR0FBTSxNQUFPLEtBQUssSUFBTCxDQUFVLENBQVYsQ0FBYixDQUNBLEdBQUksS0FBSyxJQUFMLEVBQUosQ0FBaUIsQ0FDaEIsS0FBTyxLQUFLLE1BQUwsQ0FBWSxLQUFLLElBQWpCLENBQVAsQ0FDQSxJQUFLLEdBQUksR0FBRSxDQUFYLENBQWMsRUFBRSxLQUFLLFFBQUwsQ0FBYyxNQUE5QixDQUFzQyxHQUF0QyxDQUEyQyxDQUMxQyxHQUFNLE9BQVEsS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUFkLENBQ0EsS0FBTyxLQUFLLE1BQUwsQ0FBWSxNQUFNLE9BQU4sRUFBWixDQUFQLENBQ0EsQ0FDRCxNQUFPLEtBQVAsQ0FDQSxDQUNELENBQ0Q7QUFDQSxHQUFJLEtBQUssSUFBVCxDQUFlLENBQ2QsS0FBTyxLQUFLLE1BQUwsQ0FBWSxLQUFLLElBQUwsQ0FBVSxJQUF0QixDQUFQLENBQ0EsS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixPQUFuQixDQUEyQixlQUFTLENBQ25DLEtBQU8sS0FBSyxNQUFMLENBQVksTUFBTSxPQUFOLEVBQVosQ0FBUCxDQUNBLENBRkQsRUFHQSxNQUFPLEtBQVAsQ0FDQSxDQUNELE1BQU8sRUFBUCxDQUNBLEMsb0NBQ00sQ0FDTjtBQUNBLE1BQU8sTUFBSyxPQUFMLEdBQWUsSUFBZixDQUFvQixTQUFDLENBQUQsQ0FBSSxDQUFKLENBQVUsQ0FDcEMsTUFBTyxHQUFFLElBQUYsQ0FBUyxFQUFFLElBQWxCLENBQ0EsQ0FGTSxFQUVKLEdBRkksQ0FFQSxhQUFPLENBQ2IsTUFBTyxLQUFJLE1BQVgsQ0FDQSxDQUpNLEVBSUosSUFKSSxDQUlDLElBSkQsQ0FBUCxDQUtBLEMscUJBR0YsR0FBTSxZQUFhLFFBQWIsV0FBYSxDQUFTLEtBQVQsQ0FBZ0IsQ0FFbEMsR0FBTSxRQUFTLEVBQWYsQ0FDQSxHQUFJLFNBQVUsSUFBZCxDQUVBLE1BQU0sT0FBTixDQUFjLFNBQUMsSUFBRCxDQUFPLEtBQVAsQ0FBaUIsQ0FFOUIsR0FBSSxLQUFLLEtBQUwsQ0FBVyxRQUFYLENBQUosQ0FBMEIsQ0FDekI7QUFDQSxHQUFNLE9BQVEsR0FBSSxNQUFKLENBQVUsSUFBVixDQUFnQixJQUFoQixDQUFzQixLQUF0QixDQUFkLENBQ0EsR0FBSSxDQUFDLE9BQUwsQ0FBYyxDQUNiLE9BQU8sSUFBUCxDQUFZLEtBQVosRUFDQSxDQUZELElBRU8sQ0FDTixRQUFRLElBQVIsQ0FBYSxLQUFiLEVBQ0EsQ0FDRCxRQUFVLEtBQVYsQ0FFQSxDQVZELElBVU8sSUFBSSxLQUFLLEtBQUwsQ0FBVyxXQUFYLENBQUosQ0FBNkIsQ0FDbkM7QUFDQSxHQUFNLFFBQVEsR0FBSSxNQUFKLENBQVUsT0FBVixDQUFtQixJQUFuQixDQUF5QixLQUF6QixDQUFkLENBQ0EsR0FBSSxDQUFDLE9BQUwsQ0FBYyxDQUNiLE9BQU8sSUFBUCxDQUFZLE1BQVosRUFDQSxDQUZELElBRU8sQ0FDTixRQUFRLElBQVIsQ0FBYSxNQUFiLEVBQ0EsQ0FDRCxRQUFVLE1BQVYsQ0FFQSxDQVZNLElBVUEsSUFBSSxLQUFLLEtBQUwsQ0FBVyxZQUFYLENBQUosQ0FBOEIsQ0FDcEM7QUFDQSxHQUFNLFNBQVEsR0FBSSxNQUFKLENBQVUsUUFBVixDQUFvQixJQUFwQixDQUEwQixLQUExQixDQUFkLENBQ0EsR0FBSSxDQUFDLE9BQUwsQ0FBYyxDQUNiLE9BQU8sSUFBUCxDQUFZLE9BQVosRUFDQSxDQUZELElBRU8sQ0FDTixRQUFRLElBQVIsQ0FBYSxPQUFiLEVBQ0EsQ0FDRCxRQUFVLE9BQVYsQ0FFQSxDQVZNLElBVUEsSUFBSSxLQUFLLEtBQUwsQ0FBVyxVQUFYLENBQUosQ0FBNEIsQ0FDbEM7QUFDQSxHQUFJLENBQUMsT0FBTCxDQUFjLENBQ2IsS0FBTSxpREFBTixDQUNBLENBQ0QsUUFBUSxPQUFSLENBQWdCLElBQWhCLEVBRUEsQ0FQTSxJQU9BLElBQUksS0FBSyxLQUFMLENBQVcsVUFBWCxDQUFKLENBQTRCLENBQ2xDO0FBQ0EsR0FBSSxDQUFDLE9BQUwsQ0FBYyxDQUNiLEtBQU0saURBQU4sQ0FDQSxDQUNELFFBQVEsT0FBUixDQUFnQixJQUFoQixFQUVBLENBUE0sSUFPQSxJQUFJLEtBQUssS0FBTCxDQUFXLFdBQVgsQ0FBSixDQUE2QixDQUNuQztBQUNBLEdBQUksQ0FBQyxPQUFMLENBQWMsQ0FDYixLQUFNLGtEQUFOLENBQ0EsQ0FDRCxRQUFRLE9BQVIsQ0FBa0IsS0FBbEIsQ0FDQSxRQUFVLFFBQVEsTUFBbEIsQ0FFQSxDQVJNLElBUUEsQ0FDTjtBQUNBLEdBQUksT0FBSixDQUFhLENBQ1osUUFBUSxPQUFSLENBQWdCLElBQWhCLENBQXNCLEtBQXRCLEVBQ0EsQ0FDRCxDQUNELENBNURELEVBOERBLEdBQUksT0FBSixDQUFhLENBQ1osS0FBTSx3REFBTixDQUNBLENBRUQsTUFBTyxPQUFQLENBQ0EsQ0F4RUQsQ0EwRUEsR0FBTSxnQkFBaUIsUUFBakIsZUFBaUIsQ0FBUyxLQUFULENBQWdCLENBQ3RDLEdBQU0sU0FBVSxHQUFJLElBQUosRUFBaEIsQ0FDQSxHQUFNLFVBQVcsRUFBakIsQ0FDQSxNQUFNLE9BQU4sQ0FBYyxjQUFRLENBQ3JCLEdBQUksS0FBSyxLQUFMLENBQVcsWUFBWCxDQUFKLENBQThCLENBQzdCO0FBQ0EsR0FBTSxRQUFTLG1CQUFtQixJQUFuQixDQUF3QixJQUF4QixDQUFmLENBQ0EsUUFBUSxHQUFSLENBQVksT0FBTyxDQUFQLENBQVosQ0FBdUIsT0FBTyxDQUFQLEdBQWEsT0FBcEMsRUFFQSxDQUxELElBS08sSUFBSSxLQUFLLEtBQUwsQ0FBVyxXQUFYLENBQUosQ0FBNkIsQ0FDbkM7QUFDQSxHQUFNLFNBQVMsa0JBQWtCLElBQWxCLENBQXVCLElBQXZCLENBQWYsQ0FDQSxRQUFRLE1BQVIsQ0FBZSxRQUFPLENBQVAsQ0FBZixFQUVBLENBTE0sSUFLQSxJQUFJLEtBQUssS0FBTCxDQUFXLFdBQVgsQ0FBSixDQUE2QixDQUNuQztBQUNBLEdBQU0sVUFBUyxrQkFBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsQ0FBZixDQUNBLEdBQUksUUFBUSxHQUFSLENBQVksU0FBTyxDQUFQLENBQVosQ0FBSixDQUE0QixDQUMzQixLQUFPLEtBQUssT0FBTCxDQUFhLFNBQU8sQ0FBUCxDQUFiLENBQXdCLE9BQXhCLENBQVAsQ0FDQSxDQUNELFNBQVMsSUFBVCxDQUFjLElBQWQsRUFFQSxDQVJNLElBUUEsSUFBSSxLQUFLLEtBQUwsQ0FBVyxZQUFYLENBQUosQ0FBOEIsQ0FDcEM7QUFDQSxHQUFNLFVBQVMsbUJBQW1CLElBQW5CLENBQXdCLElBQXhCLENBQWYsQ0FDQSxHQUFJLFFBQVEsR0FBUixDQUFZLFNBQU8sQ0FBUCxDQUFaLENBQUosQ0FBNEIsQ0FDM0IsS0FBTyxLQUFLLE9BQUwsQ0FBYSxTQUFPLENBQVAsQ0FBYixDQUF3QixPQUF4QixDQUFQLENBQ0EsQ0FDRCxTQUFTLElBQVQsQ0FBYyxJQUFkLEVBRUEsQ0FSTSxJQVFBLENBQ047QUFDQSxRQUFRLE9BQVIsQ0FBZ0IsU0FBQyxHQUFELENBQU0sTUFBTixDQUFpQixDQUNoQyxLQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBcUIsR0FBckIsQ0FBUCxDQUNBLENBRkQsRUFHQSxTQUFTLElBQVQsQ0FBYyxJQUFkLEVBQ0EsQ0FDRCxDQWxDRCxFQW1DQSxNQUFPLFNBQVAsQ0FDQSxDQXZDRCxDQXlDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E4QkEsT0FBTyxPQUFQLENBQWlCLFNBQVMsSUFBVCxDQUFlLENBQy9CO0FBQ0EsR0FBSSxPQUFRLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBWixDQUNBO0FBQ0EsTUFBUSxlQUFlLEtBQWYsQ0FBUixDQUNBO0FBQ0EsR0FBTSxRQUFTLFdBQVcsS0FBWCxDQUFmLENBQ0E7QUFDQSxJQUFLLEdBQUksR0FBRSxPQUFPLE1BQVAsQ0FBZ0IsQ0FBM0IsQ0FBOEIsR0FBRyxDQUFqQyxDQUFvQyxHQUFwQyxDQUF5QyxDQUN4QyxHQUFNLE9BQVEsT0FBTyxDQUFQLENBQWQsQ0FDQSxHQUFNLGFBQWMsTUFBTSxJQUFOLEVBQXBCLENBQ0EsR0FBSSxZQUFZLE1BQVosQ0FBcUIsQ0FBekIsQ0FBNEIsQ0FDM0IsTUFBTSxNQUFOLENBQWEsTUFBTSxTQUFuQixDQUE4QixNQUFNLE9BQU4sQ0FBZ0IsTUFBTSxTQUF0QixDQUFrQyxDQUFoRSxDQUFtRSxXQUFuRSxFQUNBLENBRkQsSUFFTyxDQUNOLE1BQU0sTUFBTixDQUFhLE1BQU0sU0FBbkIsQ0FBOEIsTUFBTSxPQUFOLENBQWdCLE1BQU0sU0FBdEIsQ0FBa0MsQ0FBaEUsRUFDQSxDQUNELENBQ0Q7QUFDQSxNQUFPLE9BQU0sSUFBTixDQUFXLElBQVgsRUFBaUIsT0FBakIsQ0FBeUIsZUFBekIsQ0FBMEMsRUFBMUMsQ0FBUCxDQUNBLENBbkJEOzs7QUMvUkEsYSwrb0JBRUEsR0FBTSxXQUFZLFFBQVEsa0JBQVIsQ0FBbEIsQ0FFQTs7TUFHTSxRLFlBRUw7Ozs7Ozs7Ozs7Ozs7O0lBZUEsaUJBQVksRUFBWixDQUEwQyxJQUExQixJQUEwQiwyREFBcEIsSUFBb0IsSUFBZCxRQUFjLDJEQUFKLEVBQUksK0JBQ3pDLEtBQUssRUFBTCxDQUFVLEVBQVYsQ0FDQSxLQUFLLE9BQUwsQ0FBZSxHQUFHLGFBQUgsRUFBZixDQUNBO0FBQ0EsS0FBSyxNQUFMLENBQWMsVUFBVSxRQUFRLE1BQWxCLENBQTBCLE1BQTFCLENBQWQsQ0FDQSxLQUFLLElBQUwsQ0FBWSxVQUFVLFFBQVEsSUFBbEIsQ0FBd0IsZUFBeEIsQ0FBWixDQUNBLEtBQUssTUFBTCxDQUFjLFVBQVUsUUFBUSxNQUFsQixDQUEwQixRQUExQixDQUFkLENBQ0EsS0FBSyxJQUFMLENBQVksVUFBVSxRQUFRLElBQWxCLENBQXdCLGVBQXhCLENBQVosQ0FDQSxLQUFLLE9BQUwsQ0FBZSxVQUFVLFFBQVEsT0FBbEIsQ0FBMkIsS0FBM0IsQ0FBZixDQUNBLEtBQUssZ0JBQUwsQ0FBd0IsVUFBVSxRQUFRLGdCQUFsQixDQUFvQyxLQUFwQyxDQUF4QixDQUNBO0FBQ0EsS0FBSyxVQUFMLENBQWdCLEdBQWhCLENBQXFCLFFBQVEsS0FBN0IsQ0FBb0MsUUFBUSxNQUE1QyxFQUNBO0FBQ0EsR0FBRyxhQUFILENBQWlCLEdBQUcsVUFBcEIsQ0FBZ0MsR0FBRyxjQUFuQyxDQUFtRCxHQUFHLEtBQUssSUFBUixDQUFuRCxFQUNBLEdBQUcsYUFBSCxDQUFpQixHQUFHLFVBQXBCLENBQWdDLEdBQUcsY0FBbkMsQ0FBbUQsR0FBRyxLQUFLLElBQVIsQ0FBbkQsRUFDQSxHQUFHLGFBQUgsQ0FBaUIsR0FBRyxVQUFwQixDQUFnQyxHQUFHLGtCQUFuQyxDQUF1RCxHQUFHLEtBQUssTUFBUixDQUF2RCxFQUNBLEdBQUcsYUFBSCxDQUFpQixHQUFHLFVBQXBCLENBQWdDLEdBQUcsa0JBQW5DLENBQXVELEdBQUcsS0FBSyxNQUFSLENBQXZELEVBQ0EsQ0FFRDs7Ozs7OzJEQU9tQixJQUFkLFNBQWMsMkRBQUgsQ0FBRyxDQUNsQixHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBLEdBQUcsYUFBSCxDQUFpQixhQUFhLFFBQWIsQ0FBakIsRUFDQSxHQUFHLFdBQUgsQ0FBZSxHQUFHLFVBQWxCLENBQThCLEtBQUssT0FBbkMsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7OzJDQUtTLENBQ1IsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFHLFdBQUgsQ0FBZSxHQUFHLFVBQWxCLENBQThCLElBQTlCLEVBQ0EsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozs7Ozs7a0RBU1csSSxDQUFNLEssQ0FBTyxNLENBQVEsQ0FDL0IsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQTtBQUNBLEdBQUcsV0FBSCxDQUFlLEdBQUcsVUFBbEIsQ0FBOEIsS0FBSyxPQUFuQyxFQUNBLEdBQUcsV0FBSCxDQUFlLEdBQUcsbUJBQWxCLENBQXVDLEtBQUssT0FBNUMsRUFDQSxHQUFHLFdBQUgsQ0FBZSxHQUFHLDhCQUFsQixDQUFrRCxLQUFLLGdCQUF2RCxFQUNBO0FBQ0EsR0FBSSxNQUFRLEtBQUssS0FBYixFQUFzQixLQUFLLE1BQS9CLENBQXVDLENBQ3RDO0FBQ0EsS0FBSyxLQUFMLENBQWEsS0FBSyxLQUFsQixDQUNBLEtBQUssTUFBTCxDQUFjLEtBQUssTUFBbkIsQ0FDQTtBQUNBLEdBQUcsVUFBSCxDQUNDLEdBQUcsVUFESixDQUVDLENBRkQsQ0FFSTtBQUNILEdBQUcsS0FBSyxNQUFSLENBSEQsQ0FHa0I7QUFDakIsR0FBRyxLQUFLLE1BQVIsQ0FKRCxDQUtDLEdBQUcsS0FBSyxJQUFSLENBTEQsQ0FNQyxJQU5ELEVBT0EsQ0FaRCxJQVlPLENBQ047QUFDQSxLQUFLLEtBQUwsQ0FBYSxPQUFTLEtBQUssS0FBM0IsQ0FDQSxLQUFLLE1BQUwsQ0FBYyxRQUFVLEtBQUssTUFBN0IsQ0FDQTtBQUNBLEdBQUcsVUFBSCxDQUNDLEdBQUcsVUFESixDQUVDLENBRkQsQ0FFSTtBQUNILEdBQUcsS0FBSyxNQUFSLENBSEQsQ0FHa0I7QUFDakIsS0FBSyxLQUpOLENBS0MsS0FBSyxNQUxOLENBTUMsQ0FORCxDQU1JO0FBQ0gsR0FBRyxLQUFLLE1BQVIsQ0FQRCxDQVFDLEdBQUcsS0FBSyxJQUFSLENBUkQsQ0FTQyxJQVRELEVBVUEsQ0FDRCxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7Ozs7Ozs7O3dEQVdjLEksQ0FBdUUsSUFBakUsUUFBaUUsMkRBQXZELENBQXVELElBQXBELFFBQW9ELDJEQUExQyxDQUEwQyxJQUF2QyxNQUF1QywyREFBL0IsU0FBK0IsSUFBcEIsT0FBb0IsMkRBQVgsU0FBVyxDQUNwRixHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBO0FBQ0EsR0FBRyxXQUFILENBQWUsR0FBRyxVQUFsQixDQUE4QixLQUFLLE9BQW5DLEVBQ0EsR0FBRyxXQUFILENBQWUsR0FBRyxtQkFBbEIsQ0FBdUMsS0FBSyxPQUE1QyxFQUNBLEdBQUcsV0FBSCxDQUFlLEdBQUcsOEJBQWxCLENBQWtELEtBQUssZ0JBQXZELEVBQ0E7QUFDQSxHQUFJLEtBQUssS0FBTCxFQUFjLEtBQUssTUFBdkIsQ0FBK0IsQ0FDOUI7QUFDQSxHQUFHLGFBQUgsQ0FDQyxHQUFHLFVBREosQ0FFQyxDQUZELENBRUk7QUFDSCxPQUhELENBSUMsT0FKRCxDQUtDLEdBQUcsS0FBSyxNQUFSLENBTEQsQ0FNQyxHQUFHLEtBQUssSUFBUixDQU5ELENBT0MsSUFQRCxFQVFBLENBVkQsSUFVTyxDQUNOO0FBQ0EsR0FBRyxhQUFILENBQ0MsR0FBRyxVQURKLENBRUMsQ0FGRCxDQUVJO0FBQ0gsT0FIRCxDQUlDLE9BSkQsQ0FLQyxLQUxELENBTUMsTUFORCxDQU9DLEdBQUcsS0FBSyxNQUFSLENBUEQsQ0FRQyxHQUFHLEtBQUssSUFBUixDQVJELENBU0MsSUFURCxFQVVBLENBQ0QsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozs7OzswQ0FRTyxLLENBQU8sTSxDQUFRLENBQ3JCLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFzQixLQUF0QixDQUE2QixNQUE3QixFQUNBLE1BQU8sS0FBUCxDQUNBLEMsdUJBR0YsT0FBTyxPQUFQLENBQWlCLE9BQWpCOzs7QUM3S0EsYSwrb0JBRUEsR0FBTSxXQUFZLFFBQVEsa0JBQVIsQ0FBbEIsQ0FFQTtBQUVBLEdBQU0sZUFBZ0IsUUFBaEIsY0FBZ0IsQ0FBUyxFQUFULENBQWEsTUFBYixDQUFxQixJQUFyQixDQUEyQixJQUEzQixDQUFpQyxNQUFqQyxDQUF5QyxJQUF6QyxDQUErQyxPQUEvQyxDQUF3RCxnQkFBeEQsQ0FBMEUsQ0FDL0YsR0FBTSxTQUFVLEdBQUcsYUFBSCxFQUFoQixDQUNBLEdBQUcsV0FBSCxDQUFlLEdBQUcsVUFBbEIsQ0FBOEIsT0FBOUIsRUFDQSxHQUFHLFdBQUgsQ0FBZSxHQUFHLG1CQUFsQixDQUF1QyxPQUF2QyxFQUNBLEdBQUcsV0FBSCxDQUFlLEdBQUcsOEJBQWxCLENBQWtELGdCQUFsRCxFQUNBO0FBQ0EsR0FBRyxVQUFILENBQ0MsR0FBRyxVQURKLENBRUMsQ0FGRCxDQUVJO0FBQ0gsR0FBRyxNQUFILENBSEQsQ0FHYTtBQUNaLElBSkQsQ0FLQyxJQUxELENBTUMsQ0FORCxDQU1JO0FBQ0gsR0FBRyxNQUFILENBUEQsQ0FRQyxHQUFHLElBQUgsQ0FSRCxDQVNDLElBVEQsRUFVQTtBQUNBLEdBQUcsYUFBSCxDQUFpQixHQUFHLFVBQXBCLENBQWdDLEdBQUcsY0FBbkMsQ0FBbUQsR0FBRyxJQUFILENBQW5ELEVBQ0EsR0FBRyxhQUFILENBQWlCLEdBQUcsVUFBcEIsQ0FBZ0MsR0FBRyxjQUFuQyxDQUFtRCxHQUFHLElBQUgsQ0FBbkQsRUFDQSxHQUFHLGFBQUgsQ0FBaUIsR0FBRyxVQUFwQixDQUFnQyxHQUFHLGtCQUFuQyxDQUF1RCxHQUFHLE1BQUgsQ0FBdkQsRUFDQSxHQUFHLGFBQUgsQ0FBaUIsR0FBRyxVQUFwQixDQUFnQyxHQUFHLGtCQUFuQyxDQUF1RCxHQUFHLE1BQUgsQ0FBdkQsRUFDQSxNQUFPLFFBQVAsQ0FDQSxDQXRCRCxDQXdCQTs7TUFHTSxhLFlBRUw7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF1QkEsc0JBQVksRUFBWixDQUEyQyxJQUEzQixPQUEyQiwyREFBbEIsRUFBa0IsSUFBZCxRQUFjLDJEQUFKLEVBQUksb0NBQzFDLEtBQUssRUFBTCxDQUFVLEVBQVYsQ0FDQTtBQUNBLEtBQUssU0FBTCxDQUFpQixVQUFVLFFBQVEsU0FBbEIsQ0FBNkIsR0FBN0IsQ0FBakIsQ0FDQSxLQUFLLFNBQUwsQ0FBaUIsVUFBVSxRQUFRLFNBQWxCLENBQTZCLEdBQTdCLENBQWpCLENBQ0E7QUFDQSxLQUFLLE1BQUwsQ0FBYyxVQUFVLE9BQU8sTUFBakIsQ0FBeUIsTUFBekIsQ0FBZCxDQUNBLEtBQUssSUFBTCxDQUFZLFVBQVUsT0FBTyxJQUFqQixDQUF1QixlQUF2QixDQUFaLENBQ0EsS0FBSyxNQUFMLENBQWMsVUFBVSxPQUFPLE1BQWpCLENBQXlCLFFBQXpCLENBQWQsQ0FDQSxLQUFLLElBQUwsQ0FBWSxVQUFVLE9BQU8sSUFBakIsQ0FBdUIsZUFBdkIsQ0FBWixDQUNBLEtBQUssT0FBTCxDQUFlLFVBQVUsT0FBTyxPQUFqQixDQUEwQixLQUExQixDQUFmLENBQ0EsS0FBSyxnQkFBTCxDQUF3QixVQUFVLE9BQU8sZ0JBQWpCLENBQW1DLEtBQW5DLENBQXhCLENBQ0E7QUFDQSxLQUFLLFNBQUwsQ0FBaUIsR0FBSSxNQUFKLENBQVUsS0FBSyxTQUFmLENBQWpCLENBQ0EsSUFBSyxHQUFJLEdBQUUsQ0FBWCxDQUFjLEVBQUUsS0FBSyxTQUFyQixDQUFnQyxHQUFoQyxDQUFxQyxDQUNwQyxLQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQW9CLENBQ25CLFFBQVMsY0FDUixLQUFLLEVBREcsQ0FFUixLQUFLLE1BRkcsQ0FHUixLQUFLLFNBSEcsQ0FJUixLQUFLLElBSkcsQ0FLUixLQUFLLE1BTEcsQ0FNUixLQUFLLElBTkcsQ0FPUixLQUFLLE9BUEcsQ0FRUixLQUFLLGdCQVJHLENBRFUsQ0FBcEIsQ0FXQSxDQUNEO0FBQ0EsS0FBSyxJQUFMLENBQVksR0FBSSxJQUFKLEVBQVosQ0FDQSxDQUVEOzs7Ozs7NkRBT0ksRyxDQUFLLENBQ1IsTUFBTyxNQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZCxDQUFQLENBQ0EsQ0FFRDs7Ozs7OztvQ0FRSSxHLENBQUssQ0FDUixNQUFPLE1BQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkLENBQVAsQ0FDQSxDQUVEOzs7OztvQ0FNSSxHLENBQUssSSxDQUFNLENBQ2QsR0FBSSxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQUosQ0FBbUIsQ0FDbEIsc0JBQXVCLEdBQXZCLGdDQUNBLENBQ0QsR0FBSSxLQUFLLFNBQUwsQ0FBZSxNQUFmLEdBQTBCLENBQTlCLENBQWlDLENBQ2hDLEtBQU0sc0NBQU4sQ0FDQSxDQUNEO0FBQ0EsR0FBTSxPQUFRLEtBQUssU0FBTCxDQUFlLEdBQWYsRUFBZCxDQUNBO0FBQ0EsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFHLFdBQUgsQ0FBZSxHQUFHLFVBQWxCLENBQThCLE1BQU0sT0FBcEMsRUFDQSxHQUFHLFdBQUgsQ0FBZSxHQUFHLG1CQUFsQixDQUF1QyxLQUFLLE9BQTVDLEVBQ0EsR0FBRyxXQUFILENBQWUsR0FBRyw4QkFBbEIsQ0FBa0QsS0FBSyxnQkFBdkQsRUFDQSxHQUFJLEtBQUssS0FBTCxFQUFjLEtBQUssTUFBdkIsQ0FBK0IsQ0FDOUI7QUFDQSxHQUFHLFVBQUgsQ0FDQyxHQUFHLFVBREosQ0FFQyxDQUZELENBRUk7QUFDSCxHQUFHLEtBQUssTUFBUixDQUhELENBR2tCO0FBQ2pCLEdBQUcsS0FBSyxNQUFSLENBSkQsQ0FLQyxHQUFHLEtBQUssSUFBUixDQUxELENBTUMsSUFORCxFQU9BLENBVEQsSUFTTyxDQUNOO0FBQ0EsR0FBRyxVQUFILENBQ0MsR0FBRyxVQURKLENBRUMsQ0FGRCxDQUVJO0FBQ0gsR0FBRyxLQUFLLE1BQVIsQ0FIRCxDQUdrQjtBQUNqQixLQUFLLFNBSk4sQ0FLQyxLQUFLLFNBTE4sQ0FNQyxDQU5ELENBTUk7QUFDSCxHQUFHLEtBQUssTUFBUixDQVBELENBUUMsR0FBRyxLQUFLLElBQVIsQ0FSRCxDQVNDLElBVEQsRUFVQSxDQUNEO0FBQ0EsS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQsQ0FBbUIsS0FBbkIsRUFDQSxDQUVEOzs7Ozs7MkNBT08sRyxDQUFLLENBQ1gsR0FBSSxDQUFDLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBTCxDQUFvQixDQUNuQixzQkFBdUIsR0FBdkIsZ0NBQ0EsQ0FDRDtBQUNBLEdBQU0sT0FBUSxLQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZCxDQUFkLENBQ0E7QUFDQSxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQWlCLEdBQWpCLEVBQ0E7QUFDQSxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLEtBQXBCLEVBQ0EsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozs7OztzQ0FRSyxHLENBQW1CLElBQWQsU0FBYywyREFBSCxDQUFHLENBQ3ZCLEdBQUksQ0FBQyxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQUwsQ0FBb0IsQ0FDbkIsc0JBQXVCLEdBQXZCLGdDQUNBLENBQ0QsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFNLE9BQVEsS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQsQ0FBZCxDQUNBLEdBQUcsYUFBSCxDQUFpQixhQUFhLFFBQWIsQ0FBakIsRUFDQSxHQUFHLFdBQUgsQ0FBZSxHQUFHLFVBQWxCLENBQThCLE1BQU0sT0FBcEMsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7OzJDQUtTLENBQ1I7QUFDQSxNQUFPLEtBQVAsQ0FDQSxDLDRCQUdGLE9BQU8sT0FBUCxDQUFpQixZQUFqQjs7O0FDaE5BLGEsK29CQUVBLEdBQU0sV0FBWSxRQUFRLGtCQUFSLENBQWxCLENBRUE7O01BR00sWSxZQUVMOzs7Ozs7Ozs7O0lBV0EscUJBQVksRUFBWixDQUFnQixHQUFoQixDQUFtQyxJQUFkLFFBQWMsMkRBQUosRUFBSSxtQ0FDbEMsS0FBSyxFQUFMLENBQVUsRUFBVixDQUNBLEtBQUssSUFBTCxDQUFZLFVBQVUsUUFBUSxJQUFsQixDQUF3QixnQkFBeEIsQ0FBWixDQUNBLEtBQUssSUFBTCxDQUFZLFVBQVUsUUFBUSxJQUFsQixDQUF3QixXQUF4QixDQUFaLENBQ0EsS0FBSyxLQUFMLENBQWEsVUFBVSxRQUFRLEtBQWxCLENBQXlCLENBQXpCLENBQWIsQ0FDQSxLQUFLLFVBQUwsQ0FBa0IsVUFBVSxRQUFRLFVBQWxCLENBQThCLENBQTlCLENBQWxCLENBQ0E7QUFDQSxHQUFJLGNBQWUsWUFBbkIsQ0FBZ0MsQ0FDL0IsS0FBSyxNQUFMLENBQWMsR0FBZCxDQUNBLENBRkQsSUFFTyxDQUNOLEtBQUssTUFBTCxDQUFjLEdBQUcsWUFBSCxFQUFkLENBQ0EsR0FBSSxHQUFKLENBQVMsQ0FDUjtBQUNBLEtBQUssVUFBTCxDQUFnQixHQUFoQixFQUNBLENBQ0QsQ0FDRCxDQUVEOzs7Ozs7MEVBT1csRyxDQUFLLENBQ2YsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFHLFVBQUgsQ0FBYyxHQUFHLG9CQUFqQixDQUF1QyxLQUFLLE1BQTVDLEVBQ0EsR0FBRyxVQUFILENBQWMsR0FBRyxvQkFBakIsQ0FBdUMsR0FBdkMsQ0FBNEMsR0FBRyxXQUEvQyxFQUNBLENBRUQ7Ozs7Ozs7d0RBUWMsSyxDQUF1QixJQUFoQixXQUFnQiwyREFBSCxDQUFHLENBQ3BDLEdBQU0sSUFBSyxLQUFLLEVBQWhCLENBQ0EsR0FBRyxVQUFILENBQWMsR0FBRyxvQkFBakIsQ0FBdUMsS0FBSyxNQUE1QyxFQUNBLEdBQUcsYUFBSCxDQUFpQixHQUFHLG9CQUFwQixDQUEwQyxVQUExQyxDQUFzRCxLQUF0RCxFQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7dUNBS08sQ0FDTixHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBLEdBQUcsVUFBSCxDQUFjLEdBQUcsb0JBQWpCLENBQXVDLEtBQUssTUFBNUMsRUFDQSxHQUFHLFlBQUgsQ0FBZ0IsR0FBRyxLQUFLLElBQVIsQ0FBaEIsQ0FBK0IsS0FBSyxLQUFwQyxDQUEyQyxHQUFHLEtBQUssSUFBUixDQUEzQyxDQUEwRCxLQUFLLFVBQS9ELEVBQ0E7QUFDQSxNQUFPLEtBQVAsQ0FDQSxDLDJCQUdGLE9BQU8sT0FBUCxDQUFpQixXQUFqQjs7O0FDaEZBLGEsK29CQUVBLEdBQU0sV0FBWSxRQUFRLGtCQUFSLENBQWxCLENBQ0EsR0FBTSxPQUFRLFFBQVEsY0FBUixDQUFkLENBRUE7QUFFQSxHQUFNLGdCQUFpQixDQUN0QixLQUFNLENBRGdCLENBRXRCLGNBQWUsQ0FGTyxDQUd0QixNQUFPLENBSGUsQ0FJdEIsZUFBZ0IsQ0FKTSxDQUt0QixNQUFPLENBTGUsQ0FNdEIsTUFBTyxDQU5lLENBQXZCLENBU0E7QUFFQSxHQUFNLG1CQUFvQixRQUFwQixrQkFBb0IsQ0FBUyxRQUFULENBQW1CLFNBQW5CLENBQThCLENBQ3ZELEdBQUksVUFBVyxDQUFmLENBQ0EsU0FBUyxPQUFULENBQWlCLGlCQUFXLENBQzNCLFVBQVksZUFBZSxRQUFRLElBQXZCLEVBQStCLFFBQVEsSUFBdkMsQ0FBOEMsU0FBMUQsQ0FDQSxDQUZELEVBR0EsTUFBTyxTQUFQLENBQ0EsQ0FORCxDQVFBLEdBQU0saUJBQWtCLFFBQWxCLGdCQUFrQixDQUFTLEtBQVQsQ0FBZ0IsUUFBaEIsQ0FBMEIsZUFBMUIsQ0FBMkMsQ0FDbEUsR0FBSSxZQUFhLENBQWpCLENBQ0EsU0FBUyxPQUFULENBQWlCLFNBQUMsT0FBRCxDQUFVLFFBQVYsQ0FBdUIsQ0FDdkMsTUFBTSxXQUFOLENBQWtCLFFBQWxCLEVBQThCLGdCQUFrQixVQUFoRCxDQUNBLFlBQWMsZUFBZSxRQUFRLElBQXZCLEVBQStCLFFBQVEsSUFBckQsQ0FDQSxDQUhELEVBSUEsQ0FORCxDQVFBLEdBQU0sWUFBYSxRQUFiLFdBQWEsQ0FBUyxRQUFULENBQW1CLENBQ3JDLEdBQUksUUFBUyxDQUFiLENBQ0EsU0FBUyxPQUFULENBQWlCLGlCQUFXLENBQzNCLFFBQVUsUUFBUSxJQUFsQixDQUNBLENBRkQsRUFHQSxNQUFPLE9BQVAsQ0FDQSxDQU5ELENBUUEsR0FBTSx3QkFBeUIsUUFBekIsdUJBQXlCLENBQVMsUUFBVCxDQUFtQixDQUNqRCxHQUFNLG1CQUFvQixHQUFJLElBQUosRUFBMUIsQ0FDQSxHQUFJLFlBQWEsQ0FBakIsQ0FDQTtBQUNBLE1BQU0sUUFBTixDQUFnQixTQUFDLE9BQUQsQ0FBVSxLQUFWLENBQW9CLENBQ25DLGtCQUFrQixHQUFsQixDQUFzQixLQUF0QixDQUE2QixDQUM1QixLQUFNLFFBQVEsSUFEYyxDQUU1QixLQUFNLFFBQVEsSUFGYyxDQUc1QixXQUFZLFVBSGdCLENBSTVCLFdBQVksQ0FKZ0IsQ0FBN0IsRUFNQSxZQUFjLGVBQWUsUUFBUSxJQUF2QixFQUErQixRQUFRLElBQXJELENBQ0EsQ0FSRCxFQVNBO0FBQ0Esa0JBQWtCLE9BQWxCLENBQTBCLGlCQUFXLENBQ3BDLFFBQVEsVUFBUixDQUFxQixVQUFyQixDQUNBLENBRkQsRUFHQSxNQUFPLGtCQUFQLENBQ0EsQ0FsQkQsQ0FvQkE7O01BR00sWSxZQUVMOzs7Ozs7Ozs7SUFVQSxxQkFBWSxFQUFaLENBQWdCLFFBQWhCLENBQXdDLElBQWQsUUFBYywyREFBSixFQUFJLG1DQUN2QztBQUNBLEtBQUssRUFBTCxDQUFVLEVBQVYsQ0FDQTtBQUNBLEtBQUssR0FBTCxDQUFXLEdBQUcsWUFBSCxDQUFnQix3QkFBaEIsQ0FBWCxDQUNBLEdBQUksQ0FBQyxLQUFLLEdBQVYsQ0FBZSxDQUNkLEtBQU0seURBQU4sQ0FDQSxDQUNEO0FBQ0EsS0FBSyxTQUFMLENBQWlCLFVBQVUsUUFBUSxTQUFsQixDQUE2QixJQUFNLEdBQW5DLENBQWpCLENBQ0EsS0FBSyxTQUFMLENBQWlCLFVBQVUsUUFBUSxTQUFsQixDQUE2QixHQUE3QixDQUFqQixDQUNBO0FBQ0EsR0FBSSxDQUFDLFFBQUwsQ0FBZSxDQUNkLEtBQU0sZ0NBQU4sQ0FDQSxDQUNELEtBQUssUUFBTCxDQUFnQix1QkFBdUIsUUFBdkIsQ0FBaEIsQ0FDQTtBQUNBLEtBQUssTUFBTCxDQUFjLFdBQVcsS0FBSyxRQUFoQixDQUFkLENBQ0E7QUFDQSxLQUFLLFNBQUwsQ0FBaUIsR0FBSSxNQUFKLENBQVUsS0FBSyxTQUFmLENBQWpCLENBQ0E7QUFDQSxHQUFNLGVBQWdCLGtCQUNyQixLQUFLLFFBRGdCLENBRXJCLEtBQUssU0FGZ0IsQ0FBdEIsQ0FHQTtBQUNBLElBQUssR0FBSSxHQUFFLENBQVgsQ0FBYyxFQUFFLEtBQUssU0FBckIsQ0FBZ0MsR0FBaEMsQ0FBcUMsQ0FDcEMsR0FBTSxhQUFjLEVBQUksS0FBSyxTQUE3QixDQUNBLEdBQU0saUJBQWtCLEVBQUksYUFBNUIsQ0FDQSxHQUFNLFdBQVksQ0FDakIsTUFBTyxDQURVLENBRWpCLFlBQWEsV0FGSSxDQUdqQixnQkFBaUIsZUFIQSxDQUlqQixZQUFhLEVBSkksQ0FBbEIsQ0FNQTtBQUNBO0FBQ0EsZ0JBQ0MsU0FERCxDQUVDLEtBQUssUUFGTixDQUdDLGVBSEQsRUFJQTtBQUNBLEtBQUssU0FBTCxDQUFlLENBQWYsRUFBb0IsU0FBcEIsQ0FDQSxDQUNEO0FBQ0EsS0FBSyxJQUFMLENBQVksR0FBSSxJQUFKLEVBQVosQ0FDQTtBQUNBLEtBQUssTUFBTCxDQUFjLEdBQUcsWUFBSCxFQUFkLENBQ0E7QUFDQSxHQUFNLFVBQVcsY0FBZ0IsS0FBSyxTQUF0QyxDQUNBO0FBQ0EsR0FBRyxVQUFILENBQWMsR0FBRyxZQUFqQixDQUErQixLQUFLLE1BQXBDLEVBQ0EsR0FBRyxVQUFILENBQWMsR0FBRyxZQUFqQixDQUErQixRQUEvQixDQUF5QyxHQUFHLFlBQTVDLEVBQ0EsQ0FFRDs7Ozs7OzREQU9JLEcsQ0FBSyxDQUNSLE1BQU8sTUFBSyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQsQ0FBUCxDQUNBLENBRUQ7Ozs7Ozs7b0NBUUksRyxDQUFLLENBQ1IsTUFBTyxNQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZCxDQUFQLENBQ0EsQ0FFRDs7Ozs7O29DQU9JLEcsQ0FBSyxJLENBQU0sSyxDQUFPLENBQ3JCLEdBQUksS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFKLENBQW1CLENBQ2xCLHNCQUF1QixHQUF2QixnQ0FDQSxDQUNELEdBQUksS0FBSyxTQUFMLENBQWUsTUFBZixHQUEwQixDQUE5QixDQUFpQyxDQUNoQyxLQUFNLHFDQUFOLENBQ0EsQ0FDRCxHQUFJLE1BQVEsS0FBSyxTQUFqQixDQUE0QixDQUMzQixzQkFBdUIsS0FBdkIsdUNBQWtFLEtBQUssU0FBdkUsQ0FDQSxDQUNEO0FBQ0EsR0FBTSxPQUFRLEtBQUssU0FBTCxDQUFlLEdBQWYsRUFBZCxDQUNBO0FBQ0EsTUFBTSxLQUFOLENBQWMsS0FBZCxDQUNBO0FBQ0EsR0FBSSxNQUFRLENBQVosQ0FBZSxDQUNkO0FBQ0EsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFHLFVBQUgsQ0FBYyxHQUFHLFlBQWpCLENBQStCLEtBQUssTUFBcEMsRUFDQSxHQUFHLGFBQUgsQ0FBaUIsR0FBRyxZQUFwQixDQUFrQyxNQUFNLGVBQXhDLENBQXlELElBQXpELEVBQ0EsQ0FDRDtBQUNBLEtBQUssSUFBTCxDQUFVLEdBQVYsQ0FBYyxHQUFkLENBQW1CLEtBQW5CLEVBQ0EsQ0FFRDs7Ozs7OzJDQU9PLEcsQ0FBSyxDQUNYLEdBQUksQ0FBQyxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQUwsQ0FBb0IsQ0FDbkIsc0JBQXVCLEdBQXZCLGdDQUNBLENBQ0Q7QUFDQSxHQUFNLE9BQVEsS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQsQ0FBZCxDQUNBO0FBQ0EsS0FBSyxJQUFMLENBQVUsTUFBVixDQUFpQixHQUFqQixFQUNBO0FBQ0EsS0FBSyxTQUFMLENBQWUsSUFBZixDQUFvQixLQUFwQixFQUNBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7dUNBS08sQ0FDTixHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBO0FBQ0EsR0FBRyxVQUFILENBQWMsR0FBRyxZQUFqQixDQUErQixLQUFLLE1BQXBDLEVBQ0E7QUFDQSxLQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLFNBQUMsT0FBRCxDQUFVLEtBQVYsQ0FBb0IsQ0FDekM7QUFDQSxHQUFHLHVCQUFILENBQTJCLEtBQTNCLEVBQ0E7QUFDQSxHQUFHLG1CQUFILENBQ0MsS0FERCxDQUVDLFFBQVEsSUFGVCxDQUdDLEdBQUcsUUFBUSxJQUFYLENBSEQsQ0FJQyxLQUpELENBS0MsUUFBUSxVQUxULENBTUMsUUFBUSxVQU5ULEVBT0EsQ0FYRCxFQVlBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7O3lEQU1nQixDQUNmLEdBQU0sSUFBSyxLQUFLLEVBQWhCLENBQ0EsR0FBTSxLQUFNLEtBQUssR0FBakIsQ0FDQTtBQUNBLEdBQUcsVUFBSCxDQUFjLEdBQUcsWUFBakIsQ0FBK0IsS0FBSyxNQUFwQyxFQUNBO0FBQ0EsS0FBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixTQUFDLE9BQUQsQ0FBVSxLQUFWLENBQW9CLENBQ3pDO0FBQ0EsR0FBRyx1QkFBSCxDQUEyQixLQUEzQixFQUNBO0FBQ0EsSUFBSSx3QkFBSixDQUE2QixLQUE3QixDQUFvQyxDQUFwQyxFQUNBLENBTEQsRUFNQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7OzJDQUtTLENBQ1IsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQTtBQUNBLEtBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsU0FBQyxPQUFELENBQVUsS0FBVixDQUFvQixDQUN6QztBQUNBLEdBQUcsd0JBQUgsQ0FBNEIsS0FBNUIsRUFDQSxDQUhELEVBSUEsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozs7NkRBTWtCLENBQ2pCLEdBQU0sSUFBSyxLQUFLLEVBQWhCLENBQ0EsR0FBTSxLQUFNLEtBQUssR0FBakIsQ0FDQTtBQUNBLEtBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsU0FBQyxPQUFELENBQVUsS0FBVixDQUFvQixDQUN6QztBQUNBLEdBQUcsd0JBQUgsQ0FBNEIsS0FBNUIsRUFDQTtBQUNBLElBQUksd0JBQUosQ0FBNkIsS0FBN0IsQ0FBb0MsQ0FBcEMsRUFDQSxDQUxELEVBTUEsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozs7Ozs7OztzQ0FXSyxHLENBQUssSSxDQUE2QixJQUF2QixPQUF1QiwyREFBZCxDQUFjLElBQVgsTUFBVywyREFBSCxDQUFHLENBQ3RDLEdBQUksQ0FBQyxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQUwsQ0FBb0IsQ0FDbkIsc0JBQXVCLEdBQXZCLGdDQUNBLENBQ0QsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFNLE9BQVEsS0FBSyxJQUFMLENBQVUsR0FBVixDQUFjLEdBQWQsQ0FBZCxDQUNBO0FBQ0EsR0FBSSxNQUFNLEtBQU4sQ0FBYyxDQUFsQixDQUFxQixDQUNwQjtBQUNBLEdBQUcsVUFBSCxDQUFjLEdBQUcsSUFBSCxDQUFkLENBQXdCLE1BQU0sV0FBTixDQUFvQixNQUE1QyxDQUFvRCxNQUFRLEtBQVIsQ0FBZ0IsTUFBTSxLQUExRSxFQUNBLENBQ0QsQ0FFRDs7Ozs7Ozs7O3dEQVVjLEcsQ0FBSyxJLENBQU0sSyxDQUFPLENBQy9CLEdBQUksQ0FBQyxLQUFLLEdBQUwsQ0FBUyxHQUFULENBQUwsQ0FBb0IsQ0FDbkIsc0JBQXVCLEdBQXZCLGdDQUNBLENBQ0QsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFNLEtBQU0sS0FBSyxHQUFqQixDQUNBLEdBQU0sT0FBUSxLQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsR0FBZCxDQUFkLENBQ0E7QUFDQSxLQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLFNBQUMsT0FBRCxDQUFVLEtBQVYsQ0FBb0IsQ0FDekM7QUFDQSxHQUFHLG1CQUFILENBQ0MsS0FERCxDQUVDLFFBQVEsSUFGVCxDQUdDLEdBQUcsUUFBUSxJQUFYLENBSEQsQ0FJQyxLQUpELENBS0MsUUFBUSxVQUxULENBTUMsTUFBTSxXQUFOLENBQWtCLEtBQWxCLENBTkQsRUFPQSxDQVRELEVBVUE7QUFDQSxHQUFJLE1BQU0sS0FBTixDQUFjLENBQWxCLENBQXFCLENBQ3BCO0FBQ0EsSUFBSSx3QkFBSixDQUE2QixHQUFHLElBQUgsQ0FBN0IsQ0FBdUMsQ0FBdkMsQ0FBMEMsS0FBMUMsQ0FBaUQsTUFBTSxLQUF2RCxFQUNBLENBQ0QsQywyQkFHRixPQUFPLE9BQVAsQ0FBaUIsV0FBakI7OztBQzFWQSxhLCtvQkFFQSxHQUFNLFdBQVksUUFBUSxrQkFBUixDQUFsQixDQUNBLEdBQU0sT0FBUSxRQUFRLGNBQVIsQ0FBZCxDQUVBO0FBRUEsR0FBTSxnQkFBaUIsQ0FDdEIsS0FBTSxDQURnQixDQUV0QixjQUFlLENBRk8sQ0FHdEIsTUFBTyxDQUhlLENBSXRCLGVBQWdCLENBSk0sQ0FLdEIsTUFBTyxDQUxlLENBTXRCLE1BQU8sQ0FOZSxDQUF2QixDQVNBO0FBRUEsR0FBTSxXQUFZLFFBQVosVUFBWSxDQUFTLFFBQVQsQ0FBbUIsQ0FDcEM7QUFDQTtBQUNBLEdBQUksU0FBUyxJQUFULEdBQWtCLENBQXRCLENBQXlCLENBQ3hCLE1BQU8sRUFBUCxDQUNBLENBQ0QsR0FBSSxlQUFnQixDQUFwQixDQUNBLEdBQUksYUFBYyxDQUFsQixDQUNBLEdBQUksWUFBYSxDQUFqQixDQUNBLFNBQVMsT0FBVCxDQUFpQixpQkFBVyxDQUMzQixHQUFNLFlBQWEsUUFBUSxVQUEzQixDQUNBLEdBQU0sTUFBTyxRQUFRLElBQXJCLENBQ0EsR0FBTSxNQUFPLFFBQVEsSUFBckIsQ0FDQTtBQUNBLGFBQWUsS0FBTyxlQUFlLElBQWYsQ0FBdEIsQ0FDQTtBQUNBLEdBQUksV0FBYSxhQUFqQixDQUFnQyxDQUMvQixjQUFnQixVQUFoQixDQUNBLFdBQWEsV0FBYyxLQUFPLGVBQWUsSUFBZixDQUFsQyxDQUNBLENBQ0QsQ0FYRCxFQVlBO0FBQ0E7QUFDQTtBQUNBLEdBQUksZUFBaUIsV0FBckIsQ0FBa0MsQ0FDakM7QUFDQTtBQUNBLE1BQU8sRUFBUCxDQUNBLENBQ0QsTUFBTyxXQUFQLENBQ0EsQ0E5QkQsQ0FnQ0EsR0FBTSxzQkFBdUIsUUFBdkIscUJBQXVCLENBQVMsaUJBQVQsQ0FBNEIsQ0FDeEQ7QUFDQSxHQUFNLFVBQVcsR0FBSSxJQUFKLEVBQWpCLENBQ0EsTUFBTSxpQkFBTixDQUF5QixTQUFDLE9BQUQsQ0FBVSxHQUFWLENBQWtCLENBQzFDO0FBQ0EsR0FBTSxPQUFRLFNBQVMsR0FBVCxDQUFjLEVBQWQsQ0FBZCxDQUNBO0FBQ0EsUUFBUSxVQUFSLENBQXFCLFVBQVUsUUFBUSxVQUFsQixDQUE4QixDQUE5QixDQUFyQixDQUNBO0FBQ0EsU0FBUyxHQUFULENBQWEsS0FBYixDQUFvQixPQUFwQixFQUNBLENBUEQsRUFRQSxNQUFPLFNBQVAsQ0FDQSxDQVpELENBY0E7O01BR00sYSxZQUVMOzs7Ozs7Ozs7O0lBV0Esc0JBQVksRUFBWixDQUFnQixHQUFoQixDQUFrRCxJQUE3QixTQUE2QiwyREFBbEIsRUFBa0IsSUFBZCxRQUFjLDJEQUFKLEVBQUksb0NBQ2pELEtBQUssRUFBTCxDQUFVLEVBQVYsQ0FDQSxLQUFLLElBQUwsQ0FBWSxVQUFVLFFBQVEsSUFBbEIsQ0FBd0IsV0FBeEIsQ0FBWixDQUNBLEtBQUssS0FBTCxDQUFhLFVBQVUsUUFBUSxLQUFsQixDQUF5QixDQUF6QixDQUFiLENBQ0EsS0FBSyxXQUFMLENBQW1CLFVBQVUsUUFBUSxXQUFsQixDQUErQixDQUEvQixDQUFuQixDQUNBO0FBQ0EsS0FBSyxRQUFMLENBQWdCLHFCQUFxQixRQUFyQixDQUFoQixDQUNBO0FBQ0EsS0FBSyxVQUFMLENBQWtCLFVBQVUsS0FBSyxRQUFmLENBQWxCLENBQ0E7QUFDQSxHQUFJLGNBQWUsWUFBbkIsQ0FBZ0MsQ0FDL0IsS0FBSyxNQUFMLENBQWMsR0FBZCxDQUNBLENBRkQsSUFFTyxDQUNOLEtBQUssTUFBTCxDQUFjLEdBQUcsWUFBSCxFQUFkLENBQ0EsR0FBSSxHQUFKLENBQVMsQ0FDUjtBQUNBLEtBQUssVUFBTCxDQUFnQixHQUFoQixFQUNBLENBQ0QsQ0FDRCxDQUVEOzs7Ozs7MkVBT1csRyxDQUFLLENBQ2YsR0FBTSxJQUFLLEtBQUssRUFBaEIsQ0FDQSxHQUFHLFVBQUgsQ0FBYyxHQUFHLFlBQWpCLENBQStCLEtBQUssTUFBcEMsRUFDQSxHQUFHLFVBQUgsQ0FBYyxHQUFHLFlBQWpCLENBQStCLEdBQS9CLENBQW9DLEdBQUcsV0FBdkMsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDQUVEOzs7Ozs7O3dEQVFjLEssQ0FBdUIsSUFBaEIsV0FBZ0IsMkRBQUgsQ0FBRyxDQUNwQyxHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBLEdBQUcsVUFBSCxDQUFjLEdBQUcsWUFBakIsQ0FBK0IsS0FBSyxNQUFwQyxFQUNBLEdBQUcsYUFBSCxDQUFpQixHQUFHLFlBQXBCLENBQWtDLFVBQWxDLENBQThDLEtBQTlDLEVBQ0EsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozt1Q0FLTyxnQkFDTixHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBO0FBQ0EsR0FBRyxVQUFILENBQWMsR0FBRyxZQUFqQixDQUErQixLQUFLLE1BQXBDLEVBQ0E7QUFDQSxLQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLFNBQUMsT0FBRCxDQUFVLEtBQVYsQ0FBb0IsQ0FDekM7QUFDQSxHQUFHLG1CQUFILENBQ0MsS0FERCxDQUVDLFFBQVEsSUFGVCxDQUdDLEdBQUcsUUFBUSxJQUFYLENBSEQsQ0FJQyxLQUpELENBS0MsTUFBSyxVQUxOLENBTUMsUUFBUSxVQU5ULEVBT0E7QUFDQSxHQUFHLHVCQUFILENBQTJCLEtBQTNCLEVBQ0EsQ0FYRCxFQVlBLE1BQU8sS0FBUCxDQUNBLENBRUQ7Ozs7MkNBS1MsQ0FDUixHQUFNLElBQUssS0FBSyxFQUFoQixDQUNBLEtBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsU0FBQyxPQUFELENBQVUsS0FBVixDQUFvQixDQUN6QztBQUNBLEdBQUcsd0JBQUgsQ0FBNEIsS0FBNUIsRUFDQSxDQUhELEVBSUEsTUFBTyxLQUFQLENBQ0EsQ0FFRDs7Ozt1Q0FLTyxDQUNOLEdBQU0sSUFBSyxLQUFLLEVBQWhCLENBQ0EsR0FBRyxVQUFILENBQWMsR0FBRyxLQUFLLElBQVIsQ0FBZCxDQUE2QixLQUFLLFdBQWxDLENBQStDLEtBQUssS0FBcEQsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDLDRCQUdGLE9BQU8sT0FBUCxDQUFpQixZQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVhcmN1dDtcblxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcblxuICAgIGRpbSA9IGRpbSB8fCAyO1xuXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxuICAgICAgICBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcbiAgICAgICAgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSkgcmV0dXJuIHRyaWFuZ2xlcztcblxuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuXG4gICAgaWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xuXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gODAgKiBkaW0pIHtcbiAgICAgICAgbWluWCA9IG1heFggPSBkYXRhWzBdO1xuICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICAgIGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMSAvIGludlNpemUgOiAwO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICAgIHZhciBpLCBsYXN0O1xuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgYnJlYWs7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGljZSBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGVhciwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBwID0gZWFyLm5leHQubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBlYXIucHJldikge1xuICAgICAgICBpZiAocG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IChhLnggPCBjLnggPyBhLnggOiBjLngpIDogKGIueCA8IGMueCA/IGIueCA6IGMueCksXG4gICAgICAgIG1pblRZID0gYS55IDwgYi55ID8gKGEueSA8IGMueSA/IGEueSA6IGMueSkgOiAoYi55IDwgYy55ID8gYi55IDogYy55KSxcbiAgICAgICAgbWF4VFggPSBhLnggPiBiLnggPyAoYS54ID4gYy54ID8gYS54IDogYy54KSA6IChiLnggPiBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtYXhUWSA9IGEueSA+IGIueSA/IChhLnkgPiBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA+IGMueSA/IGIueSA6IGMueSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgaW52U2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHZhciBwID0gZWFyLm5leHRaO1xuXG4gICAgd2hpbGUgKHAgJiYgcC56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHRaO1xuICAgIH1cblxuICAgIC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHAgPSBlYXIucHJldlo7XG5cbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBwO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgICAgICBvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICBvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmIChvdXRlck5vZGUpIHtcbiAgICAgICAgdmFyIGIgPSBzcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcbiAgICAgICAgZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG4gICAgfVxufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC5uZXh0LnkpIHJldHVybiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChoeCA9PT0gcXgpIHJldHVybiBtLnByZXY7IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBzdG9wID0gbSxcbiAgICAgICAgbXggPSBtLngsXG4gICAgICAgIG15ID0gbS55LFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgdGFuO1xuXG4gICAgcCA9IG0ubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBzdG9wKSB7XG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKCh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCkpICYmIGxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IG51bGwpIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9IDMyNzY3ICogKHggLSBtaW5YKSAqIGludlNpemU7XG4gICAgeSA9IDMyNzY3ICogKHkgLSBtaW5ZKSAqIGludlNpemU7XG5cbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcbmZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgbGVmdG1vc3QgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnggPCBsZWZ0bW9zdC54KSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSAtIChheCAtIHB4KSAqIChjeSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSAtIChieCAtIHB4KSAqIChheSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSAtIChjeCAtIHB4KSAqIChieSAtIHB5KSA+PSAwO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiZcbiAgICAgICAgICAgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKTtcbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICBpZiAoKGVxdWFscyhwMSwgcTEpICYmIGVxdWFscyhwMiwgcTIpKSB8fFxuICAgICAgICAoZXF1YWxzKHAxLCBxMikgJiYgZXF1YWxzKHAyLCBxMSkpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gYXJlYShwMSwgcTEsIHAyKSA+IDAgIT09IGFyZWEocDEsIHExLCBxMikgPiAwICYmXG4gICAgICAgICAgIGFyZWEocDIsIHEyLCBwMSkgPiAwICE9PSBhcmVhKHAyLCBxMiwgcTEpID4gMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGljZSBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0aWNlIG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgIHRoaXMueiA9IG51bGw7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XG5cbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZWFyY3V0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgdmFyIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIHBvbHlnb25BcmVhID0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCAwLCBvdXRlckxlbiwgZGltKSk7XG4gICAgaWYgKGhhc0hvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICB2YXIgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHBvbHlnb25BcmVhIC09IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVzQXJlYSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgYSA9IHRyaWFuZ2xlc1tpXSAqIGRpbTtcbiAgICAgICAgdmFyIGIgPSB0cmlhbmdsZXNbaSArIDFdICogZGltO1xuICAgICAgICB2YXIgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufTtcblxuZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgICAgICBqID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLy8gdHVybiBhIHBvbHlnb24gaW4gYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBmb3JtIChlLmcuIGFzIGluIEdlb0pTT04pIGludG8gYSBmb3JtIEVhcmN1dCBhY2NlcHRzXG5lYXJjdXQuZmxhdHRlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRpbSA9IGRhdGFbMF1bMF0ubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7dmVydGljZXM6IFtdLCBob2xlczogW10sIGRpbWVuc2lvbnM6IGRpbX0sXG4gICAgICAgIGhvbGVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSByZXN1bHQudmVydGljZXMucHVzaChkYXRhW2ldW2pdW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGhvbGVJbmRleCArPSBkYXRhW2kgLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQuaG9sZXMucHVzaChob2xlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICB9XG4gICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtYmVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbGFtcDtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RGdW5jdGlvbjtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRWFjaDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGJhc2VDbGFtcCA9IHJlcXVpcmUoJy4vX2Jhc2VDbGFtcCcpLFxuICAgIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKipcbiAqIENsYW1wcyBgbnVtYmVyYCB3aXRoaW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY2xhbXAoLTEwLCAtNSwgNSk7XG4gKiAvLyA9PiAtNVxuICpcbiAqIF8uY2xhbXAoMTAsIC01LCA1KTtcbiAqIC8vID0+IDVcbiAqL1xuZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICB1cHBlciA9IGxvd2VyO1xuICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXBwZXIgPSB0b051bWJlcih1cHBlcik7XG4gICAgdXBwZXIgPSB1cHBlciA9PT0gdXBwZXIgPyB1cHBlciA6IDA7XG4gIH1cbiAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICBsb3dlciA9IHRvTnVtYmVyKGxvd2VyKTtcbiAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgfVxuICByZXR1cm4gYmFzZUNsYW1wKHRvTnVtYmVyKG51bWJlciksIGxvd2VyLCB1cHBlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhbXA7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgbm93ID0gcmVxdWlyZSgnLi9ub3cnKSxcbiAgICB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogQ2hlY2tzIGB2YWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCBpblxuICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICogb3IgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjE0LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gKiAvLyA9PiAxXG4gKlxuICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gKiAvLyA9PiAxMFxuICovXG5mdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRUbztcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4zLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZm9ySW5SaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgPyBvYmplY3RcbiAgICA6IGJhc2VGb3Iob2JqZWN0LCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpLCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckluO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi9fYmFzZU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gKiAgIHJldHVybiBuICogbjtcbiAqIH1cbiAqXG4gKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XVxuICpcbiAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuL2RlYm91bmNlJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnRpYWxTb3J0O1xuXG4vLyBGbG95ZC1SaXZlc3Qgc2VsZWN0aW9uIGFsZ29yaXRobTpcbi8vIFJlYXJyYW5nZSBpdGVtcyBzbyB0aGF0IGFsbCBpdGVtcyBpbiB0aGUgW2xlZnQsIGtdIHJhbmdlIGFyZSBzbWFsbGVyIHRoYW4gYWxsIGl0ZW1zIGluIChrLCByaWdodF07XG4vLyBUaGUgay10aCBlbGVtZW50IHdpbGwgaGF2ZSB0aGUgKGsgLSBsZWZ0ICsgMSl0aCBzbWFsbGVzdCB2YWx1ZSBpbiBbbGVmdCwgcmlnaHRdXG5cbmZ1bmN0aW9uIHBhcnRpYWxTb3J0KGFyciwgaywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCAwO1xuICAgIHJpZ2h0ID0gcmlnaHQgfHwgKGFyci5sZW5ndGggLSAxKTtcbiAgICBjb21wYXJlID0gY29tcGFyZSB8fCBkZWZhdWx0Q29tcGFyZTtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgICAgICAgdmFyIG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgICAgICAgdmFyIHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgdmFyIG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBwYXJ0aWFsU29ydChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gYXJyW2tdO1xuICAgICAgICB2YXIgaSA9IGxlZnQ7XG4gICAgICAgIHZhciBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyLCBsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMCkgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2pdLCB0KSA+IDApIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyLCBsZWZ0LCBqKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmJ1c2g7XG5cbnZhciBxdWlja3NlbGVjdCA9IHJlcXVpcmUoJ3F1aWNrc2VsZWN0Jyk7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgY29sbGlkZXM6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHN0cmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRm4pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGNvbXBhcmVOb2RlTWluWCxcbiAgICBjb21wYXJlTWluWTogY29tcGFyZU5vZGVNaW5ZLFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hbGw6IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaC5hcHBseShub2Rlc1RvU2VhcmNoLCBub2RlLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgTiA9IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKE4gPD0gTSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSk7XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgbm9kZS5sZWFmID0gZmFsc2U7XG4gICAgICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuXG4gICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXG4gICAgICAgICAgICBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXG4gICAgICAgICAgICBpLCBqLCByaWdodDIsIHJpZ2h0MztcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgICAgIHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXG4gICAgICAgICAgICAgICAgcmlnaHQzID0gTWF0aC5taW4oaiArIE4yIC0gMSwgcmlnaHQyKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTdWJ0cmVlOiBmdW5jdGlvbiAoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XG5cbiAgICAgICAgICAgIG1pbkFyZWEgPSBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtIDogdG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgZXh0ZW5kKG5vZGUsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdDogZnVuY3Rpb24gKGluc2VydFBhdGgsIGxldmVsKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcbiAgICAgICAgICAgIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfSxcblxuICAgIF9zcGxpdFJvb3Q6IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgaSwgYmJveDEsIGJib3gyLCBvdmVybGFwLCBhcmVhLCBtaW5PdmVybGFwLCBtaW5BcmVhLCBpbmRleDtcblxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH0sXG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSkge1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcbiAgICAgICAgICAgIG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXSwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xuXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblggPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMF0pKTtcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xuXG4gICAgICAgIHRoaXMudG9CQm94ID0gbmV3IEZ1bmN0aW9uKCdhJyxcbiAgICAgICAgICAgICdyZXR1cm4ge21pblg6IGEnICsgZm9ybWF0WzBdICtcbiAgICAgICAgICAgICcsIG1pblk6IGEnICsgZm9ybWF0WzFdICtcbiAgICAgICAgICAgICcsIG1heFg6IGEnICsgZm9ybWF0WzJdICtcbiAgICAgICAgICAgICcsIG1heFk6IGEnICsgZm9ybWF0WzNdICsgJ307Jyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZmluZEl0ZW0oaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSkge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgYS5taW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIGEubWluWSA9IE1hdGgubWluKGEubWluWSwgYi5taW5ZKTtcbiAgICBhLm1heFggPSBNYXRoLm1heChhLm1heFgsIGIubWF4WCk7XG4gICAgYS5tYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5taW5ZIC0gYi5taW5ZOyB9XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGEpICAgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSArIChhLm1heFkgLSBhLm1pblkpOyB9XG5cbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGIubWF4WSwgYS5tYXhZKSAtIE1hdGgubWluKGIubWluWSwgYS5taW5ZKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoYSwgYikge1xuICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYS5taW5YLCBiLm1pblgpLFxuICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYS5taW5ZLCBiLm1pblkpLFxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYS5tYXhYLCBiLm1heFgpLFxuICAgICAgICBtYXhZID0gTWF0aC5taW4oYS5tYXhZLCBiLm1heFkpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhLm1pblggPD0gYi5taW5YICYmXG4gICAgICAgICAgIGEubWluWSA8PSBiLm1pblkgJiZcbiAgICAgICAgICAgYi5tYXhYIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1heFkgPD0gYS5tYXhZO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5taW5YIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1pblkgPD0gYS5tYXhZICYmXG4gICAgICAgICAgIGIubWF4WCA+PSBhLm1pblggJiZcbiAgICAgICAgICAgYi5tYXhZID49IGEubWluWTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZShjaGlsZHJlbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5XG4gICAgfTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXG4gICAgICAgIG1pZDtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBFdmVudCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBFdmVudCBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGhlIG9iamVjdCB0aGF0IGZpcmVkIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBldmVudCB3YXMgY3JlYXRlZC4gT3B0aW9uYWwuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IodGFyZ2V0LCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpKSB7XHJcblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuXHRcdHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudCBicm9hZGNhc3Rlci5cclxuICogQHByaXZhdGVcclxuICovXHJcbmNsYXNzIEV2ZW50QnJvYWRjYXN0ZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgRXZlbnRCcm9hZGNhc3RlciBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byBhdHRhY2ggdGhlIGJyb2FkY2FzdGVyIHRvLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHBsb3QpIHtcclxuXHRcdHRoaXMucGxvdCA9IHBsb3Q7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBCcm9hZGNhc3RzIHRoZSBwcm92aWRlZCBldmVudCB0eXBlIHRvIGFsbCBjaGlsZHJlbiBvZiB0aGUgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUgdG8gYnJvYWRjYXN0LlxyXG5cdCAqL1xyXG5cdGJyb2FkY2FzdCh0eXBlKSB7XHJcblx0XHR0aGlzLnBsb3Qub24odHlwZSwgZXZlbnQgPT4ge1xyXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMucGxvdC5nZXRTb3J0ZWRMYXllcnMoKTtcclxuXHRcdFx0Zm9yIChsZXQgaT1jaGlsZHJlbi5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XHJcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0hpZGRlbigpKSB7XHJcblx0XHRcdFx0XHRjaGlsZHJlbltpXS5lbWl0KHR5cGUsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEJyb2FkY2FzdGVyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBFdmVudFR5cGUgPSByZXF1aXJlKCcuL0V2ZW50VHlwZScpO1xyXG5jb25zdCBNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9Nb3VzZUV2ZW50Jyk7XHJcblxyXG5jb25zdCBzZXRDdXJzb3IgPSBmdW5jdGlvbihwbG90KSB7XHJcblx0cGxvdC5nZXRDb250YWluZXIoKS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcbn07XHJcblxyXG5jb25zdCByZXNldEN1cnNvciA9IGZ1bmN0aW9uKHBsb3QpIHtcclxuXHRwbG90LmdldENvbnRhaW5lcigpLnN0eWxlLmN1cnNvciA9ICdpbmhlcml0JztcclxufTtcclxuXHJcbmNvbnN0IGNvcHlFdmVudCA9IGZ1bmN0aW9uKHRhcmdldCwgZGF0YSwgZXZlbnQpIHtcclxuXHRyZXR1cm4gbmV3IE1vdXNlRXZlbnQoXHJcblx0XHR0YXJnZXQsXHJcblx0XHRldmVudC5vcmlnaW5hbEV2ZW50LFxyXG5cdFx0eyB4OiBldmVudC5wb3MueCwgeTogZXZlbnQucG9zLnkgfSxcclxuXHRcdHsgeDogZXZlbnQucHgueCwgeTogZXZlbnQucHgueSB9LFxyXG5cdFx0ZGF0YSk7XHJcbn07XHJcblxyXG5jb25zdCBkZWxlZ2F0ZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKGRlbGVnYXRvciwgY2hpbGQsIGV2ZW50LCBjb2xsaXNpb24pIHtcclxuXHQvLyBjcmVhdGUgZXZlbnRzIHRvIGRlbGVnYXRlXHJcblx0Y29uc3QgZGVsZWdhdGlvbnMgPSBbXTtcclxuXHRjb25zdCBwcmV2ID0gZGVsZWdhdG9yLnByZXZNb3VzZW92ZXI7XHJcblxyXG5cdGlmICghY29sbGlzaW9uKSB7XHJcblx0XHQvLyAgbm8gY29sbGlzaW9uXHJcblxyXG5cdFx0Ly8gY2hlY2sgZm9yIHByZXZcclxuXHRcdGlmIChwcmV2KSB7XHJcblx0XHRcdC8vIGNsZWFyIGN1cnNvciBzdHlsZVxyXG5cdFx0XHRyZXNldEN1cnNvcihkZWxlZ2F0b3IucGxvdCk7XHJcblx0XHRcdC8vIHVuLWhpZ2hsaWdodCBwcmV2aW91cyB0YXJnZXRcclxuXHRcdFx0cHJldi50YXJnZXQudW5oaWdobGlnaHQoKTtcclxuXHRcdFx0Ly8gYG1vdXNlb3V0YCBvbiBwcmV2aW91cyB0YXJnZXRcclxuXHRcdFx0ZGVsZWdhdGlvbnMucHVzaCh7XHJcblx0XHRcdFx0dHlwZTogRXZlbnRUeXBlLk1PVVNFX09VVCxcclxuXHRcdFx0XHRldmVudDogY29weUV2ZW50KHByZXYudGFyZ2V0LCBwcmV2LmRhdGEsIHByZXYpXHJcblx0XHRcdH0pO1xyXG5cdFx0XHQvLyB1bmZsYWcgYXMgcHJldiBgbW91c2VvdmVyYCB0YXJnZXRcclxuXHRcdFx0ZGVsZWdhdG9yLnByZXZNb3VzZW92ZXIgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gY29sbGlzaW9uXHJcblxyXG5cdFx0Ly8gY2hlY2sgZm9yIHByZXZcclxuXHRcdGlmIChwcmV2ICYmIHByZXYuZGF0YSAhPT0gY29sbGlzaW9uKSB7XHJcblx0XHRcdC8vIHVuLWhpZ2hsaWdodCBwcmV2aW91cyB0YXJnZXRcclxuXHRcdFx0cHJldi50YXJnZXQudW5oaWdobGlnaHQoKTtcclxuXHRcdFx0Ly8gYG1vdXNlb3V0YCBvbiBwcmV2aW91cyB0YXJnZXRcclxuXHRcdFx0ZGVsZWdhdGlvbnMucHVzaCh7XHJcblx0XHRcdFx0dHlwZTogRXZlbnRUeXBlLk1PVVNFX09VVCxcclxuXHRcdFx0XHRldmVudDogY29weUV2ZW50KHByZXYudGFyZ2V0LCBwcmV2LmRhdGEsIHByZXYpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGBtb3VzZW1vdmVgIG9uIGN1cnJlbnQgdGFyZ2V0XHJcblx0XHRkZWxlZ2F0aW9ucy5wdXNoKHtcclxuXHRcdFx0dHlwZTogRXZlbnRUeXBlLk1PVVNFX01PVkUsXHJcblx0XHRcdGV2ZW50OiBjb3B5RXZlbnQoY2hpbGQsIGNvbGxpc2lvbiwgZXZlbnQpXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBzZXQgY3Vyc29yIGZvciBob3ZlclxyXG5cdFx0c2V0Q3Vyc29yKGRlbGVnYXRvci5wbG90KTtcclxuXHJcblx0XHQvLyBoaWdobGlnaHRcclxuXHRcdGNoaWxkLmhpZ2hsaWdodChjb2xsaXNpb24pO1xyXG5cclxuXHRcdGlmICghcHJldiB8fCBwcmV2LmRhdGEgIT09IGNvbGxpc2lvbikge1xyXG5cdFx0XHQvLyBgbW91c2VvdmVyYCBvbiBjdXJyZW50XHJcblx0XHRcdGRlbGVnYXRpb25zLnB1c2goe1xyXG5cdFx0XHRcdHR5cGU6IEV2ZW50VHlwZS5NT1VTRV9PVkVSLFxyXG5cdFx0XHRcdGV2ZW50OiBjb3B5RXZlbnQoY2hpbGQsIGNvbGxpc2lvbiwgZXZlbnQpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZsYWcgYXMgcHJldiBgbW91c2VvdmVyYFxyXG5cdFx0ZGVsZWdhdG9yLnByZXZNb3VzZW92ZXIgPSBkZWxlZ2F0aW9uc1tkZWxlZ2F0aW9ucy5sZW5ndGgtMV0uZXZlbnQ7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGVsZWdhdGlvbnM7XHJcbn07XHJcblxyXG5jb25zdCBkZWxlZ2F0ZU1vdXNlVXAgPSBmdW5jdGlvbihkZWxlZ2F0b3IsIGNoaWxkLCBldmVudCwgY29sbGlzaW9uKSB7XHJcblx0aWYgKGNvbGxpc2lvbikge1xyXG5cdFx0cmV0dXJuIFt7XHJcblx0XHRcdHR5cGU6IEV2ZW50VHlwZS5NT1VTRV9VUCxcclxuXHRcdFx0ZXZlbnQ6IGNvcHlFdmVudChjaGlsZCwgY29sbGlzaW9uLCBldmVudClcclxuXHRcdH1dO1xyXG5cdH1cclxuXHRyZXR1cm4gW107XHJcbn07XHJcblxyXG5jb25zdCBkZWxlZ2F0ZU1vdXNlRG93biA9IGZ1bmN0aW9uKGRlbGVnYXRvciwgY2hpbGQsIGV2ZW50LCBjb2xsaXNpb24pIHtcclxuXHRpZiAoY29sbGlzaW9uKSB7XHJcblx0XHRyZXR1cm4gW3tcclxuXHRcdFx0dHlwZTogRXZlbnRUeXBlLk1PVVNFX0RPV04sXHJcblx0XHRcdGV2ZW50OiBjb3B5RXZlbnQoY2hpbGQsIGNvbGxpc2lvbiwgZXZlbnQpXHJcblx0XHR9XTtcclxuXHR9XHJcblx0cmV0dXJuIFtdO1xyXG59O1xyXG5cclxuY29uc3QgZGVsZWdhdGVDbGljayA9IGZ1bmN0aW9uKGRlbGVnYXRvciwgY2hpbGQsIGV2ZW50LCBjb2xsaXNpb24pIHtcclxuXHQvLyBjaGVjayBpZiBtdWx0aS1zZWxlY3QgaXMgZW5hYmxlZFxyXG5cdGNvbnN0IG11bHRpU2VsZWN0ID0gZXZlbnQub3JpZ2luYWxFdmVudC5jdHJsS2V5IHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQubWV0YUtleTtcclxuXHRpZiAoY29sbGlzaW9uKSB7XHJcblxyXG5cdFx0Ly8gc2VsZWN0XHJcblx0XHRpZiAoIWNoaWxkLmlzU2VsZWN0ZWQoY29sbGlzaW9uKSkge1xyXG5cdFx0XHRpZiAoIW11bHRpU2VsZWN0KSB7XHJcblx0XHRcdFx0Ly8gaWYgbm90IG11bHRpLXNlbGVjdCwgdW5zZWxlY3QgdGhlIGRhdGEgcHJldiBzZWxlY3RlZCBkYXRhXHJcblx0XHRcdFx0ZGVsZWdhdG9yLnByZXZDbGljay5mb3JFYWNoKHByZXYgPT4ge1xyXG5cdFx0XHRcdFx0cHJldi50YXJnZXQudW5zZWxlY3RBbGwoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRkZWxlZ2F0b3IucHJldkNsaWNrID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaWYgbm90IGFscmVhZHkgc2VsZWN0ZWQsIGFkZCB0byBzZWxlY3Rpb25cclxuXHRcdFx0Y2hpbGQuc2VsZWN0KGNvbGxpc2lvbiwgbXVsdGlTZWxlY3QpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG11bHRpU2VsZWN0KSB7XHJcblx0XHRcdFx0Ly8gcmVtb3ZlIGlmIGFscmVhZHkgc2VsZWN0ZWRcclxuXHRcdFx0XHRjaGlsZC51bnNlbGVjdChjb2xsaXNpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBgY2xpY2tgIGV2ZW50XHJcblx0XHRjb25zdCBkZWxlZ2F0aW9uID0ge1xyXG5cdFx0XHR0eXBlOiBFdmVudFR5cGUuQ0xJQ0ssXHJcblx0XHRcdGV2ZW50OiBjb3B5RXZlbnQoY2hpbGQsIGNvbGxpc2lvbiwgZXZlbnQpXHJcblx0XHR9O1xyXG5cdFx0Ly8gZmxhZyBhcyBwcmV2IGBjbGlja2AgdGFyZ2V0XHJcblx0XHRkZWxlZ2F0b3IucHJldkNsaWNrLnB1c2goZGVsZWdhdGlvbi5ldmVudCk7XHJcblx0XHQvLyByZXR1cm4gZGVsZWdhdGlvblxyXG5cdFx0cmV0dXJuIFsgZGVsZWdhdGlvbiBdO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGlmIChkZWxlZ2F0b3IucHJldkNsaWNrLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0aWYgKG11bHRpU2VsZWN0KSB7XHJcblx0XHRcdFx0Ly8gaWYgbXVsdGktc2VsZWN0IGlzIGhlbGQsIGRvbid0IGNsZWFyIHNlbGVjdGlvbiwgYXNzdW1lIHRoZVxyXG5cdFx0XHRcdC8vIHVzZXIgbWF5IGhhdmUgbWlzY2xpY2tlZFxyXG5cdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyB1bnNlbGVjdCB0aGUgZGF0YVxyXG5cdFx0XHRkZWxlZ2F0b3IucHJldkNsaWNrLmZvckVhY2gocHJldiA9PiB7XHJcblx0XHRcdFx0cHJldi50YXJnZXQudW5zZWxlY3RBbGwoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdC8vIHVuZmxhZyBhcyBwcmV2IGBjbGlja2AgdGFyZ2V0XHJcblx0XHRcdGRlbGVnYXRvci5wcmV2Q2xpY2sgPSBbXTtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cdHJldHVybiBbXTtcclxufTtcclxuXHJcbmNvbnN0IGRlbGVnYXRlRGJsQ2xpY2sgPSBmdW5jdGlvbihkZWxlZ2F0b3IsIGNoaWxkLCBldmVudCwgY29sbGlzaW9uKSB7XHJcblx0aWYgKGNvbGxpc2lvbikge1xyXG5cdFx0cmV0dXJuIFt7XHJcblx0XHRcdHR5cGU6IEV2ZW50VHlwZS5EQkxfQ0xJQ0ssXHJcblx0XHRcdGV2ZW50OiBjb3B5RXZlbnQoY2hpbGQsIGNvbGxpc2lvbiwgZXZlbnQpXHJcblx0XHR9XTtcclxuXHR9XHJcblx0cmV0dXJuIFtdO1xyXG59O1xyXG5cclxuY29uc3QgREVMRUdBVElPTl9GVU5DUyA9IHtcclxuXHRbRXZlbnRUeXBlLk1PVVNFX01PVkVdOiBkZWxlZ2F0ZU1vdXNlTW92ZSxcclxuXHRbRXZlbnRUeXBlLk1PVVNFX1VQXTogZGVsZWdhdGVNb3VzZVVwLFxyXG5cdFtFdmVudFR5cGUuTU9VU0VfRE9XTl06IGRlbGVnYXRlTW91c2VEb3duLFxyXG5cdFtFdmVudFR5cGUuQ0xJQ0tdOiBkZWxlZ2F0ZUNsaWNrLFxyXG5cdFtFdmVudFR5cGUuREJMX0NMSUNLXTogZGVsZWdhdGVEYmxDbGljayxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQgZGVsZWdhdG9yLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY2xhc3MgRXZlbnREZWxlZ2F0b3Ige1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgRXZlbnREZWxlZ2F0b3Igb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQbG90fSBwbG90IC0gVGhlIHBsb3QgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHBsb3QpIHtcclxuXHRcdHRoaXMucGxvdCA9IHBsb3Q7XHJcblx0XHR0aGlzLnByZXZDbGljayA9IFtdO1xyXG5cdFx0dGhpcy5wcmV2TW91c2VvdmVyID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlbGVnYXRlcyB0aGUgcHJvdmlkZWQgZXZlbnQgdHlwZSB0byBhbGwgY2hpbGRyZW4gb2YgdGhlIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlIHRvIGRlbGVnYXRlLlxyXG5cdCAqL1xyXG5cdGRlbGVnYXRlKHR5cGUpIHtcclxuXHRcdC8vIGdldCBhcHByb3ByaWF0ZSBkZWxlZ2F0aW9uIGZ1bmN0aW9uXHJcblx0XHRjb25zdCBmdW5jID0gREVMRUdBVElPTl9GVU5DU1t0eXBlXTtcclxuXHRcdGlmICghZnVuYykge1xyXG5cdFx0XHR0aHJvdyBgRGVsZWdhdGlvbiBmb3IgZXZlbnQgdHlwZSAke3R5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgO1xyXG5cdFx0fVxyXG5cdFx0Ly8gYXR0YWNoIGRlbGVnYXRpb24gaGFuZGxlclxyXG5cdFx0dGhpcy5wbG90Lm9uKHR5cGUsIGV2ZW50ID0+IHtcclxuXHRcdFx0Ly8gZ2V0IGNoaWxkcmVuIHNvcnRlZCBieSB6LWluZGV4XHJcblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5wbG90LmdldFNvcnRlZExheWVycygpO1xyXG5cdFx0XHQvLyBwaWNrIGNoaWxkcmVuLCBieSBwcmlvcml0eVxyXG5cdFx0XHRsZXQgY29sbGlzaW9uID0gbnVsbDtcclxuXHRcdFx0bGV0IGNoaWxkID0gbnVsbDtcclxuXHRcdFx0Zm9yIChsZXQgaT1jaGlsZHJlbi5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XHJcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0hpZGRlbigpKSB7XHJcblx0XHRcdFx0XHRjb2xsaXNpb24gPSBjaGlsZHJlbltpXS5waWNrKGV2ZW50LnBvcyk7XHJcblx0XHRcdFx0XHRpZiAoY29sbGlzaW9uKSB7XHJcblx0XHRcdFx0XHRcdGNoaWxkID0gY2hpbGRyZW5baV07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBkZWxlZ2F0ZSB1c2luZyBwcm92aWRlZCBmdW5jXHJcblx0XHRcdGNvbnN0IGRlbGVnYXRpb25zID0gZnVuYyh0aGlzLCBjaGlsZCwgZXZlbnQsIGNvbGxpc2lvbik7XHJcblx0XHRcdC8vIGRlbGVnYXRlIHRoZSBhY2N1bXVsYXRlZCBldmVudHNcclxuXHRcdFx0Zm9yIChsZXQgaT0wOyBpPGRlbGVnYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0Y29uc3QgZGVsZWdhdGlvbiA9IGRlbGVnYXRpb25zW2ldO1xyXG5cdFx0XHRcdGRlbGVnYXRpb24uZXZlbnQudGFyZ2V0LmVtaXQoZGVsZWdhdGlvbi50eXBlLCBkZWxlZ2F0aW9uLmV2ZW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RGVsZWdhdG9yO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogRXZlbnQgdHlwZSBzdHJpbmcgY29uc3RhbnRzLlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXR0ZWQgd2hlbiB0aGUgcGxvdCBpcyBjbGlja2VkLlxyXG5cdCAqIEBjb25zdGFudCB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdENMSUNLOiAnY2xpY2snLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0dGVkIHdoZW4gdGhlIHBsb3QgaXMgZG91YmxlIGNsaWNrZWQuXHJcblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XHJcblx0ICovXHJcblx0REJMX0NMSUNLOiAnZGJsY2xpY2snLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0dGVkIHdoZW4gYSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZC5cclxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cclxuXHQgKi9cclxuXHRNT1VTRV9ET1dOOiAnbW91c2Vkb3duJyxcclxuXHJcblx0LyoqXHJcblx0ICogRW1pdHRlZCB3aGVuIGEgbW91c2UgYnV0dG9uIGlzIHJlbGVhc2VkLlxyXG5cdCAqIEBjb25zdGFudCB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdE1PVVNFX1VQOiAnbW91c2V1cCcsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXR0ZWQgd2hlbiB0aGUgbW91c2UgaXMgbW92ZWQgb24gdGhlIHRhcmdldC5cclxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cclxuXHQgKi9cclxuXHRNT1VTRV9NT1ZFOiAnbW91c2Vtb3ZlJyxcclxuXHJcblx0LyoqXHJcblx0ICogRW1pdHRlZCB3aGVuIHRoZSBtb3VzZSBpcyBtb3ZlZCBvbnRvIHRoZSB0YXJnZXQuXHJcblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XHJcblx0ICovXHJcblx0TU9VU0VfT1ZFUjogJ21vdXNlb3ZlcicsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXR0ZWQgd2hlbiB0aGUgbW91c2UgaXMgbW92ZWQgb3V0IG9mIHRoZSB0YXJnZXQuXHJcblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XHJcblx0ICovXHJcblx0TU9VU0VfT1VUOiAnbW91c2VvdXQnLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0dGVkIHdoZW4gYSBuZXcgcGFuIGV2ZW50IGlzIGhhbmRsZWQuXHJcblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XHJcblx0ICovXHJcblx0UEFOX1NUQVJUOiAncGFuc3RhcnQnLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0dGVkIGR1cmluZyBlYWNoIGZyYW1lIG9mIGEgcGFuIGFuaW1hdGlvbi5cclxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cclxuXHQgKi9cclxuXHRQQU46ICdwYW4nLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0dGVkIG9uIHRoZSBmaW5hbCBmcmFtZSBvZiBhIHBhbiBhbmltYXRpb24uXHJcblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XHJcblx0ICovXHJcblx0UEFOX0VORDogJ3BhbmVuZCcsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXR0ZWQgd2hlbiBhIG5ldyB6b29tIGV2ZW50IGlzIGhhbmRsZWQuXHJcblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XHJcblx0ICovXHJcblx0Wk9PTV9TVEFSVDogJ3pvb21zdGFydCcsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXR0ZWQgZHVyaW5nIGVhY2ggZnJhbWUgb2YgYSB6b29tIGFuaW1hdGlvbi5cclxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cclxuXHQgKi9cclxuXHRaT09NOiAnem9vbScsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXR0ZWQgb24gdGhlIGZpbmFsIGZyYW1lIG9mIGEgem9vbSBhbmltYXRpb24uXHJcblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XHJcblx0ICovXHJcblx0Wk9PTV9FTkQ6ICd6b29tZW5kJyxcclxuXHJcblx0LyoqXHJcblx0ICogRW1pdHRlZCBiZWZvcmUgcHJvY2Vzc2luZyBhIG5ldyBmcmFtZS5cclxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cclxuXHQgKi9cclxuXHRGUkFNRTogJ2ZyYW1lJyxcclxuXHJcblx0LyoqXHJcblx0ICogRW1pdHRlZCB3aGVuIHByb2Nlc3NpbmcgYSByZXNpemUgZXZlbnQuXHJcblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XHJcblx0ICovXHJcblx0UkVTSVpFOiAncmVzaXplJyxcclxuXHJcblx0LyoqXHJcblx0ICogRW1pdHRlZCB3aGVuIHRoZSB2aWV3aW5nIGNlbGwgb2YgdGhlIHBsb3QgaXMgdXBkYXRlZC5cclxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cclxuXHQgKi9cclxuXHRDRUxMX1VQREFURTogJ2NlbGx1cGRhdGUnLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0dGVkIHdoZW4gdGhlIGxheWVyIGlzIHJlZnJlc2hlZC5cclxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cclxuXHQgKi9cclxuXHRSRUZSRVNIOiAncmVmcmVzaCcsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXR0ZWQgd2hlbiBhbiBpbml0aWFsIHJlcXVlc3QgZm9yIGEgdGlsZSBpcyBtYWRlLCB0aGUgdGlsZSBpcyBub3RcclxuXHQgKiB5ZXQgcGFydCBvZiB0aGUgbGF5ZXIgYW5kIGhhcyBub3QgeWV0IGJlZW4gcmVxdWVzdGVkLlxyXG5cdCAqIEBjb25zdGFudCB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdFRJTEVfUkVRVUVTVDogJ3RpbGVyZXF1ZXN0JyxcclxuXHJcblx0LyoqXHJcblx0ICogRW1pdHRlZCB3aGVuIGEgdGlsZSByZXF1ZXN0IGNvbXBsZXRlcyB1bnN1Y2Nlc3NmdWxseS4gVGhlIHRpbGUgaXMgbm90XHJcblx0ICogYWRkZWQgdG8gdGhlIGxheWVyLlxyXG5cdCAqIEBjb25zdGFudCB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdFRJTEVfRkFJTFVSRTogJ3RpbGVmYWlsdXJlJyxcclxuXHJcblx0LyoqXHJcblx0ICogRW1pdHRlZCB3aGVuIGEgdGlsZSByZXF1ZXN0IGNvbXBsZXRlcyBzdWNjZXNzZnVsbHkuIFRoZSB0aWxlIGlzIGFkZGVkXHJcblx0ICogdG8gdGhlIGxheWVyLlxyXG5cdCAqIEBjb25zdGFudCB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdFRJTEVfQUREOiAndGlsZWFkZCcsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXR0ZWQgd2hlbiBhIHRpbGUgcmVxdWVzdCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5IGJ1dCB0aGUgdGlsZSBpcyBub1xyXG5cdCAqIGxvbmdlciBpbiB2aWV3LiBUaGUgdGlsZSBpcyBub3QgYWRkZWQgdG8gdGhlIGxheWVyLlxyXG5cdCAqIEBjb25zdGFudCB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdFRJTEVfRElTQ0FSRDogJ3RpbGVkaXNjYXJkJyxcclxuXHJcblx0LyoqXHJcblx0ICogRW1pdHRlZCB3aGVuIGEgdGlsZSBpcyBldmljdGVkIGZyb20gdGhlIGludGVybmFsIExSVSBjYWNoZS5cclxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cclxuXHQgKi9cclxuXHRUSUxFX1JFTU9WRTogJ3RpbGVyZW1vdmUnLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0dGVkIHdoZW4gYWxsIHZpc2libGUgdGlsZXMgaGF2ZSBiZWVuIGxvYWRlZCBmb3IgYSBsYXllci5cclxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cclxuXHQgKi9cclxuXHRMT0FEOiAnbG9hZCdcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbW91c2UgZXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBNb3VzZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgTW91c2VFdmVudCBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGhlIG9iamVjdCB0aGF0IGZpcmVkIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIG1vdXNlIGV2ZW50IGZpcmVkIGJ5IHRoZSBicm93c2VyLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3MgLSBUaGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGV2ZW50IGluIHBsb3QgY29vcmRpbmF0ZXMuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBldmVudCBpbiB2aWV3cG9ydCBwaXhlbCBjb29yZGluYXRlcy5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IodGFyZ2V0LCBldmVudCwgcG9zLCBweCwgZGF0YSA9IG51bGwpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcclxuXHRcdHRoaXMucG9zID0gcG9zO1xyXG5cdFx0dGhpcy5weCA9IHB4O1xyXG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2VFdmVudDtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcmVzaXplIGV2ZW50LlxyXG4gKi9cclxuY2xhc3MgUmVzaXplRXZlbnQgZXh0ZW5kcyBFdmVudCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBSZXNpemVFdmVudCBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGhlIG9iamVjdCB0aGF0IGZpcmVkIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2xkU2l6ZSAtIFRoZSBvbGQgc2l6ZSBvZiB0aGUgdmlld3BvcnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG5ld1NpemUgLSBUaGUgbmV3IHNpemUgb2YgdGhlIHZpZXdwb3J0LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHRhcmdldCwgb2xkU2l6ZSwgbmV3U2l6ZSkge1xyXG5cdFx0c3VwZXIodGFyZ2V0KTtcclxuXHRcdHRoaXMub2xkU2l6ZSA9IG9sZFNpemU7XHJcblx0XHR0aGlzLm5ld1NpemUgPSBuZXdTaXplO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXNpemVFdmVudDtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgdGlsZSBldmVudC5cclxuICovXHJcbmNsYXNzIFRpbGVFdmVudCBleHRlbmRzIEV2ZW50IHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFRpbGVFdmVudCBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGhlIG9iamVjdCB0aGF0IGZpcmVkIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlsZSAtIFRoZSB0aWxlIG9iamVjdC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcih0YXJnZXQsIHRpbGUpIHtcclxuXHRcdHN1cGVyKHRhcmdldCk7XHJcblx0XHR0aGlzLnRpbGUgPSB0aWxlO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaWxlRXZlbnQ7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4vZXZlbnQvRXZlbnRUeXBlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQvLyBldmVudHNcclxuXHRDTElDSzogRXZlbnRUeXBlLkNMSUNLLFxyXG5cdERCTF9DTElDSzogRXZlbnRUeXBlLkRCTF9DTElDSyxcclxuXHRNT1VTRV9ET1dOOiBFdmVudFR5cGUuTU9VU0VfRE9XTixcclxuXHRNT1VTRV9VUDogRXZlbnRUeXBlLk1PVVNFX1VQLFxyXG5cdE1PVVNFX01PVkU6IEV2ZW50VHlwZS5NT1VTRV9NT1ZFLFxyXG5cdE1PVVNFX09WRVI6IEV2ZW50VHlwZS5NT1VTRV9PVkVSLFxyXG5cdE1PVVNFX09VVDogRXZlbnRUeXBlLk1PVVNFX09VVCxcclxuXHRQQU5fU1RBUlQ6IEV2ZW50VHlwZS5QQU5fU1RBUlQsXHJcblx0UEFOOiBFdmVudFR5cGUuUEFOLFxyXG5cdFBBTl9FTkQ6IEV2ZW50VHlwZS5QQU5fRU5ELFxyXG5cdFpPT01fU1RBUlQ6IEV2ZW50VHlwZS5aT09NX1NUQVJULFxyXG5cdFpPT006IEV2ZW50VHlwZS5aT09NLFxyXG5cdFpPT01fRU5EOiBFdmVudFR5cGUuWk9PTV9FTkQsXHJcblx0UkVTSVpFOiBFdmVudFR5cGUuUkVTSVpFLFxyXG5cdEZSQU1FOiBFdmVudFR5cGUuRlJBTUUsXHJcblx0UkVGUkVTSDogRXZlbnRUeXBlLlJFRlJFU0gsXHJcblx0VElMRV9SRVFVRVNUOiBFdmVudFR5cGUuVElMRV9SRVFVRVNULFxyXG5cdFRJTEVfRkFJTFVSRTogRXZlbnRUeXBlLlRJTEVfRkFJTFVSRSxcclxuXHRUSUxFX0FERDogRXZlbnRUeXBlLlRJTEVfQURELFxyXG5cdFRJTEVfRElTQ0FSRDogRXZlbnRUeXBlLlRJTEVfRElTQ0FSRCxcclxuXHRUSUxFX1JFTU9WRTogRXZlbnRUeXBlLlRJTEVfUkVNT1ZFLFxyXG5cdENFTExfVVBEQVRFOiBFdmVudFR5cGUuQ0VMTF9VUERBVEUsXHJcblx0Ly8gZXZlbnRcclxuXHRFdmVudDogcmVxdWlyZSgnLi9ldmVudC9FdmVudCcpLFxyXG5cdE1vdXNlRXZlbnQ6IHJlcXVpcmUoJy4vZXZlbnQvTW91c2VFdmVudCcpLFxyXG5cdFJlc2l6ZUV2ZW50OiByZXF1aXJlKCcuL2V2ZW50L1Jlc2l6ZUV2ZW50JyksXHJcblx0VGlsZUV2ZW50OiByZXF1aXJlKCcuL2V2ZW50L1RpbGVFdmVudCcpLFxyXG5cdC8vIGdlb21ldHJ5XHJcblx0Qm91bmRzOiByZXF1aXJlKCcuL2dlb21ldHJ5L0JvdW5kcycpLFxyXG5cdFJUcmVlOiByZXF1aXJlKCcuL2dlb21ldHJ5L1JUcmVlJyksXHJcblx0UlRyZWVQeXJhbWlkOiByZXF1aXJlKCcuL2dlb21ldHJ5L1JUcmVlUHlyYW1pZCcpLFxyXG5cdENpcmNsZUNvbGxpZGFibGU6IHJlcXVpcmUoJy4vZ2VvbWV0cnkvQ2lyY2xlQ29sbGlkYWJsZScpLFxyXG5cdFJlY3RhbmdsZUNvbGxpZGFibGU6IHJlcXVpcmUoJy4vZ2VvbWV0cnkvUmVjdGFuZ2xlQ29sbGlkYWJsZScpLFxyXG5cdFJpbmdDb2xsaWRhYmxlOiByZXF1aXJlKCcuL2dlb21ldHJ5L1JpbmdDb2xsaWRhYmxlJyksXHJcblx0Ly8gcGxvdFxyXG5cdFBsb3Q6IHJlcXVpcmUoJy4vcGxvdC9QbG90JyksXHJcblx0Ly8gbGF5ZXJcclxuXHRMYXllcjogcmVxdWlyZSgnLi9sYXllci9MYXllcicpLFxyXG5cdC8vIHRpbGUgbGF5ZXJcclxuXHRUaWxlTGF5ZXI6IHJlcXVpcmUoJy4vbGF5ZXIvdGlsZS9UaWxlTGF5ZXInKSxcclxuXHQvLyBvdmVybGF5IGxheWVyXHJcblx0T3ZlcmxheTogcmVxdWlyZSgnLi9sYXllci9vdmVybGF5L092ZXJsYXknKSxcclxuXHRQb2ludE92ZXJsYXk6IHJlcXVpcmUoJy4vbGF5ZXIvb3ZlcmxheS9Qb2ludE92ZXJsYXknKSxcclxuXHRQb2x5bGluZU92ZXJsYXk6IHJlcXVpcmUoJy4vbGF5ZXIvb3ZlcmxheS9Qb2x5bGluZU92ZXJsYXknKSxcclxuXHRQb2x5Z29uT3ZlcmxheTogcmVxdWlyZSgnLi9sYXllci9vdmVybGF5L1BvbHlnb25PdmVybGF5JyksXHJcblx0Ly8gcmVuZGVyZXJcclxuXHRSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci9SZW5kZXJlcicpLFxyXG5cdC8vIHRpbGUgcmVuZGVyZXJcclxuXHRUaWxlUmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXIvdGlsZS9UaWxlUmVuZGVyZXInKSxcclxuXHQvLyB3ZWJnbCB0aWxlIHJlbmRlcmVyXHJcblx0V2ViR0xUaWxlUmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXIvdGlsZS9XZWJHTFRpbGVSZW5kZXJlcicpLFxyXG5cdEltYWdlVGlsZVJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVyL3RpbGUvc2FtcGxlL0ltYWdlVGlsZVJlbmRlcmVyJyksXHJcblx0SW50ZXJhY3RpdmVUaWxlUmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXIvdGlsZS9zYW1wbGUvSW50ZXJhY3RpdmVUaWxlUmVuZGVyZXInKSxcclxuXHRQb2ludFRpbGVSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci90aWxlL3NhbXBsZS9Qb2ludFRpbGVSZW5kZXJlcicpLFxyXG5cdEluc3RhbmNlZFRpbGVSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci90aWxlL3NhbXBsZS9JbnN0YW5jZWRUaWxlUmVuZGVyZXInKSxcclxuXHQvLyBvdmVybGF5IHJlbmRlcmVyXHJcblx0T3ZlcmxheVJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVyL292ZXJsYXkvT3ZlcmxheVJlbmRlcmVyJyksXHJcblx0Ly8gd2ViZ2wgb3ZlcmxheSByZW5kZXJlclxyXG5cdFdlYkdMT3ZlcmxheVJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVyL292ZXJsYXkvV2ViR0xPdmVybGF5UmVuZGVyZXInKSxcclxuXHRQb2ludE92ZXJsYXlSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci9vdmVybGF5L3NhbXBsZS9Qb2ludE92ZXJsYXlSZW5kZXJlcicpLFxyXG5cdFBvbHlsaW5lT3ZlcmxheVJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVyL292ZXJsYXkvc2FtcGxlL1BvbHlsaW5lT3ZlcmxheVJlbmRlcmVyJyksXHJcblx0UG9seWdvbk92ZXJsYXlSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci9vdmVybGF5L3NhbXBsZS9Qb2x5Z29uT3ZlcmxheVJlbmRlcmVyJyksXHJcblx0Ly8gd2ViZ2wgc2hhZGVyXHJcblx0U2hhZGVyOiByZXF1aXJlKCcuL3dlYmdsL3NoYWRlci9TaGFkZXInKSxcclxuXHQvLyB3ZWJnbCB0ZXh0dXJlXHJcblx0VGV4dHVyZTogcmVxdWlyZSgnLi93ZWJnbC90ZXh0dXJlL1RleHR1cmUnKSxcclxuXHRUZXh0dXJlQXJyYXk6IHJlcXVpcmUoJy4vd2ViZ2wvdGV4dHVyZS9UZXh0dXJlQXJyYXknKSxcclxuXHQvLyB3ZWJnbCB2ZXJ0ZXhcclxuXHRWZXJ0ZXhBdGxhczogcmVxdWlyZSgnLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QXRsYXMnKSxcclxuXHRWZXJ0ZXhCdWZmZXI6IHJlcXVpcmUoJy4vd2ViZ2wvdmVydGV4L1ZlcnRleEJ1ZmZlcicpLFxyXG5cdEluZGV4QnVmZmVyOiByZXF1aXJlKCcuL3dlYmdsL3ZlcnRleC9JbmRleEJ1ZmZlcicpLFxyXG5cdC8vIHV0aWxcclxuXHRsb2FkQnVmZmVyOiByZXF1aXJlKCcuL3V0aWwvbG9hZEJ1ZmZlcicpLFxyXG5cdGxvYWRJbWFnZTogcmVxdWlyZSgnLi91dGlsL2xvYWRJbWFnZScpXHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuY29uc3QgSU5TSURFID0gMHgwMDsgLy8gMDAwMFxyXG5jb25zdCBMRUZUID0gMHgwMTsgICAvLyAwMDAxXHJcbmNvbnN0IFJJR0hUID0gMHgwMjsgIC8vIDAwMTBcclxuY29uc3QgQk9UVE9NID0gMHgwNDsgLy8gMDEwMFxyXG5jb25zdCBUT1AgPSAweDA4OyAgICAvLyAxMDAwXHJcblxyXG5jb25zdCBjb21wdXRlQ29kZSA9IGZ1bmN0aW9uKGJvdW5kcywgeCwgeSkge1xyXG5cdGxldCBjb2RlID0gSU5TSURFO1xyXG5cdGlmICh4IDwgYm91bmRzLmxlZnQpIHtcclxuXHRcdC8vIHRvIHRoZSBsZWZ0IG9mIGNsaXAgd2luZG93XHJcblx0XHRjb2RlIHw9IExFRlQ7XHJcblx0fSBlbHNlIGlmICh4ID4gYm91bmRzLnJpZ2h0KSB7XHJcblx0XHQvLyB0byB0aGUgcmlnaHQgb2YgY2xpcCB3aW5kb3dcclxuXHRcdGNvZGUgfD0gUklHSFQ7XHJcblx0fVxyXG5cdGlmICh5IDwgYm91bmRzLmJvdHRvbSkge1xyXG5cdFx0Ly8gYmVsb3cgdGhlIGNsaXAgd2luZG93XHJcblx0XHRjb2RlIHw9IEJPVFRPTTtcclxuXHR9IGVsc2UgaWYgKHkgPiBib3VuZHMudG9wKSB7XHJcblx0XHQvLyBhYm92ZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdGNvZGUgfD0gVE9QO1xyXG5cdH1cclxuXHRyZXR1cm4gY29kZTtcclxufTtcclxuXHJcbmNvbnN0IHN1dGhlcmxhbmRIb2RnZW1hbkNsaXAgPSBmdW5jdGlvbihib3VuZHMsIHBvaW50cykge1xyXG5cdC8vIFN1dGhlcmxhbmQtSG9kZ2VtYW4gY2xpcHBpbmcgYWxnb3JpdGhtIGNsaXBzIGEgcG9seWdvbiBhZ2FpbnN0IGFcclxuXHQvLyByZWN0YW5nbGUuXHJcblxyXG5cdGxldCByZXN1bHQ7XHJcblx0Zm9yIChsZXQgY29kZT0xOyBjb2RlPD04OyBjb2RlKj0yKSB7XHJcblx0XHRyZXN1bHQgPSBbXTtcclxuXHRcdGxldCBwcmV2ID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcclxuXHRcdGxldCBwcmV2SW5zaWRlID0gIShjb21wdXRlQ29kZShib3VuZHMsIHByZXYueCwgcHJldi55KSAmIGNvZGUpO1xyXG5cdFx0Zm9yIChsZXQgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjb25zdCBwID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRjb25zdCBpbnNpZGUgPSAhKGNvbXB1dGVDb2RlKGJvdW5kcywgcC54LCBwLnkpICYgY29kZSk7XHJcblx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyB0aHJvdWdoIHRoZSBjbGlwIHdpbmRvdywgYWRkIGFuIGludGVyc2VjdGlvblxyXG5cdFx0XHRpZiAoaW5zaWRlICE9PSBwcmV2SW5zaWRlKSB7XHJcblx0XHRcdFx0Y29uc3QgYXggPSBwcmV2Lng7XHJcblx0XHRcdFx0Y29uc3QgYXkgPSBwcmV2Lnk7XHJcblx0XHRcdFx0Y29uc3QgYnggPSBwLng7XHJcblx0XHRcdFx0Y29uc3QgYnkgPSBwLnk7XHJcblx0XHRcdFx0bGV0IHgsIHkgPSAwO1xyXG5cdFx0XHRcdGlmIChjb2RlICYgVE9QKSB7XHJcblx0XHRcdFx0XHQvLyBwb2ludCBpcyBhYm92ZSB0aGUgY2xpcCByZWN0YW5nbGVcclxuXHRcdFx0XHRcdHggPSBheCArIChieCAtIGF4KSAqIChib3VuZHMudG9wIC0gYXkpIC8gKGJ5IC0gYXkpO1xyXG5cdFx0XHRcdFx0eSA9IGJvdW5kcy50b3A7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjb2RlICYgQk9UVE9NKSB7XHJcblx0XHRcdFx0XHQvLyBwb2ludCBpcyBiZWxvdyB0aGUgY2xpcCByZWN0YW5nbGVcclxuXHRcdFx0XHRcdHggPSBheCArIChieCAtIGF4KSAqIChib3VuZHMuYm90dG9tIC0gYXkpIC8gKGJ5IC0gYXkpO1xyXG5cdFx0XHRcdFx0eSA9IGJvdW5kcy5ib3R0b207XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjb2RlICYgUklHSFQpIHtcclxuXHRcdFx0XHRcdC8vIHBvaW50IGlzIHRvIHRoZSByaWdodCBvZiBjbGlwIHJlY3RhbmdsZVxyXG5cdFx0XHRcdFx0eSA9IGF5ICsgKGJ5IC0gYXkpICogKGJvdW5kcy5yaWdodCAtIGF4KSAvIChieCAtIGF4KTtcclxuXHRcdFx0XHRcdHggPSBib3VuZHMucmlnaHQ7XHJcblx0XHRcdFx0fSBlbHNlIHsgLy9pZiAoY29kZSAmIExFRlQpIHtcclxuXHRcdFx0XHRcdC8vIHBvaW50IGlzIHRvIHRoZSBsZWZ0IG9mIGNsaXAgcmVjdGFuZ2xlXHJcblx0XHRcdFx0XHR5ID0gYXkgKyAoYnkgLSBheSkgKiAoYm91bmRzLmxlZnQgLSBheCkgLyAoYnggLSBheCk7XHJcblx0XHRcdFx0XHR4ID0gYm91bmRzLmxlZnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKHtcclxuXHRcdFx0XHRcdHg6IHgsXHJcblx0XHRcdFx0XHR5OiB5XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGluc2lkZSkge1xyXG5cdFx0XHRcdC8vIGFkZCBhIHBvaW50IGlmIGl0J3MgaW5zaWRlXHJcblx0XHRcdFx0cmVzdWx0LnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldiA9IHA7XHJcblx0XHRcdHByZXZJbnNpZGUgPSBpbnNpZGU7XHJcblx0XHR9XHJcblx0XHRwb2ludHMgPSByZXN1bHQ7XHJcblx0XHRpZiAoIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZXN1bHQubGVuZ3RoID4gMCA/IHJlc3VsdCA6IG51bGw7XHJcbn07XHJcblxyXG5jb25zdCBjb2hlblN1dGhlcmxhbmRDbGlwID0gZnVuY3Rpb24oYm91bmRzLCBhLCBiKSB7XHJcblx0Ly8gQ29oZW7igJNTdXRoZXJsYW5kIGNsaXBwaW5nIGFsZ29yaXRobSBjbGlwcyBhIGxpbmUgYWdhaW5zdCBhIHJlY3RhbmdsZS5cclxuXHJcblx0Ly8gY29weSBzbyB3ZSBkb24ndCBjaGFuZ2UgaW4tcGxhY2VcclxuXHRsZXQgYXggPSBhLng7XHJcblx0bGV0IGF5ID0gYS55O1xyXG5cdGxldCBieCA9IGIueDtcclxuXHRsZXQgYnkgPSBiLnk7XHJcblx0Ly8gY29tcHV0ZSBvdXRjb2RlcyBmb3IgUDAsIFAxLCBhbmQgd2hhdGV2ZXIgcG9pbnQgbGllcyBvdXRzaWRlIHRoZSBjbGlwIHJlY3RhbmdsZVxyXG5cdGxldCBhQ29kZSA9IGNvbXB1dGVDb2RlKGJvdW5kcywgYXgsIGF5KTtcclxuXHRsZXQgYkNvZGUgPSBjb21wdXRlQ29kZShib3VuZHMsIGJ4LCBieSk7XHJcblx0bGV0IGFjY2VwdCA9IGZhbHNlO1xyXG5cdC8vIG5vcm1hbCBhbGcgaGFzIGluZmlpbml0ZSB3aGlsZSBsb29wLCBjYXAgYXQgOCBpdGVyYXRpb25zIGp1c3QgaW4gY2FzZVxyXG5cdGNvbnN0IE1BWF9JVEVSQVRJT05TID0gODtcclxuXHRsZXQgaXRlciA9IDA7XHJcblx0d2hpbGUgKGl0ZXIgPCBNQVhfSVRFUkFUSU9OUykge1xyXG5cdFx0aWYgKCEoYUNvZGUgfCBiQ29kZSkpIHtcclxuXHRcdFx0Ly8gYml0d2lzZSBPUiBpcyAwLiBUcml2aWFsbHkgYWNjZXB0IGFuZCBnZXQgb3V0IG9mIGxvb3BcclxuXHRcdFx0YWNjZXB0ID0gdHJ1ZTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9IGVsc2UgaWYgKGFDb2RlICYgYkNvZGUpIHtcclxuXHRcdFx0Ly8gYml0d2lzZSBBTkQgaXMgbm90IDAuIChpbXBsaWVzIGJvdGggZW5kIHBvaW50cyBhcmUgaW4gdGhlIHNhbWVcclxuXHRcdFx0Ly8gcmVnaW9uIG91dHNpZGUgdGhlIHdpbmRvdykuIFJlamVjdCBhbmQgZ2V0IG91dCBvZiBsb29wXHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gZmFpbGVkIGJvdGggdGVzdHMsIHNvIGNhbGN1bGF0ZSB0aGUgbGluZSBzZWdtZW50IHRvIGNsaXBcclxuXHRcdFx0Ly8gZnJvbSBhbiBvdXRzaWRlIHBvaW50IHRvIGFuIGludGVyc2VjdGlvbiB3aXRoIGNsaXAgZWRnZVxyXG5cdFx0XHRsZXQgeCwgeSA9IDA7XHJcblx0XHRcdC8vIEF0IGxlYXN0IG9uZSBlbmRwb2ludCBpcyBvdXRzaWRlIHRoZSBjbGlwIHJlY3RhbmdsZTsgcGljayBpdC5cclxuXHRcdFx0Y29uc3QgY29kZSA9IGFDb2RlID8gYUNvZGUgOiBiQ29kZTtcclxuXHRcdFx0Ly8gTm93IGZpbmQgdGhlIGludGVyc2VjdGlvbiBwb2ludDtcclxuXHRcdFx0Ly8gdXNlIGZvcm11bGFzXHJcblx0XHRcdC8vIHkgPSBheSArIHNsb3BlICogKHggLSBheCksIHggPSBheCArICgxIC8gc2xvcGUpICogKHkgLSBheSlcclxuXHRcdFx0aWYgKGNvZGUgJiBUT1ApIHtcclxuXHRcdFx0XHQvLyBwb2ludCBpcyBhYm92ZSB0aGUgY2xpcCByZWN0YW5nbGVcclxuXHRcdFx0XHR4ID0gYXggKyAoYnggLSBheCkgKiAoYm91bmRzLnRvcCAtIGF5KSAvIChieSAtIGF5KTtcclxuXHRcdFx0XHR5ID0gYm91bmRzLnRvcDtcclxuXHRcdFx0fSBlbHNlIGlmIChjb2RlICYgQk9UVE9NKSB7XHJcblx0XHRcdFx0Ly8gcG9pbnQgaXMgYmVsb3cgdGhlIGNsaXAgcmVjdGFuZ2xlXHJcblx0XHRcdFx0eCA9IGF4ICsgKGJ4IC0gYXgpICogKGJvdW5kcy5ib3R0b20gLSBheSkgLyAoYnkgLSBheSk7XHJcblx0XHRcdFx0eSA9IGJvdW5kcy5ib3R0b207XHJcblx0XHRcdH0gZWxzZSBpZiAoY29kZSAmIFJJR0hUKSB7XHJcblx0XHRcdFx0Ly8gcG9pbnQgaXMgdG8gdGhlIHJpZ2h0IG9mIGNsaXAgcmVjdGFuZ2xlXHJcblx0XHRcdFx0eSA9IGF5ICsgKGJ5IC0gYXkpICogKGJvdW5kcy5yaWdodCAtIGF4KSAvIChieCAtIGF4KTtcclxuXHRcdFx0XHR4ID0gYm91bmRzLnJpZ2h0O1xyXG5cdFx0XHR9IGVsc2UgeyAvL2lmIChjb2RlICYgTEVGVCkge1xyXG5cdFx0XHRcdC8vIHBvaW50IGlzIHRvIHRoZSBsZWZ0IG9mIGNsaXAgcmVjdGFuZ2xlXHJcblx0XHRcdFx0eSA9IGF5ICsgKGJ5IC0gYXkpICogKGJvdW5kcy5sZWZ0IC0gYXgpIC8gKGJ4IC0gYXgpO1xyXG5cdFx0XHRcdHggPSBib3VuZHMubGVmdDtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBub3cgd2UgbW92ZSBvdXRzaWRlIHBvaW50IHRvIGludGVyc2VjdGlvbiBwb2ludCB0byBjbGlwXHJcblx0XHRcdC8vIGFuZCBnZXQgcmVhZHkgZm9yIG5leHQgcGFzcy5cclxuXHRcdFx0aWYgKGNvZGUgPT09IGFDb2RlKSB7XHJcblx0XHRcdFx0YXggPSB4O1xyXG5cdFx0XHRcdGF5ID0geTtcclxuXHRcdFx0XHRhQ29kZSA9IGNvbXB1dGVDb2RlKGJvdW5kcywgYXgsIGF5KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRieCA9IHg7XHJcblx0XHRcdFx0YnkgPSB5O1xyXG5cdFx0XHRcdGJDb2RlID0gY29tcHV0ZUNvZGUoYm91bmRzLCBieCwgYnkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpdGVyKys7XHJcblx0fVxyXG5cdGlmIChhY2NlcHQpIHtcclxuXHRcdHJldHVybiBbXHJcblx0XHRcdHsgeDogYXgsIHk6IGF5IH0sXHJcblx0XHRcdHsgeDogYngsIHk6IGJ5IH1cclxuXHRcdF07XHJcblx0fVxyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHNldCBvZiBib3VuZHMuXHJcbiAqL1xyXG5jbGFzcyBCb3VuZHMge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgQm91bmRzIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IC0gVGhlIGxlZnQgYm91bmQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IC0gVGhlIHJpZ2h0IGJvdW5kLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gLSBUaGUgYm90dG9tIGJvdW5kLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgLSBUaGUgdG9wIGJvdW5kLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCkge1xyXG5cdFx0dGhpcy5sZWZ0ID0gbGVmdDtcclxuXHRcdHRoaXMucmlnaHQgPSByaWdodDtcclxuXHRcdHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG5cdFx0dGhpcy50b3AgPSB0b3A7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBib3VuZHMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGJvdW5kcy5cclxuXHQgKi9cclxuXHRnZXRXaWR0aCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kcy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kcy5cclxuXHQgKi9cclxuXHRnZXRIZWlnaHQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50b3AgLSB0aGlzLmJvdHRvbTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4dGVuZHMgdGhlIGJvdW5kcyBieSB0aGUgcHJvdmlkZWQgcG9pbnQgb3IgYm91bmRzIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fEJvdW5kc30gYXJnIC0gVGhlIHBvaW50IG9yIGJvdW5kcyB0byBleHRlbmQgdGhlIGJvdW5kcyBieS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtCb3VuZHN9IFRoZSBib3VuZHMgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZXh0ZW5kKGFyZykge1xyXG5cdFx0aWYgKGFyZy5sZWZ0ICE9PSB1bmRlZmluZWQgJiZcclxuXHRcdFx0YXJnLnJpZ2h0ICE9PSB1bmRlZmluZWQgJiZcclxuXHRcdFx0YXJnLmJvdHRvbSAhPT0gdW5kZWZpbmVkICYmXHJcblx0XHRcdGFyZy50b3AgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvLyBib3VuZHNcclxuXHRcdFx0aWYgKGFyZy5sZWZ0IDwgdGhpcy5sZWZ0KSB7XHJcblx0XHRcdFx0dGhpcy5sZWZ0ID0gYXJnLmxlZnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGFyZy5yaWdodCA+IHRoaXMucmlnaHQpIHtcclxuXHRcdFx0XHR0aGlzLnJpZ2h0ID0gYXJnLnJpZ2h0O1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChhcmcuYm90dG9tIDwgdGhpcy5ib3R0b20pIHtcclxuXHRcdFx0XHR0aGlzLmJvdHRvbSA9IGFyZy5ib3R0b207XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGFyZy50b3AgPiB0aGlzLnRvcCkge1xyXG5cdFx0XHRcdHRoaXMudG9wID0gYXJnLnRvcDtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gcG9pbnRcclxuXHRcdFx0aWYgKGFyZy54IDwgdGhpcy5sZWZ0KSB7XHJcblx0XHRcdFx0dGhpcy5sZWZ0ID0gYXJnLng7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGFyZy54ID4gdGhpcy5yaWdodCkge1xyXG5cdFx0XHRcdHRoaXMucmlnaHQgPSBhcmcueDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoYXJnLnkgPCB0aGlzLmJvdHRvbSkge1xyXG5cdFx0XHRcdHRoaXMuYm90dG9tID0gYXJnLnk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGFyZy55ID4gdGhpcy50b3ApIHtcclxuXHRcdFx0XHR0aGlzLnRvcCA9IGFyZy55O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGNlbnRlciBjb29yZGluYXRlIG9mIHRoZSBib3VuZHMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY2VudGVyIGNvb3JkaW5hdGUgb2YgdGhlIGJvdW5kcy5cclxuXHQgKi9cclxuXHRnZXRDZW50ZXIoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB0aGlzLmxlZnQgKyAodGhpcy5nZXRXaWR0aCgpIC8gMiksXHJcblx0XHRcdHk6IHRoaXMuYm90dG9tICsgKHRoaXMuZ2V0SGVpZ2h0KCkgLyAyKVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3QgaWYgdGhlIGJvdW5kcyBlcXVhbHMgYW5vdGhlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Qm91bmRzfSBib3VuZHMgLSBUaGUgYm91bmRzIG9iamVjdCB0byB0ZXN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBib3VuZHMgb2JqZWN0cyBhcmUgZXF1YWwuXHJcblx0ICovXHJcblx0ZXF1YWxzKGJvdW5kcykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGVmdCA9PT0gYm91bmRzLmxlZnQgJiZcclxuXHRcdFx0dGhpcy5yaWdodCA9PT0gYm91bmRzLnJpZ2h0ICYmXHJcblx0XHRcdHRoaXMuYm90dG9tID09PSBib3VuZHMuYm90dG9tICYmXHJcblx0XHRcdHRoaXMudG9wID09PSBib3VuZHMudG9wO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGVzdCBpZiB0aGUgYm91bmRzIG92ZXJsYXBzIGFub3RoZXIuIFRlc3QgaXMgaW5jbHVzaXZlIG9mIGVkZ2VzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtCb3VuZHN9IGJvdW5kcyAtIFRoZSBib3VuZHMgb2JqZWN0IHRvIHRlc3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGJvdW5kcyBvdmVybGFwIGVhY2hvdGhlci5cclxuXHQgKi9cclxuXHRvdmVybGFwcyhib3VuZHMpIHtcclxuXHRcdC8vIE5PVEU6IGluY2x1c2l2ZSBvZiBlZGdlc1xyXG5cdFx0cmV0dXJuICEodGhpcy5sZWZ0ID4gYm91bmRzLnJpZ2h0IHx8XHJcblx0XHRcdHRoaXMucmlnaHQgPCBib3VuZHMubGVmdCB8fFxyXG5cdFx0XHR0aGlzLnRvcCA8IGJvdW5kcy5ib3R0b20gfHxcclxuXHRcdFx0dGhpcy5ib3R0b20gPiBib3VuZHMudG9wKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBib3VuZHMuIFRlc3QgaXMgaW5jbHVzaXZlIG9mIGVkZ2VzLiBJZlxyXG5cdCAqIHRoZSBib3VuZHMgZG8gbm90IGludGVyc2VjdCwgcmV0dXJucyB1bmRlZmluZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0JvdW5kc30gYm91bmRzIC0gVGhlIGJvdW5kcyBvYmplY3QgdG8gaW50ZXJzZWN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0JvdW5kc30gVGhlIGludGVyc2VjdGlvbiBvZiBib3RoIGJvdW5kcy5cclxuXHQgKi9cclxuXHRpbnRlcnNlY3Rpb24oYm91bmRzKSB7XHJcblx0XHQvLyBOT1RFOiBpbmNsdXNpdmUgb2YgZWRnZXNcclxuXHRcdGlmICghdGhpcy5vdmVybGFwcyhib3VuZHMpKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhcclxuXHRcdFx0TWF0aC5tYXgodGhpcy5sZWZ0LCBib3VuZHMubGVmdCksXHJcblx0XHRcdE1hdGgubWluKHRoaXMucmlnaHQsIGJvdW5kcy5yaWdodCksXHJcblx0XHRcdE1hdGgubWF4KHRoaXMuYm90dG9tLCBib3VuZHMuYm90dG9tKSxcclxuXHRcdFx0TWF0aC5taW4odGhpcy50b3AsIGJvdW5kcy50b3ApKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsaXBzIHRoZSBwcm92aWRlZCBsaW5lIHNlZ21lbnQgdG8gd2l0aGluIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3VuZHMuXHJcblx0ICogVGVzdCBpcyBpbmNsdXNpdmUgb2YgZWRnZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBsaW5lIC0gVGhlIGxpbmUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBjbGlwcGVkIGxpbmUsIG9yIG51bGwgaWYgaXQgaXMgb3V0c2lkZSB0aGUgYm91bmRzLlxyXG5cdCAqL1xyXG5cdGNsaXBMaW5lKGxpbmUpIHtcclxuXHRcdGlmICghbGluZSB8fCBsaW5lLmxlbmd0aCAhPT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb2hlblN1dGhlcmxhbmRDbGlwKHRoaXMsIGxpbmVbMF0sIGxpbmVbMV0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2xpcHMgdGhlIHByb3ZpZGVkIHBvbHlsaW5lIHRvIHdpdGhpbiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYm91bmRzLiBXaWxsXHJcblx0ICogcmV0dXJuIGFuIGFycmF5IG9mIGNsaXBwZWQgcG9seWxpbmVzIGFzIHJlc3VsdC5cclxuXHQgKiBUZXN0IGlzIGluY2x1c2l2ZSBvZiBlZGdlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBvbHlsaW5lIC0gVGhlIHBvbHlsaW5lLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgcmVzdWx0aW5nIGNsaXBwZWQgcG9seWxpbmVzLCBvciBudWxsIGlmIGl0IGlzIG91dHNpZGUgdGhlIGJvdW5kcy5cclxuXHQgKi9cclxuXHRjbGlwUG9seWxpbmUocG9seWxpbmUpIHtcclxuXHRcdGlmICghcG9seWxpbmUgfHwgcG9seWxpbmUubGVuZ3RoIDwgMikge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdGNvbnN0IGNsaXBwZWQgPSBbXTtcclxuXHRcdGxldCBjdXJyZW50ID0gW107XHJcblx0XHRmb3IgKGxldCBpPTE7IGk8cG9seWxpbmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgYSA9IHBvbHlsaW5lW2ktMV07XHJcblx0XHRcdGNvbnN0IGIgPSBwb2x5bGluZVtpXTtcclxuXHRcdFx0Ly8gY2xpcCB0aGUgbGluZVxyXG5cdFx0XHRjb25zdCBsaW5lID0gY29oZW5TdXRoZXJsYW5kQ2xpcCh0aGlzLCBhLCBiKTtcclxuXHRcdFx0Ly8gbm8gbGluZSBpbiBib3VuZHNcclxuXHRcdFx0aWYgKCFsaW5lKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0Y29uc3QgY2xpcHBlZEEgPSBsaW5lWzBdO1xyXG5cdFx0XHRjb25zdCBjbGlwcGVkQiA9IGxpbmVbMV07XHJcblx0XHRcdC8vIGFkZCBzcmMgcG9pbnRcclxuXHRcdFx0Y3VycmVudC5wdXNoKGNsaXBwZWRBKTtcclxuXHRcdFx0aWYgKChjbGlwcGVkQi54ICE9PSBiLnggJiYgY2xpcHBlZEIueSAhPT0gYi55KSB8fFxyXG5cdFx0XHRcdGkgPT09IHBvbHlsaW5lLmxlbmd0aCAtIDEpIHtcclxuXHRcdFx0XHQvLyBvbmx5IGFkZCBkZXN0aW5hdGlvbiBwb2ludCBpZiBpdCB3YXMgY2xpcHBlZCwgb3IgaXMgbGFzdFxyXG5cdFx0XHRcdC8vIHBvaW50XHJcblx0XHRcdFx0Y3VycmVudC5wdXNoKGNsaXBwZWRCKTtcclxuXHRcdFx0XHQvLyB0aGVuIGJyZWFrIHRoZSBwb2x5bGluZVxyXG5cdFx0XHRcdGNsaXBwZWQucHVzaChjdXJyZW50KTtcclxuXHRcdFx0XHRjdXJyZW50ID0gW107XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBjbGlwcGVkLmxlbmd0aCA+IDAgPyBjbGlwcGVkIDogbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsaXBzIHRoZSBwcm92aWRlZCBwb2ludHMgdG8gdGhvc2Ugd2l0aGluIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3VuZHMuXHJcblx0ICogVGVzdCBpcyBpbmNsdXNpdmUgb2YgZWRnZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgLSBUaGUgcG9pbnRzIHRvIGNsaXAuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBjbGlwcGVkIHBvaW50cywgb3IgbnVsbCBpZiBub25lIGFyZSB3aXRoaW4gdGhlIGJvdW5kcy5cclxuXHQgKi9cclxuXHRjbGlwUG9pbnRzKHBvaW50cykge1xyXG5cdFx0aWYgKCFwb2ludHMpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0XHRjb25zdCBjbGlwcGVkID0gW107XHJcblx0XHRmb3IgKGxldCBpPTA7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRpZiAocG9pbnQueCA+PSB0aGlzLmxlZnQgJiZcclxuXHRcdFx0XHRwb2ludC54IDw9IHRoaXMucmlnaHQgJiZcclxuXHRcdFx0XHRwb2ludC55ID49IHRoaXMuYm90dG9tICYmXHJcblx0XHRcdFx0cG9pbnQueSA8PSB0aGlzLnRvcCkge1xyXG5cdFx0XHRcdGNsaXBwZWQucHVzaChwb2ludCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBjbGlwcGVkLmxlbmd0aCA+IDAgPyBjbGlwcGVkIDogbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsaXBzIHRoZSBwcm92aWRlZCBwb2x5Z29uIHRvIHRob3NlIHdpdGhpbiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYm91bmRzLlxyXG5cdCAqIFRlc3QgaXMgaW5jbHVzaXZlIG9mIGVkZ2VzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtBcnJheX0gcG9seWdvbiAtIFRoZSBwb2ludHMgb2YgdGhlIHBvbHlnb24gdG8gY2xpcC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGNsaXBwZWQgcG9pbnRzIG9mIHRoZSBwb2x5Z29uLCBvciBudWxsIGlmIGl0IGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kcy5cclxuXHQgKi9cclxuXHRjbGlwUG9seWdvbihwb2x5Z29uKSB7XHJcblx0XHRpZiAoIXBvbHlnb24gfHwgcG9seWdvbi5sZW5ndGggPCAzKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN1dGhlcmxhbmRIb2RnZW1hbkNsaXAodGhpcywgcG9seWdvbik7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJvdW5kcztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgY2xhbXAgPSByZXF1aXJlKCdsb2Rhc2gvY2xhbXAnKTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjaXJjbGUgY29sbGlkYWJsZS5cclxuICovXHJcbmNsYXNzIENpcmNsZUNvbGxpZGFibGUge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgQ2lyY2xlQ29sbGlkYWJsZSBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB0aWxlIHggcGl4ZWwgY29vcmRpbmF0ZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB0aWxlIHkgcGl4ZWwgY29vcmRpbmF0ZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBpbiBwaXhlbHMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHhPZmZzZXQgLSBUaGUgdGlsZSB4IG9mZnNldCBpbiBwaXhlbHMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXQgLSBUaGUgdGlsZSB5IG9mZnNldCBpbiBwaXhlbHMuXHJcblx0ICogQHBhcmFtIHtUaWxlfSB0aWxlIC0gVGhlIHRpbGUgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gQW55IGFyYml0cmFyeSB1c2VyIGRhdGEuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoeCwgeSwgcmFkaXVzLCB4T2Zmc2V0LCB5T2Zmc2V0LCB0aWxlLCBkYXRhKSB7XHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cdFx0dGhpcy5taW5YID0geCArIHhPZmZzZXQgLSByYWRpdXM7XHJcblx0XHR0aGlzLm1heFggPSB4ICsgeE9mZnNldCArIHJhZGl1cztcclxuXHRcdHRoaXMubWluWSA9IHkgKyB5T2Zmc2V0IC0gcmFkaXVzO1xyXG5cdFx0dGhpcy5tYXhZID0geSArIHlPZmZzZXQgKyByYWRpdXM7XHJcblx0XHR0aGlzLnRpbGUgPSB0aWxlO1xyXG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3QgaWYgdGhlIHByb3ZpZGVkIHBvc2l0aW9uIGlzIHdpdGhpbiB0aGUgaW5uZXIgc2hhcGUgb2YgdGhlIGNvbGxpZGFibGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHBvc2l0aW9uIHRvIHRlc3QuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBwb3NpdGlvbiB0byB0ZXN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2x9IFdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbi5cclxuXHQgKi9cclxuXHR0ZXN0UG9pbnQoeCwgeSkge1xyXG5cdFx0Ly8gY2VudGVyIHBvc1xyXG5cdFx0Y29uc3QgY3ggPSAodGhpcy5taW5YICsgdGhpcy5tYXhYKSAqIDAuNTtcclxuXHRcdGNvbnN0IGN5ID0gKHRoaXMubWluWSArIHRoaXMubWF4WSkgKiAwLjU7XHJcblx0XHQvLyBkaXN0YW5jZSB0byBwb2ludFxyXG5cdFx0Y29uc3QgZHggPSBjeCAtIHg7XHJcblx0XHRjb25zdCBkeSA9IGN5IC0geTtcclxuXHRcdHJldHVybiAoZHggKiBkeCArIGR5ICogZHkpIDw9ICh0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3QgaWYgdGhlIHByb3ZpZGVkIHJlY3RhbmdsZSBpcyB3aXRoaW4gdGhlIGlubmVyIHNoYXBlIG9mIHRoZVxyXG5cdCAqIGNvbGxpZGFibGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluWCAtIFRoZSBtaW5pbXVtIHggY29tcG9uZW50LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIC0gVGhlIG1heGltdW0geCBjb21wb25lbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblkgLSBUaGUgbWluaW11bSB5IGNvbXBvbmVudC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4WSAtIFRoZSBtYXhpbXVtIHkgY29tcG9uZW50LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2x9IFdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbi5cclxuXHQgKi9cclxuXHR0ZXN0UmVjdGFuZ2xlKG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcclxuXHRcdC8vIGNpcmNsZSBwb3NcclxuXHRcdGNvbnN0IGN4ID0gKHRoaXMubWluWCArIHRoaXMubWF4WCkgKiAwLjU7XHJcblx0XHRjb25zdCBjeSA9ICh0aGlzLm1pblkgKyB0aGlzLm1heFkpICogMC41O1xyXG5cdFx0Ly8gZmluZCBjbG9zZXN0IHBvaW50IGluIHJlY3RhbmdsZSB0byBjaXJjbGVcclxuXHRcdGNvbnN0IG5lYXJlc3RYID0gY2xhbXAoY3gsIG1pblgsIG1heFgpO1xyXG5cdFx0Y29uc3QgbmVhcmVzdFkgPSBjbGFtcChjeSwgbWluWSwgbWF4WSk7XHJcblx0XHQvLyB0ZXN0IGRpc3RhbmNlXHJcblx0XHRjb25zdCBkeCA9IGN4IC0gbmVhcmVzdFg7XHJcblx0XHRjb25zdCBkeSA9IGN5IC0gbmVhcmVzdFk7XHJcblx0XHRyZXR1cm4gKGR4ICogZHggKyBkeSAqIGR5KSA8ICh0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlQ29sbGlkYWJsZTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xyXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIHItdHJlZS5cclxuICovXHJcbmNsYXNzIFJUcmVlIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFJUcmVlIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5ub2RlQ2FwYWNpdHkgLSBUaGUgbm9kZSBjYXBhY2l0eSBvZiB0aGUgci10cmVlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuXHRcdHRoaXMudHJlZSA9IHJidXNoKGRlZmF1bHRUbyhvcHRpb25zLm5vZGVDYXBhY2l0eSwgMzIpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc2VydHMgYW4gYXJyYXkgb2YgY29sbGlkYWJsZXMgaW50byB0aGUgci10cmVlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtBcnJheX0gY29sbGlkYWJsZXMgLSBUaGUgYXJyYXkgb2YgY29sbGlkYWJsZXMgdG8gaW5zZXJ0LlxyXG5cdCAqL1xyXG5cdGluc2VydChjb2xsaWRhYmxlcykge1xyXG5cdFx0dGhpcy50cmVlLmxvYWQoY29sbGlkYWJsZXMpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhbiBhcnJheSBvZiBjb2xsaWRhYmxlcyBmcm9tIHRoZSByLXRyZWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xsaWRhYmxlcyAtIFRoZSBhcnJheSBvZiBjb2xsaWRhYmxlcyB0byByZW1vdmUuXHJcblx0ICovXHJcblx0cmVtb3ZlKGNvbGxpZGFibGVzKSB7XHJcblx0XHRjb25zdCB0cmVlID0gdGhpcy50cmVlO1xyXG5cdFx0Zm9yIChsZXQgaT0wOyBpPGNvbGxpZGFibGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRyZWUucmVtb3ZlKGNvbGxpZGFibGVzW2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNlYXJjaHMgdGhlIHItdHJlZSB1c2luZyBhIHBvaW50LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb21wb25lbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb21wb25lbnQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY29sbGlzaW9uIG9iamVjdC5cclxuXHQgKi9cclxuXHRzZWFyY2hQb2ludCh4LCB5KSB7XHJcblx0XHRjb25zdCBjb2xsaXNpb25zID0gdGhpcy50cmVlLnNlYXJjaCh7XHJcblx0XHRcdG1pblg6IHgsXHJcblx0XHRcdG1heFg6IHgsXHJcblx0XHRcdG1pblk6IHksXHJcblx0XHRcdG1heFk6IHlcclxuXHRcdH0pO1xyXG5cdFx0aWYgKGNvbGxpc2lvbnMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0Ly8gaW5uZXIgc2hhcGUgdGVzdFxyXG5cdFx0Zm9yIChsZXQgaT0wOyBpPGNvbGxpc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgY29sbGlzaW9uID0gY29sbGlzaW9uc1tpXTtcclxuXHRcdFx0aWYgKGNvbGxpc2lvbi50ZXN0UG9pbnQoeCwgeSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gY29sbGlzaW9uO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNlYXJjaHMgdGhlIHItdHJlZSB1c2luZyBhIHJlY3RhbmdsZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIC0gVGhlIG1pbmltdW0geCBjb21wb25lbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFggLSBUaGUgbWF4aW11bSB4IGNvbXBvbmVudC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluWSAtIFRoZSBtaW5pbXVtIHkgY29tcG9uZW50LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIC0gVGhlIG1heGltdW0geSBjb21wb25lbnQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY29sbGlzaW9uIG9iamVjdC5cclxuXHQgKi9cclxuXHRzZWFyY2hSZWN0YW5nbGUobWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xyXG5cdFx0Y29uc3QgY29sbGlzaW9ucyA9IHRoaXMudHJlZS5zZWFyY2goe1xyXG5cdFx0XHRtaW5YOiBtaW5YLFxyXG5cdFx0XHRtYXhYOiBtYXhYLFxyXG5cdFx0XHRtaW5ZOiBtaW5ZLFxyXG5cdFx0XHRtYXhZOiBtYXhZXHJcblx0XHR9KTtcclxuXHRcdGlmIChjb2xsaXNpb25zLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdC8vIGlubmVyIHNoYXBlIHRlc3RcclxuXHRcdGZvciAobGV0IGk9MDsgaTxjb2xsaXNpb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IGNvbGxpc2lvbiA9IGNvbGxpc2lvbnNbaV07XHJcblx0XHRcdGlmIChjb2xsaXNpb24udGVzdFJlY3RhbmdsZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSkge1xyXG5cdFx0XHRcdHJldHVybiBjb2xsaXNpb247XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSVHJlZTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xyXG5jb25zdCBSVHJlZSA9IHJlcXVpcmUoJy4vUlRyZWUnKTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBweXJhbWlkIG9mIHItdHJlZXMuXHJcbiAqL1xyXG5jbGFzcyBSVHJlZVB5cmFtaWQge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUlRyZWVQeXJhbWlkIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5ub2RlQ2FwYWNpdHkgLSBUaGUgbm9kZSBjYXBhY2l0eSBvZiB0aGUgci10cmVlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuXHRcdHRoaXMudHJlZXMgPSBuZXcgTWFwKCk7XHJcblx0XHR0aGlzLmNvbGxpZGFibGVzID0gbmV3IE1hcCgpO1xyXG5cdFx0dGhpcy5ub2RlQ2FwYWNpdHkgPSBkZWZhdWx0VG8ob3B0aW9ucy5ub2RlQ2FwYWNpdHksIDMyKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc2VydHMgYW4gYXJyYXkgb2YgY29sbGlkYWJsZXMgaW50byB0aGUgci10cmVlIGZvciB0aGUgcHJvdmlkZWQgY29vcmQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gY29vcmQgLSBUaGUgY29vcmQgb2YgdGhlIHRpbGUuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gY29sbGlkYWJsZXMgLSBUaGUgYXJyYXkgb2YgY29sbGlkYWJsZXMgdG8gaW5zZXJ0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1JUcmVlUHlyYW1pZH0gVGhlIFJUcmVlUHlyYW1pZCBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRpbnNlcnQoY29vcmQsIGNvbGxpZGFibGVzKSB7XHJcblx0XHRpZiAoIXRoaXMudHJlZXMuaGFzKGNvb3JkLnopKSB7XHJcblx0XHRcdHRoaXMudHJlZXMuc2V0KGNvb3JkLnosIG5ldyBSVHJlZSh7XHJcblx0XHRcdFx0bm9kZUNhcGFjaXR5OiB0aGlzLm5vZGVDYXBhY2l0eVxyXG5cdFx0XHR9KSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLnRyZWVzLmdldChjb29yZC56KS5pbnNlcnQoY29sbGlkYWJsZXMpO1xyXG5cdFx0dGhpcy5jb2xsaWRhYmxlcy5zZXQoY29vcmQuaGFzaCwgY29sbGlkYWJsZXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGFuIGFycmF5IG9mIGNvbGxpZGFibGVzIGZyb20gdGhlIHItdHJlZSBmb3IgdGhlIHByb3ZpZGVkIGNvb3JkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIGNvb3JkIG9mIHRoZSB0aWxlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1JUcmVlUHlyYW1pZH0gVGhlIFJUcmVlUHlyYW1pZCBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRyZW1vdmUoY29vcmQpIHtcclxuXHRcdGNvbnN0IGNvbGxpZGFibGVzID0gdGhpcy5jb2xsaWRhYmxlcy5nZXQoY29vcmQuaGFzaCk7XHJcblx0XHR0aGlzLnRyZWVzLmdldChjb29yZC56KS5yZW1vdmUoY29sbGlkYWJsZXMpO1xyXG5cdFx0dGhpcy5jb2xsaWRhYmxlcy5kZWxldGUoY29vcmQuaGFzaCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNlYXJjaHMgdGhlIHItdHJlZSB1c2luZyBhIHBvaW50LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb21wb25lbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb21wb25lbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgcGxvdC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZXh0ZW50IC0gVGhlIHBpeGVsIGV4dGVudCBvZiB0aGUgcGxvdCB6b29tLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGNvbGxpc2lvbiBvYmplY3QuXHJcblx0ICovXHJcblx0c2VhcmNoUG9pbnQoeCwgeSwgem9vbSwgZXh0ZW50KSB7XHJcblx0XHQvLyBwb2ludHMgYXJlIHN0b3JlZCBpbiB1bi1zY2FsZWQgY29vcmRpbmF0ZXMsIHVuc2NhbGUgdGhlIHBvaW50XHJcblx0XHRjb25zdCB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XHJcblx0XHQvLyBnZXQgdGhlIHRyZWUgZm9yIHRoZSB6b29tXHJcblx0XHRjb25zdCB0cmVlID0gdGhpcy50cmVlcy5nZXQodGlsZVpvb20pO1xyXG5cdFx0aWYgKCF0cmVlKSB7XHJcblx0XHRcdC8vIG5vIGRhdGEgZm9yIHRpbGVcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHRpbGVab29tIC0gem9vbSk7XHJcblx0XHQvLyB1bnNjYWxlZCBwb2ludHNcclxuXHRcdGNvbnN0IHN4ID0geCAqIGV4dGVudCAqIHNjYWxlO1xyXG5cdFx0Y29uc3Qgc3kgPSB5ICogZXh0ZW50ICogc2NhbGU7XHJcblx0XHQvLyBnZXQgY29sbGlzaW9uXHJcblx0XHRyZXR1cm4gdHJlZS5zZWFyY2hQb2ludChzeCwgc3kpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2VhcmNocyB0aGUgci10cmVlIHVzaW5nIGEgcmVjdGFuZ2xlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblggLSBUaGUgbWluaW11bSB4IGNvbXBvbmVudC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4WCAtIFRoZSBtYXhpbXVtIHggY29tcG9uZW50LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIC0gVGhlIG1pbmltdW0geSBjb21wb25lbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFkgLSBUaGUgbWF4aW11bSB5IGNvbXBvbmVudC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gem9vbSAtIFRoZSB6b29tIGxldmVsIG9mIHRoZSBwbG90LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBleHRlbnQgLSBUaGUgcGl4ZWwgZXh0ZW50IG9mIHRoZSBwbG90IHpvb20uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY29sbGlzaW9uIG9iamVjdC5cclxuXHQgKi9cclxuXHRzZWFyY2hSZWN0YW5nbGUobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgem9vbSwgZXh0ZW50KSB7XHJcblx0XHQvLyBwb2ludHMgYXJlIHN0b3JlZCBpbiB1bi1zY2FsZWQgY29vcmRpbmF0ZXMsIHVuc2NhbGUgdGhlIHBvaW50XHJcblx0XHRjb25zdCB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XHJcblx0XHQvLyBnZXQgdGhlIHRyZWUgZm9yIHRoZSB6b29tXHJcblx0XHRjb25zdCB0cmVlID0gdGhpcy50cmVlcy5nZXQodGlsZVpvb20pO1xyXG5cdFx0aWYgKCF0cmVlKSB7XHJcblx0XHRcdC8vIG5vIGRhdGEgZm9yIHRpbGVcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHRpbGVab29tIC0gem9vbSk7XHJcblx0XHQvLyB1bnNjYWxlZCBwb2ludHNcclxuXHRcdGNvbnN0IHNtaW5YID0gbWluWCAqIGV4dGVudCAqIHNjYWxlO1xyXG5cdFx0Y29uc3Qgc21heFggPSBtYXhYICogZXh0ZW50ICogc2NhbGU7XHJcblx0XHRjb25zdCBzbWluWSA9IG1pblkgKiBleHRlbnQgKiBzY2FsZTtcclxuXHRcdGNvbnN0IHNtYXhZID0gbWF4WSAqIGV4dGVudCAqIHNjYWxlO1xyXG5cdFx0Ly8gZ2V0IGNvbGxpc2lvblxyXG5cdFx0cmV0dXJuIHRyZWUuc2VhcmNoUmVjdGFuZ2xlKHNtaW5YLCBzbWF4WCwgc21pblksIHNtYXhZKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUlRyZWVQeXJhbWlkO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcmVjdGFuZ2xlIGNvbGxpZGFibGUuXHJcbiAqL1xyXG5jbGFzcyBSZWN0YW5nbGVDb2xsaWRhYmxlIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFJlY3RhbmdsZUNvbGxpZGFibGUgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblggLSBUaGUgbGVmdCBib3VuZCBpbiBwaXhlbHMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFggLSBUaGUgcmlnaHQgYm91bmQgaW4gcGl4ZWxzLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIC0gVGhlIGJvdHRvbSBib3VuZCBpbiBwaXhlbHMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFkgLSBUaGUgdG9wIGJvdW5kIGluIHBpeGVscy5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldCAtIFRoZSB0aWxlIHggb2Zmc2V0IGluIHBpeGVscy5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geU9mZnNldCAtIFRoZSB0aWxlIHkgb2Zmc2V0IGluIHBpeGVscy5cclxuXHQgKiBAcGFyYW0ge1RpbGV9IHRpbGUgLSBUaGUgdGlsZSBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBBbnkgYXJiaXRyYXJ5IHVzZXIgZGF0YS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCB4T2Zmc2V0LCB5T2Zmc2V0LCB0aWxlLCBkYXRhKSB7XHJcblx0XHR0aGlzLm1pblggPSBtaW5YICsgeE9mZnNldDtcclxuXHRcdHRoaXMubWF4WCA9IG1heFggKyB4T2Zmc2V0O1xyXG5cdFx0dGhpcy5taW5ZID0gbWluWSArIHlPZmZzZXQ7XHJcblx0XHR0aGlzLm1heFkgPSBtYXhZICsgeU9mZnNldDtcclxuXHRcdHRoaXMudGlsZSA9IHRpbGU7XHJcblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGVzdCBpZiB0aGUgcHJvdmlkZWQgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBpbm5lciBzaGFwZSBvZiB0aGUgY29sbGlkYWJsZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggcG9zaXRpb24gdG8gdGVzdC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IHBvc2l0aW9uIHRvIHRlc3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Ym9vbH0gV2hldGhlciBvciBub3QgdGhlcmUgaXMgYW4gaW50ZXJzZWN0aW9uLlxyXG5cdCAqL1xyXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcblx0dGVzdFBvaW50KHgsIHkpIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGVzdCBpZiB0aGUgcHJvdmlkZWQgcmVjdGFuZ2xlIGlzIHdpdGhpbiB0aGUgaW5uZXIgc2hhcGUgb2YgdGhlXHJcblx0ICogY29sbGlkYWJsZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIC0gVGhlIG1pbmltdW0geCBjb21wb25lbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFggLSBUaGUgbWF4aW11bSB4IGNvbXBvbmVudC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluWSAtIFRoZSBtaW5pbXVtIHkgY29tcG9uZW50LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIC0gVGhlIG1heGltdW0geSBjb21wb25lbnQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Ym9vbH0gV2hldGhlciBvciBub3QgdGhlcmUgaXMgYW4gaW50ZXJzZWN0aW9uLlxyXG5cdCAqL1xyXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcblx0dGVzdFJlY3RhbmdsZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlQ29sbGlkYWJsZTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgY2xhbXAgPSByZXF1aXJlKCdsb2Rhc2gvY2xhbXAnKTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjaXJjbGUgY29sbGlkYWJsZS5cclxuICovXHJcbmNsYXNzIFJpbmdDb2xsaWRhYmxlIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFJpbmdDb2xsaWRhYmxlIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHRpbGUgeCBwaXhlbCBjb29yZGluYXRlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHRpbGUgeSBwaXhlbCBjb29yZGluYXRlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIGluIHBpeGVscy5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgcmFkaXVzIGJ1ZmZlciBpbiBwaXhlbHMgKGFkZGl0aW9uYWwgaGl0LWFyZWEgYmV5b25kIHJhZGl1cylcclxuXHQgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldCAtIFRoZSB0aWxlIHggb2Zmc2V0IGluIHBpeGVscy5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geU9mZnNldCAtIFRoZSB0aWxlIHkgb2Zmc2V0IGluIHBpeGVscy5cclxuXHQgKiBAcGFyYW0ge1RpbGV9IHRpbGUgLSBUaGUgdGlsZSBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBBbnkgYXJiaXRyYXJ5IHVzZXIgZGF0YS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcih4LCB5LCByYWRpdXMsIHdpZHRoLCB4T2Zmc2V0LCB5T2Zmc2V0LCB0aWxlLCBkYXRhKSB7XHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0Y29uc3QgaGFsZldpZHRoID0gd2lkdGggKiAwLjU7XHJcblx0XHR0aGlzLm1pblggPSB4ICsgeE9mZnNldCAtIHJhZGl1cyAtIGhhbGZXaWR0aDtcclxuXHRcdHRoaXMubWF4WCA9IHggKyB4T2Zmc2V0ICsgcmFkaXVzICsgaGFsZldpZHRoO1xyXG5cdFx0dGhpcy5taW5ZID0geSArIHlPZmZzZXQgLSByYWRpdXMgLSBoYWxmV2lkdGg7XHJcblx0XHR0aGlzLm1heFkgPSB5ICsgeU9mZnNldCArIHJhZGl1cyArIGhhbGZXaWR0aDtcclxuXHRcdHRoaXMudGlsZSA9IHRpbGU7XHJcblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGVzdCBpZiB0aGUgcHJvdmlkZWQgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBpbm5lciBzaGFwZSBvZiB0aGUgY29sbGlkYWJsZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggcG9zaXRpb24gdG8gdGVzdC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IHBvc2l0aW9uIHRvIHRlc3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Ym9vbH0gV2hldGhlciBvciBub3QgdGhlcmUgaXMgYW4gaW50ZXJzZWN0aW9uLlxyXG5cdCAqL1xyXG5cdHRlc3RQb2ludCh4LCB5KSB7XHJcblx0XHQvLyBjZW50ZXIgcG9zXHJcblx0XHRjb25zdCBjeCA9ICh0aGlzLm1pblggKyB0aGlzLm1heFgpICogMC41O1xyXG5cdFx0Y29uc3QgY3kgPSAodGhpcy5taW5ZICsgdGhpcy5tYXhZKSAqIDAuNTtcclxuXHRcdC8vIGRpc3RhbmNlIHRvIHBvaW50XHJcblx0XHRjb25zdCBkeCA9IGN4IC0geDtcclxuXHRcdGNvbnN0IGR5ID0gY3kgLSB5O1xyXG5cdFx0Y29uc3QgZGlzdGFuY2VTcXIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IHRoaXMud2lkdGggKiAwLjU7XHJcblx0XHRjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMucmFkaXVzIC0gaGFsZldpZHRoO1xyXG5cdFx0Y29uc3Qgb3V0ZXJSYWRpdXMgPSB0aGlzLnJhZGl1cyArIGhhbGZXaWR0aDtcclxuXHRcdHJldHVybiAoZGlzdGFuY2VTcXIgPD0gKG91dGVyUmFkaXVzICogb3V0ZXJSYWRpdXMpKSAmJlxyXG5cdFx0XHQoZGlzdGFuY2VTcXIgPj0gKGlubmVyUmFkaXVzICogaW5uZXJSYWRpdXMpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3QgaWYgdGhlIHByb3ZpZGVkIHJlY3RhbmdsZSBpcyB3aXRoaW4gdGhlIGlubmVyIHNoYXBlIG9mIHRoZVxyXG5cdCAqIGNvbGxpZGFibGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluWCAtIFRoZSBtaW5pbXVtIHggY29tcG9uZW50LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIC0gVGhlIG1heGltdW0geCBjb21wb25lbnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblkgLSBUaGUgbWluaW11bSB5IGNvbXBvbmVudC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4WSAtIFRoZSBtYXhpbXVtIHkgY29tcG9uZW50LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2x9IFdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbi5cclxuXHQgKi9cclxuXHR0ZXN0UmVjdGFuZ2xlKG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcclxuXHRcdC8vIGNpcmNsZSBwb3NcclxuXHRcdGNvbnN0IGN4ID0gKHRoaXMubWluWCArIHRoaXMubWF4WCkgKiAwLjU7XHJcblx0XHRjb25zdCBjeSA9ICh0aGlzLm1pblkgKyB0aGlzLm1heFkpICogMC41O1xyXG5cdFx0Ly8gZmluZCB0aGUgZnVydGhlc3QgcG9pbnRzIG9uIHJlY3RhbmdsZSBmcm9tIHRoZSBjaXJjbGVcclxuXHRcdGxldCBmdXJ0aGVzdFgsIGZ1cnRoZXN0WSA9IDA7XHJcblx0XHRpZiAoTWF0aC5hYnMoY3ggLSBtaW5YKSA8IE1hdGguYWJzKGN4IC0gbWF4WCkpIHtcclxuXHRcdFx0ZnVydGhlc3RYID0gbWF4WDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZ1cnRoZXN0WCA9IG1pblg7XHJcblx0XHR9XHJcblx0XHRpZiAoTWF0aC5hYnMoY3kgLSBtaW5ZKSA8IE1hdGguYWJzKGN5IC0gbWF4WSkpIHtcclxuXHRcdFx0ZnVydGhlc3RZID0gbWF4WTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZ1cnRoZXN0WSA9IG1pblk7XHJcblx0XHR9XHJcblx0XHQvLyBjaGVjayBpZiB0aGVyZSBpcyBhbnkgaW50ZXJzZWN0aW9uIHdpdGggdGhlIGlubmVyIGNpcmNsZVxyXG5cdFx0Y29uc3QgZnggPSBjeCAtIGZ1cnRoZXN0WDtcclxuXHRcdGNvbnN0IGZ5ID0gY3kgLSBmdXJ0aGVzdFk7XHJcblx0XHRjb25zdCBoYWxmV2lkdGggPSB0aGlzLndpZHRoICogMC41O1xyXG5cdFx0Y29uc3QgaW5uZXJSYWRpdXMgPSB0aGlzLnJhZGl1cyAtIGhhbGZXaWR0aDtcclxuXHRcdGlmICgoZnggKiBmeCArIGZ5ICogZnkpIDwgKGlubmVyUmFkaXVzICogaW5uZXJSYWRpdXMpKSB7XHJcblx0XHRcdC8vIHJlY3RhbmdsZSBpcyBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmluZyBhbmQgY2Fubm90IGludGVyc2VjdFxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHQvLyBvdGhlcndpc2UganVzdCBkbyBhIGNpcmNsZSAtIGFhYmIgdGVzdCBmb3Igb3V0ZXIgY2lyY2xlXHJcblx0XHQvLyBmaW5kIGNsb3Nlc3QgcG9pbnQgaW4gcmVjdGFuZ2xlIHRvIGNpcmNsZVxyXG5cdFx0Y29uc3QgbmVhcmVzdFggPSBjbGFtcChjeCwgbWluWCwgbWF4WCk7XHJcblx0XHRjb25zdCBuZWFyZXN0WSA9IGNsYW1wKGN5LCBtaW5ZLCBtYXhZKTtcclxuXHRcdC8vIHRlc3QgZGlzdGFuY2VcclxuXHRcdGNvbnN0IGR4ID0gY3ggLSBuZWFyZXN0WDtcclxuXHRcdGNvbnN0IGR5ID0gY3kgLSBuZWFyZXN0WTtcclxuXHRcdGNvbnN0IG91dGVyUmFkaXVzID0gdGhpcy5yYWRpdXMgKyBoYWxmV2lkdGg7XHJcblx0XHRyZXR1cm4gKGR4ICogZHggKyBkeSAqIGR5KSA8IChvdXRlclJhZGl1cyAqIG91dGVyUmFkaXVzKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmluZ0NvbGxpZGFibGU7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGNsYW1wID0gcmVxdWlyZSgnbG9kYXNoL2NsYW1wJyk7XHJcbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcclxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XHJcbmNvbnN0IEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnQvRXZlbnQnKTtcclxuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vZXZlbnQvRXZlbnRUeXBlJyk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbGF5ZXIgY29tcG9uZW50LlxyXG4gKi9cclxuY2xhc3MgTGF5ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgTGF5ZXIgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5vcGFjaXR5IC0gVGhlIGxheWVyIG9wYWNpdHkuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuekluZGV4IC0gVGhlIGxheWVyIHotaW5kZXguXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmhpZGRlbiAtIFdoZXRoZXIgb3Igbm90IHRoZSBsYXllciBpcyB2aXNpYmxlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMub3BhY2l0eSA9IGRlZmF1bHRUbyhvcHRpb25zLm9wYWNpdHksIDEuMCk7XHJcblx0XHR0aGlzLmhpZGRlbiA9IGRlZmF1bHRUbyhvcHRpb25zLmhpZGRlbiwgZmFsc2UpO1xyXG5cdFx0dGhpcy56SW5kZXggPSBkZWZhdWx0VG8ob3B0aW9ucy56SW5kZXgsIDApO1xyXG5cdFx0dGhpcy5yZW5kZXJlciA9IGRlZmF1bHRUbyhvcHRpb25zLnJlbmRlcmVyLCBudWxsKTtcclxuXHRcdHRoaXMuaGlnaGxpZ2h0ZWQgPSBudWxsO1xyXG5cdFx0dGhpcy5zZWxlY3RlZCA9IFtdO1xyXG5cdFx0dGhpcy5wbG90ID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIGF0dGFjaGVkIHRvIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgbGF5ZXIgdG8uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRvbkFkZChwbG90KSB7XHJcblx0XHRpZiAoIXBsb3QpIHtcclxuXHRcdFx0dGhyb3cgJ05vIHBsb3QgYXJndW1lbnQgcHJvdmlkZWQnO1xyXG5cdFx0fVxyXG5cdFx0Ly8gc2V0IHBsb3RcclxuXHRcdHRoaXMucGxvdCA9IHBsb3Q7XHJcblx0XHQvLyBmbGFnIGFzIGRpcnR5XHJcblx0XHR0aGlzLnBsb3Quc2V0RGlydHkoKTtcclxuXHRcdC8vIGV4ZWN1dGUgcmVuZGVyZXIgaG9va1xyXG5cdFx0aWYgKHRoaXMucmVuZGVyZXIpIHtcclxuXHRcdFx0dGhpcy5yZW5kZXJlci5vbkFkZCh0aGlzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIHJlbW92ZSB0aGUgbGF5ZXIgZnJvbS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uUmVtb3ZlKHBsb3QpIHtcclxuXHRcdGlmICghcGxvdCkge1xyXG5cdFx0XHR0aHJvdyAnTm8gcGxvdCBhcmd1bWVudCBwcm92aWRlZCc7XHJcblx0XHR9XHJcblx0XHQvLyBleGVjdXRlIHJlbmRlcmVyIGhvb2tcclxuXHRcdGlmICh0aGlzLnJlbmRlcmVyKSB7XHJcblx0XHRcdHRoaXMucmVuZGVyZXIub25SZW1vdmUodGhpcyk7XHJcblx0XHR9XHJcblx0XHQvLyBjbGVhciBzdGF0ZVxyXG5cdFx0dGhpcy5jbGVhcigpO1xyXG5cdFx0Ly8gZmxhZyBhcyBkaXJ0eVxyXG5cdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XHJcblx0XHQvLyByZW1vdmUgcGxvdFxyXG5cdFx0dGhpcy5wbG90ID0gbnVsbDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGEgcmVuZGVyZXIgdG8gdGhlIGxheWVyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XHJcblx0XHRpZiAoIXJlbmRlcmVyKSB7XHJcblx0XHRcdHRocm93ICdObyByZW5kZXJlciBhcmd1bWVudCBwcm92aWRlZCc7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5yZW5kZXJlciAmJiB0aGlzLnBsb3QpIHtcclxuXHRcdFx0dGhpcy5yZW5kZXJlci5vblJlbW92ZSh0aGlzKTtcclxuXHRcdH1cclxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHRcdGlmICh0aGlzLnBsb3QpIHtcclxuXHRcdFx0dGhpcy5yZW5kZXJlci5vbkFkZCh0aGlzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHRoZSByZW5kZXJlciBmcm9tIHRoZSBsYXllci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHJlbW92ZVJlbmRlcmVyKCkge1xyXG5cdFx0aWYgKCF0aGlzLnJlbmRlcmVyKSB7XHJcblx0XHRcdHRocm93ICdObyByZW5kZXJlciBpcyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhlIGxheWVyJztcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLnBsb3QpIHtcclxuXHRcdFx0dGhpcy5yZW5kZXJlci5vblJlbW92ZSh0aGlzKTtcclxuXHRcdH1cclxuXHRcdHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSByZW5kZXJlciBvZiB0aGUgbGF5ZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QuXHJcblx0ICovXHJcblx0Z2V0UmVuZGVyZXIoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJlcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSAtIFRoZSBvcGFjaXR5IHRvIHNldC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHNldE9wYWNpdHkob3BhY2l0eSkge1xyXG5cdFx0b3BhY2l0eSA9IGNsYW1wKG9wYWNpdHksIDAsIDEpO1xyXG5cdFx0aWYgKHRoaXMub3BhY2l0eSAhPT0gb3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0XHRpZiAodGhpcy5wbG90KSB7XHJcblx0XHRcdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBvcGFjaXR5IG9mIHRoZSBsYXllciBvYmplY3QsLlxyXG5cdCAqL1xyXG5cdGdldE9wYWNpdHkoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcGFjaXR5O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6SW5kZXggLSBUaGUgei1pbmRleCB0byBzZXQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRzZXRaSW5kZXgoekluZGV4KSB7XHJcblx0XHRpZiAodGhpcy56SW5kZXggIT09IHpJbmRleCkge1xyXG5cdFx0XHR0aGlzLnpJbmRleCA9IHpJbmRleDtcclxuXHRcdFx0aWYgKHRoaXMucGxvdCkge1xyXG5cdFx0XHRcdHRoaXMucGxvdC5zZXREaXJ0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgekluZGV4IG9mIHRoZSBsYXllciBvYmplY3QsLlxyXG5cdCAqL1xyXG5cdGdldFpJbmRleCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnpJbmRleDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE1ha2UgdGhlIGxheWVyIHZpc2libGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRzaG93KCkge1xyXG5cdFx0aWYgKHRoaXMuaGlkZGVuKSB7XHJcblx0XHRcdHRoaXMuaGlkZGVuID0gZmFsc2U7XHJcblx0XHRcdGlmICh0aGlzLnBsb3QpIHtcclxuXHRcdFx0XHR0aGlzLnBsb3Quc2V0RGlydHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNYWtlIHRoZSBsYXllciBpbnZpc2libGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRoaWRlKCkge1xyXG5cdFx0aWYgKCF0aGlzLmhpZGRlbikge1xyXG5cdFx0XHR0aGlzLmhpZGRlbiA9IHRydWU7XHJcblx0XHRcdGlmICh0aGlzLnJlbmRlcmVyKSB7XHJcblx0XHRcdFx0dGhpcy5yZW5kZXJlci5jbGVhcigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLnBsb3QpIHtcclxuXHRcdFx0XHR0aGlzLnBsb3Quc2V0RGlydHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxheWVyIGlzIGhpZGRlbi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgaGlkZGVuLlxyXG5cdCAqL1xyXG5cdGlzSGlkZGVuKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGlkZGVuO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUGljayBhIHBvc2l0aW9uIG9mIHRoZSBsYXllciBmb3IgYSBjb2xsaXNpb24gd2l0aCBhbnkgcmVuZGVyZWQgb2JqZWN0cy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3MgLSBUaGUgcGxvdCBwb3NpdGlvbiB0byBwaWNrIGF0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGNvbGxpc2lvbiwgb3IgbnVsbC5cclxuXHQgKi9cclxuXHRwaWNrKHBvcykge1xyXG5cdFx0aWYgKHRoaXMucmVuZGVyZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyZXIucGljayhwb3MpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBIaWdobGlnaHRzIHRoZSBwcm92aWRlZCBkYXRhLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byBoaWdobGlnaHQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRoaWdobGlnaHQoZGF0YSkge1xyXG5cdFx0aWYgKHRoaXMuaGlnaGxpZ2h0ZWQgIT09IGRhdGEpIHtcclxuXHRcdFx0dGhpcy5oaWdobGlnaHRlZCA9IGRhdGE7XHJcblx0XHRcdGlmICh0aGlzLnBsb3QpIHtcclxuXHRcdFx0XHR0aGlzLnBsb3Quc2V0RGlydHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhcnMgYW55IGN1cnJlbnQgaGlnaGxpZ2h0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0xheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0dW5oaWdobGlnaHQoKSB7XHJcblx0XHRpZiAodGhpcy5oaWdobGlnaHRlZCAhPT0gbnVsbCkge1xyXG5cdFx0XHR0aGlzLmhpZ2hsaWdodGVkID0gbnVsbDtcclxuXHRcdFx0aWYgKHRoaXMucGxvdCkge1xyXG5cdFx0XHRcdHRoaXMucGxvdC5zZXREaXJ0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYW55IGhpZ2hsaWdodGVkIGRhdGEuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaGlnaGxpZ2h0ZWQgZGF0YS5cclxuXHQgKi9cclxuXHRnZXRIaWdobGlnaHRlZCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmhpZ2hsaWdodGVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBhcmd1bWVudCBpcyBoaWdobGlnaHRlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgdG8gdGVzdC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBoaWdobGlnaHRlZCBkYXRhLlxyXG5cdCAqL1xyXG5cdGlzSGlnaGxpZ2h0ZWQoZGF0YSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGlnaGxpZ2h0ZWQgPT09IGRhdGE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZWxlY3RzIHRoZSBwcm92aWRlZCBkYXRhLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byBzZWxlY3QuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG11bHRpU2VsZWN0IC0gV2hldGhlciBtdXRsaS1zZWxlY3QgaXMgZW5hYmxlZC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHNlbGVjdChkYXRhLCBtdWx0aVNlbGVjdCkge1xyXG5cdFx0bGV0IGNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdGlmIChtdWx0aVNlbGVjdCkge1xyXG5cdFx0XHQvLyBhZGQgdG8gY29sbGVjdGlvbiBpZiBtdWx0aS1zZWxlY3Rpb24gaXMgZW5hYmxlZFxyXG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuc2VsZWN0ZWQuaW5kZXhPZihkYXRhKTtcclxuXHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdC8vIHNlbGVjdCBwb2ludFxyXG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWQucHVzaChkYXRhKTtcclxuXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gY2xlYXIgc2VsZWN0aW9uLCBhZGRpbmcgb25seSB0aGUgbGF0ZXN0IGVudHJ5XHJcblx0XHRcdGlmICh0aGlzLnNlbGVjdGVkLmxlbmd0aCAhPT0gMSB8fCB0aGlzLnNlbGVjdGVkWzBdICE9PSBkYXRhKSB7XHJcblx0XHRcdFx0dGhpcy5zZWxlY3RlZCA9IFsgZGF0YSBdO1xyXG5cdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5wbG90ICYmIGNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSB0aGUgcHJvdmlkZWQgZGF0YSBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgdG8gdW5zZWxlY3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHR1bnNlbGVjdChkYXRhKSB7XHJcblx0XHRjb25zdCBpbmRleCA9IHRoaXMuc2VsZWN0ZWQuaW5kZXhPZihkYXRhKTtcclxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcclxuXHRcdFx0Ly8gdW5zZWxlY3QgcG9pbnRcclxuXHRcdFx0dGhpcy5zZWxlY3RlZC5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0XHRpZiAodGhpcy5wbG90KSB7XHJcblx0XHRcdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYXJzIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHVuc2VsZWN0QWxsKCkge1xyXG5cdFx0aWYgKHRoaXMuc2VsZWN0ZWQubGVuZ3RoID4gMCkge1xyXG5cdFx0XHQvLyB1bnNlbGVjdCBhbGxcclxuXHRcdFx0dGhpcy5zZWxlY3RlZCA9IFtdO1xyXG5cdFx0XHRpZiAodGhpcy5wbG90KSB7XHJcblx0XHRcdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbnkgc2VsZWN0ZWQgZGF0YS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHNlbGVjdGVkIGRhdGEuXHJcblx0ICovXHJcblx0Z2V0U2VsZWN0ZWQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnQgaXMgc2VsZWN0ZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHRvIHRlc3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGRhdGEgaXMgc2VsZWN0ZWQuXHJcblx0ICovXHJcblx0aXNTZWxlY3RlZChkYXRhKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RlZC5pbmRleE9mKGRhdGEpICE9PSAtMTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXcgdGhlIGxheWVyIGZvciB0aGUgZnJhbWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gVGhlIGZyYW1lIHRpbWVzdGFtcC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGRyYXcodGltZXN0YW1wKSB7XHJcblx0XHRpZiAodGhpcy5yZW5kZXJlcikge1xyXG5cdFx0XHR0aGlzLnJlbmRlcmVyLmRyYXcodGltZXN0YW1wKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYXJzIGFueSBwZXJzaXN0ZWQgc3RhdGUgaW4gdGhlIGxheWVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0xheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0Y2xlYXIoKSB7XHJcblx0XHQvLyBjbGVhciBzZWxlY3RlZCAvIGhpZ2hsaWdodGVkXHJcblx0XHRpZiAodGhpcy5oaWdobGlnaHRlZCB8fCB0aGlzLnNlbGVjdGVkLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0dGhpcy5oaWdobGlnaHRlZCA9IG51bGw7XHJcblx0XHRcdHRoaXMuc2VsZWN0ZWQgPSBbXTtcclxuXHRcdH1cclxuXHRcdC8vIGNsZWFyIHJlbmRlcmVyIHN0YXRlXHJcblx0XHRpZiAodGhpcy5yZW5kZXJlcikge1xyXG5cdFx0XHR0aGlzLnJlbmRlcmVyLmNsZWFyKCk7XHJcblx0XHR9XHJcblx0XHQvLyBmbGFnIGFzIGRpcnR5XHJcblx0XHRpZiAodGhpcy5wbG90KSB7XHJcblx0XHRcdHRoaXMucGxvdC5zZXREaXJ0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhcnMgYW55IHBlcnNpc3RlZCBzdGF0ZSBpbiB0aGUgbGF5ZXIgYW5kIHJlZnJlc2hlcyB0aGUgdW5kZXJseWluZ1xyXG5cdCAqIGRhdGEuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRyZWZyZXNoKCkge1xyXG5cdFx0Ly8gY2xlYXIgdGhlIGxheWVyIHN0YXRlXHJcblx0XHR0aGlzLmNsZWFyKCk7XHJcblx0XHQvLyBlbWl0IHJlZnJlc2ggZXZlbnRcclxuXHRcdHRoaXMuZW1pdChFdmVudFR5cGUuUkVGUkVTSCwgbmV3IEV2ZW50KHRoaXMpKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMYXllcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnRUeXBlJyk7XHJcbmNvbnN0IExheWVyID0gcmVxdWlyZSgnLi4vTGF5ZXInKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuLyoqXHJcbiAqIENlbGwgdXBkYXRlIGV2ZW50IGhhbmRsZXIgc3ltYm9sLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge1N5bWJvbH1cclxuICovXHJcbmNvbnN0IENFTExfVVBEQVRFID0gU3ltYm9sKCk7XHJcblxyXG4vKipcclxuICogQ2xpcHBlZCBnZW9tZXRyeSBzeW1ib2wuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxyXG4gKi9cclxuY29uc3QgQ0xJUFBFRCA9IFN5bWJvbCgpO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBvdmVybGF5IGxheWVyLlxyXG4gKi9cclxuY2xhc3MgT3ZlcmxheSBleHRlbmRzIExheWVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IE92ZXJsYXkgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3ZlcmxheSBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm9wYWNpdHkgLSBUaGUgb3ZlcmxheSBvcGFjaXR5LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpJbmRleCAtIFRoZSBvdmVybGF5IHotaW5kZXguXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmhpZGRlbiAtIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IGlzIHZpc2libGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzdXBlcihvcHRpb25zKTtcclxuXHRcdHRoaXNbQ0xJUFBFRF0gPSBudWxsO1xyXG5cdFx0dGhpc1tDRUxMX1VQREFURV0gPSBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byBhdHRhY2ggdGhlIG92ZXJsYXkgdG8uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T3ZlcmxheX0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25BZGQocGxvdCkge1xyXG5cdFx0c3VwZXIub25BZGQocGxvdCk7XHJcblx0XHQvLyBjbGlwIGV4aXN0aW5nIGdlb21ldHJ5XHJcblx0XHR0aGlzLnJlZnJlc2goKTtcclxuXHRcdC8vIGNyZWF0ZSBjZWxsIHVwZGF0ZSBoYW5kbGVyXHJcblx0XHR0aGlzW0NFTExfVVBEQVRFXSA9ICgpID0+IHtcclxuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XHJcblx0XHR9O1xyXG5cdFx0Ly8gYXR0YWNoIGhhbmRsZXJcclxuXHRcdHRoaXMucGxvdC5vbihFdmVudFR5cGUuQ0VMTF9VUERBVEUsIHRoaXNbQ0VMTF9VUERBVEVdKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyByZW1vdmVkIGZyb20gYSBwbG90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQbG90fSBwbG90IC0gVGhlIHBsb3QgdG8gcmVtb3ZlIHRoZSBvdmVybGF5IGZyb20uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T3ZlcmxheX0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25SZW1vdmUocGxvdCkge1xyXG5cdFx0Ly8gcmVtb3ZlIGNsaXBwZWQgZ2VvbWV0cnlcclxuXHRcdHRoaXNbQ0xJUFBFRF0gPSBudWxsO1xyXG5cdFx0Ly8gcmVtb3ZlIGhhbmRsZXJcclxuXHRcdHRoaXMucGxvdC5yZW1vdmVMaXN0ZW5lcihFdmVudFR5cGUuQ0VMTF9VUERBVEUsIHRoaXNbQ0VMTF9VUERBVEVdKTtcclxuXHRcdC8vIGNyZWF0ZSByZWZyZXNoIGhhbmRsZXJcclxuXHRcdHRoaXNbQ0VMTF9VUERBVEVdID0gbnVsbDtcclxuXHRcdHN1cGVyLm9uUmVtb3ZlKHBsb3QpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVbm11dGVzIGFuZCBzaG93cyB0aGUgb3ZlcmxheS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRlbmFibGUoKSB7XHJcblx0XHR0aGlzLnNob3coKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTXV0ZXMgYW5kIGhpZGVzIHRoZSBvdmVybGF5LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge092ZXJsYXl9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGRpc2FibGUoKSB7XHJcblx0XHR0aGlzLmhpZGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBvdmVybGF5IGlzIGRpc2FibGVkLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IGlzIGRpc2FibGVkLlxyXG5cdCAqL1xyXG5cdGlzRGlzYWJsZWQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc0hpZGRlbigpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYXJzIGFueSBwZXJzaXN0ZWQgc3RhdGUgaW4gdGhlIG92ZXJsYXkgYW5kIHJlZnJlc2hlcyB0aGUgdW5kZXJseWluZ1xyXG5cdCAqIGRhdGEuIFRoaXMgaW52b2x2ZXMgcmVmcmVzaGluZyB0aGUgc3RvcmVkIGNsaXBwZWQgZ2VvbWV0cnkgb2YgdGhlXHJcblx0ICogb3ZlcmxheSBiYXNlZCB0aGUgY3VycmVudCByZW5kZXJpbmcgY2VsbCBvZiB0aGUgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRyZWZyZXNoKCkge1xyXG5cdFx0aWYgKHRoaXMucGxvdCkge1xyXG5cdFx0XHR0aGlzW0NMSVBQRURdID0gdGhpcy5jbGlwR2VvbWV0cnkodGhpcy5wbG90LmNlbGwpO1xyXG5cdFx0fVxyXG5cdFx0c3VwZXIucmVmcmVzaCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHaXZlbiBhbiBhcnJheSBvZiBwb2ludCBiYXNlZCBnZW9tZXRyeSwgcmV0dXJuIHRoZSBjbGlwcGVkIGdlb21ldHJ5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtDZWxsfSBjZWxsIC0gVGhlIHJlbmRlcmluZyBjZWxsLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgY2xpcHBlZCBnZW9tZXRyeS5cclxuXHQgKi9cclxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG5cdGNsaXBHZW9tZXRyeShjZWxsKSB7XHJcblx0XHR0aHJvdyAnYGNsaXBHZW9tZXRyeWAgbXVzdCBiZSBvdmVycmlkZGVuJztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiB0aGUgY2xpcHBlZCBnZW9tZXRyeSBiYXNlZCBvbiB0aGUgY3VycmVudCBjZWxsLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgY2xpcHBlZCBnZW9tZXRyeS5cclxuXHQgKi9cclxuXHRnZXRDbGlwcGVkR2VvbWV0cnkoKSB7XHJcblx0XHRyZXR1cm4gdGhpc1tDTElQUEVEXTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxheTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgT3ZlcmxheSA9IHJlcXVpcmUoJy4vT3ZlcmxheScpO1xyXG5cclxuLy8gUHJpdmF0ZSBNZXRob2RzXHJcblxyXG5jb25zdCBjbGlwUG9pbnRzID0gZnVuY3Rpb24oY2VsbCwgcG9pbnRzKSB7XHJcblx0Y29uc3QgY2xpcHBlZCA9IFtdO1xyXG5cdHBvaW50cy5mb3JFYWNoKHB0cyA9PiB7XHJcblx0XHRjb25zdCBjbGlwcGVkUG9pbnRzID0gY2VsbC5ib3VuZHMuY2xpcFBvaW50cyhwdHMpO1xyXG5cdFx0aWYgKCFjbGlwcGVkUG9pbnRzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGZvciAobGV0IGk9MDsgaTxjbGlwcGVkUG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNsaXBwZWQucHVzaChjZWxsLnByb2plY3QoY2xpcHBlZFBvaW50c1tpXSkpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHJldHVybiBjbGlwcGVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHBvaW50IG92ZXJsYXkuXHJcbiAqL1xyXG5jbGFzcyBQb2ludE92ZXJsYXkgZXh0ZW5kcyBPdmVybGF5IHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFBvaW50T3ZlcmxheSBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBsYXllciBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm9wYWNpdHkgLSBUaGUgbGF5ZXIgb3BhY2l0eS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy56SW5kZXggLSBUaGUgbGF5ZXIgei1pbmRleC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuXHRcdHN1cGVyKG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5wb2ludHMgPSBuZXcgTWFwKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYSBzZXQgb2YgcG9pbnRzIHRvIHJlbmRlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCB0byBzdG9yZSB0aGUgcG9pbnRzIHVuZGVyLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyAtIFRoZSBwb2ludHMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UG9pbnRPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRhZGRQb2ludHMoaWQsIHBvaW50cykge1xyXG5cdFx0dGhpcy5wb2ludHMuc2V0KGlkLCBwb2ludHMpO1xyXG5cdFx0aWYgKHRoaXMucGxvdCkge1xyXG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGEgc2V0IG9mIHBvaW50cyBieSBpZCBmcm9tIHRoZSBvdmVybGF5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGlkIHRvIHN0b3JlIHRoZSBwb2ludHMgdW5kZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UG9pbnRPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRyZW1vdmVQb2ludHMoaWQpIHtcclxuXHRcdHRoaXMucG9pbnRzLmRlbGV0ZShpZCk7XHJcblx0XHRpZiAodGhpcy5wbG90KSB7XHJcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgYWxsIHBvaW50cyBmcm9tIHRoZSBsYXllci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2ludE92ZXJsYXl9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGNsZWFyUG9pbnRzKCkge1xyXG5cdFx0dGhpcy5jbGVhcigpO1xyXG5cdFx0dGhpcy5wb2ludHMgPSBuZXcgTWFwKCk7XHJcblx0XHRpZiAodGhpcy5wbG90KSB7XHJcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGhlIGNsaXBwZWQgZ2VvbWV0cnkgYmFzZWQgb24gdGhlIGN1cnJlbnQgY2VsbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Q2VsbH0gY2VsbCAtIFRoZSByZW5kZXJpbmcgY2VsbC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIGNsaXBwZWQgZ2VvbWV0cnkuXHJcblx0ICovXHJcblx0Y2xpcEdlb21ldHJ5KGNlbGwpIHtcclxuXHRcdHJldHVybiBjbGlwUG9pbnRzKGNlbGwsIHRoaXMucG9pbnRzKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRPdmVybGF5O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBPdmVybGF5ID0gcmVxdWlyZSgnLi9PdmVybGF5Jyk7XHJcblxyXG4vLyBQcml2YXRlIE1ldGhvZHNcclxuXHJcbmNvbnN0IGNsaXBQb2x5Z29ucyA9IGZ1bmN0aW9uKGNlbGwsIHBvbHlnb25zKSB7XHJcblx0Y29uc3QgY2xpcHBlZCA9IFtdO1xyXG5cdHBvbHlnb25zLmZvckVhY2gocG9seWdvbiA9PiB7XHJcblx0XHRjb25zdCBjbGlwcGVkUG9seWdvbiA9IGNlbGwuYm91bmRzLmNsaXBQb2x5Z29uKHBvbHlnb24pO1xyXG5cdFx0aWYgKCFjbGlwcGVkUG9seWdvbikge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoY2xpcHBlZFBvbHlnb24ubGVuZ3RoKTtcclxuXHRcdGZvciAobGV0IGk9MDsgaTxjbGlwcGVkUG9seWdvbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRyZXN1bHRbaV0gPSBjZWxsLnByb2plY3QoY2xpcHBlZFBvbHlnb25baV0pO1xyXG5cdFx0fVxyXG5cdFx0Y2xpcHBlZC5wdXNoKHJlc3VsdCk7XHJcblx0fSk7XHJcblx0cmV0dXJuIGNsaXBwZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcG9seWdvbiBvdmVybGF5LlxyXG4gKi9cclxuY2xhc3MgUG9seWdvbk92ZXJsYXkgZXh0ZW5kcyBPdmVybGF5IHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFBvbHlnb25PdmVybGF5IG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGxheWVyIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtSZW5kZXJlcn0gb3B0aW9ucy5yZW5kZXJlciAtIFRoZSBsYXllciByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5vcGFjaXR5IC0gVGhlIGxheWVyIG9wYWNpdHkuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuekluZGV4IC0gVGhlIGxheWVyIHotaW5kZXguXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzdXBlcihvcHRpb25zKTtcclxuXHRcdHRoaXMucG9seWdvbnMgPSBuZXcgTWFwKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYSBzZXQgb2YgcG9pbnRzIHRvIHJlbmRlciBhcyBhIHNpbmdsZSBwb2x5Z29uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGlkIHRvIHN0b3JlIHRoZSBwb2x5Z29uIHVuZGVyLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyAtIFRoZSBwb2x5Z29uIHBvaW50cy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2x5Z29uT3ZlcmxheX0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0YWRkUG9seWdvbihpZCwgcG9pbnRzKSB7XHJcblx0XHR0aGlzLnBvbHlnb25zLnNldChpZCwgcG9pbnRzKTtcclxuXHRcdGlmICh0aGlzLnBsb3QpIHtcclxuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSBhIHBvbHlnb24gYnkgaWQgZnJvbSB0aGUgb3ZlcmxheS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCB0byBzdG9yZSB0aGUgcG9seWdvbiB1bmRlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2x5Z29uT3ZlcmxheX0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0cmVtb3ZlUG9seWdvbihpZCkge1xyXG5cdFx0dGhpcy5wb2x5Z29ucy5kZWxldGUoaWQpO1xyXG5cdFx0aWYgKHRoaXMucGxvdCkge1xyXG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGFsbCBwb2x5Z29ucyBmcm9tIHRoZSBsYXllci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2x5Z29uT3ZlcmxheX0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0Y2xlYXJQb2x5bGluZXMoKSB7XHJcblx0XHR0aGlzLmNsZWFyKCk7XHJcblx0XHR0aGlzLnBvbHlnb25zID0gbmV3IE1hcCgpO1xyXG5cdFx0aWYgKHRoaXMucGxvdCkge1xyXG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIHRoZSBjbGlwcGVkIGdlb21ldHJ5IGJhc2VkIG9uIHRoZSBjdXJyZW50IGNlbGwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0NlbGx9IGNlbGwgLSBUaGUgcmVuZGVyaW5nIGNlbGwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBjbGlwcGVkIGdlb21ldHJ5LlxyXG5cdCAqL1xyXG5cdGNsaXBHZW9tZXRyeShjZWxsKSB7XHJcblx0XHRyZXR1cm4gY2xpcFBvbHlnb25zKGNlbGwsIHRoaXMucG9seWdvbnMpO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uT3ZlcmxheTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgT3ZlcmxheSA9IHJlcXVpcmUoJy4vT3ZlcmxheScpO1xyXG5cclxuLy8gUHJpdmF0ZSBNZXRob2RzXHJcblxyXG5jb25zdCBjbGlwUG9seWxpbmVzID0gZnVuY3Rpb24oY2VsbCwgcG9seWxpbmVzKSB7XHJcblx0Y29uc3QgY2xpcHBlZCA9IFtdO1xyXG5cdHBvbHlsaW5lcy5mb3JFYWNoKHBvbHlsaW5lID0+IHtcclxuXHRcdC8vIGNsaXAgdGhlIHBvbHlsaW5lLCByZXN1bHRpbmcgaW4gbXVsdGlwbGUgY2xpcHBlZCBwb2x5bGluZXNcclxuXHRcdGNvbnN0IGNsaXBwZWRQb2x5bGluZXMgPSBjZWxsLmJvdW5kcy5jbGlwUG9seWxpbmUocG9seWxpbmUpO1xyXG5cdFx0aWYgKCFjbGlwcGVkUG9seWxpbmVzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGZvciAobGV0IGk9MDsgaTxjbGlwcGVkUG9seWxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IGNsaXBwZWRQb2x5bGluZSA9IGNsaXBwZWRQb2x5bGluZXNbaV07XHJcblx0XHRcdGZvciAobGV0IGo9MDsgajxjbGlwcGVkUG9seWxpbmUubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHQvLyBwcm9qZWN0IGluIHBsYWNlXHJcblx0XHRcdFx0Y2xpcHBlZFBvbHlsaW5lW2pdID0gY2VsbC5wcm9qZWN0KGNsaXBwZWRQb2x5bGluZVtqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2xpcHBlZC5wdXNoKGNsaXBwZWRQb2x5bGluZSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0cmV0dXJuIGNsaXBwZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcG9seWxpbmUgb3ZlcmxheS5cclxuICovXHJcbmNsYXNzIFBvbHlsaW5lT3ZlcmxheSBleHRlbmRzIE92ZXJsYXkge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUG9seWxpbmVPdmVybGF5IG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGxheWVyIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtSZW5kZXJlcn0gb3B0aW9ucy5yZW5kZXJlciAtIFRoZSBsYXllciByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5vcGFjaXR5IC0gVGhlIGxheWVyIG9wYWNpdHkuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuekluZGV4IC0gVGhlIGxheWVyIHotaW5kZXguXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzdXBlcihvcHRpb25zKTtcclxuXHRcdHRoaXMucG9seWxpbmVzID0gbmV3IE1hcCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGEgc2V0IG9mIHBvaW50cyB0byByZW5kZXIgYXMgYSBzaW5nbGUgcG9seWxpbmUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdG8gc3RvcmUgdGhlIHBvbHlsaW5lIHVuZGVyLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyAtIFRoZSBwb2x5bGluZSBwb2ludHMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UG9seWxpbmVPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRhZGRQb2x5bGluZShpZCwgcG9pbnRzKSB7XHJcblx0XHR0aGlzLnBvbHlsaW5lcy5zZXQoaWQsIHBvaW50cyk7XHJcblx0XHRpZiAodGhpcy5wbG90KSB7XHJcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgYSBwb2x5bGluZSBieSBpZCBmcm9tIHRoZSBvdmVybGF5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGlkIHRvIHN0b3JlIHRoZSBwb2x5bGluZSB1bmRlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2x5bGluZU92ZXJsYXl9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHJlbW92ZVBvbHlsaW5lKGlkKSB7XHJcblx0XHR0aGlzLnBvbHlsaW5lcy5kZWxldGUoaWQpO1xyXG5cdFx0aWYgKHRoaXMucGxvdCkge1xyXG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGFsbCBwb2x5bGluZXMgZnJvbSB0aGUgbGF5ZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UG9seWxpbmVPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRjbGVhclBvbHlsaW5lcygpIHtcclxuXHRcdHRoaXMuY2xlYXIoKTtcclxuXHRcdHRoaXMucG9seWxpbmVzID0gbmV3IE1hcCgpO1xyXG5cdFx0aWYgKHRoaXMucGxvdCkge1xyXG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIHRoZSBjbGlwcGVkIGdlb21ldHJ5IGJhc2VkIG9uIHRoZSBjdXJyZW50IGNlbGwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0NlbGx9IGNlbGwgLSBUaGUgcmVuZGVyaW5nIGNlbGwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBjbGlwcGVkIGdlb21ldHJ5LlxyXG5cdCAqL1xyXG5cdGNsaXBHZW9tZXRyeShjZWxsKSB7XHJcblx0XHRyZXR1cm4gY2xpcFBvbHlsaW5lcyhjZWxsLCB0aGlzLnBvbHlsaW5lcyk7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlsaW5lT3ZlcmxheTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gQ29uc3RhbnRzXHJcblxyXG4vKipcclxuICogTWF4aW11bSBzYWZlIGludGVnZXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgTUFYX1NBRkVfSU5UID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcclxuXHJcbi8vIFByaXZhdGUgTWV0aG9kc1xyXG5cclxubGV0IHVpZCA9IDE7XHJcbmNvbnN0IGdldFVJRCA9IGZ1bmN0aW9uKCkge1xyXG5cdHVpZCA9ICh1aWQgKyAxKSAlIE1BWF9TQUZFX0lOVDtcclxuXHRyZXR1cm4gdWlkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHRpbGUuXHJcbiAqL1xyXG5jbGFzcyBUaWxlIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFRpbGUgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIGNvb3JkIG9mIHRoZSB0aWxlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGNvb3JkKSB7XHJcblx0XHR0aGlzLmNvb3JkID0gY29vcmQ7XHJcblx0XHR0aGlzLnVpZCA9IGdldFVJRCgpO1xyXG5cdFx0dGhpcy5kYXRhID0gbnVsbDtcclxuXHRcdHRoaXMuZXJyID0gbnVsbDtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gUHJpdmF0ZSBNZXRob2RzXHJcblxyXG5jb25zdCBtb2QgPSBmdW5jdGlvbihuLCBtKSB7XHJcblx0cmV0dXJuICgobiAlIG0pICsgbSkgJSBtO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHRpbGUgY29vcmRpbmF0ZS5cclxuICovXHJcbmNsYXNzIFRpbGVDb29yZCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBUaWxlQ29vcmQgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHogLSBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHRpbGUgY29vcmRpbmF0ZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdGlsZSBjb29yZGluYXRlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0aWxlIGNvb3JkaW5hdGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoeiwgeCwgeSkge1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy5oYXNoID0gYCR7dGhpcy56fToke3RoaXMueH06JHt0aGlzLnl9YDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIFhZWiBVUkwgc3RyaW5nLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIFhZWiBVUkwgc3RyaW5nLlxyXG5cdCAqL1xyXG5cdHh5eigpIHtcclxuXHRcdGNvbnN0IGRpbSA9IE1hdGgucG93KDIsIHRoaXMueik7XHJcblx0XHRyZXR1cm4gYCR7dGhpcy56fS8ke3RoaXMueH0vJHtkaW0gLSAxIC0gdGhpcy55fWA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBUTVMgVVJMIHN0cmluZy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBUTVMgVVJMIHN0cmluZy5cclxuXHQgKi9cclxuXHR0bXMoKSB7XHJcblx0XHRyZXR1cm4gYCR7dGhpcy56fS8ke3RoaXMueH0vJHt0aGlzLnl9YDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3QgaWYgdGhlIGJvdW5kcyBlcXVhbHMgYW5vdGhlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBjb29yZCAtIFRoZSBjb29yZCBvYmplY3QgdG8gdGVzdC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgY29vcmQgb2JqZWN0cyBhcmUgZXF1YWwuXHJcblx0ICovXHJcblx0ZXF1YWxzKGNvb3JkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy56ID09PSBjb29yZC56ICYmXHJcblx0XHRcdHRoaXMueCA9PT0gY29vcmQueCAmJlxyXG5cdFx0XHR0aGlzLnkgPT09IGNvb3JkLnk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGFuY2VzdG9yIGNvb3JkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgb2YgdGhlIGFuY2VzdG9yIGZyb20gdGhlIGNvb3JkLiBPcHRpb25hbC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUaWxlQ29vcmR9IFRoZSBhbmNlc3RvciBjb29yZC5cclxuXHQgKi9cclxuXHRnZXRBbmNlc3RvcihvZmZzZXQgPSAxKSB7XHJcblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIG9mZnNldCk7XHJcblx0XHRyZXR1cm4gbmV3IFRpbGVDb29yZChcclxuXHRcdFx0dGhpcy56IC0gb2Zmc2V0LFxyXG5cdFx0XHRNYXRoLmZsb29yKHRoaXMueCAvIHNjYWxlKSxcclxuXHRcdFx0TWF0aC5mbG9vcih0aGlzLnkgLyBzY2FsZSkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBkZXNjZW5kYW50cyBvZiB0aGUgY29vcmQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBvZiB0aGUgZGVzY2VuZGFudHMgZnJvbSB0aGUgY29vcmQuIE9wdGlvbmFsLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgZGVzY2VuZGFudCBjb29yZHMuXHJcblx0ICovXHJcblx0Z2V0RGVzY2VuZGFudHMob2Zmc2V0ID0gMSkge1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBvZmZzZXQpO1xyXG5cdFx0Y29uc3QgY29vcmRzID0gbmV3IEFycmF5KHNjYWxlKnNjYWxlKTtcclxuXHRcdGZvciAobGV0IHg9MDsgeDxzY2FsZTsgeCsrKSB7XHJcblx0XHRcdGNvbnN0IHN0cmlkZSA9IHggKiBzY2FsZTtcclxuXHRcdFx0Zm9yIChsZXQgeT0wOyB5PHNjYWxlOyB5KyspIHtcclxuXHRcdFx0XHRjb29yZHNbc3RyaWRlICsgeV0gPSBuZXcgVGlsZUNvb3JkKFxyXG5cdFx0XHRcdFx0dGhpcy56ICsgb2Zmc2V0LFxyXG5cdFx0XHRcdFx0dGhpcy54ICogc2NhbGUgKyB4LFxyXG5cdFx0XHRcdFx0dGhpcy55ICogc2NhbGUgKyB5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNvb3JkcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3QgaWYgdGhlIGNvb3JkIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBwcm92aWRlZCBjb29yZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBjb29yZCAtIFRoZSBjb29yZCBvYmplY3QgdG8gdGVzdC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgY29vcmQgaXMgYW4gYW5jZXN0b3IuXHJcblx0ICovXHJcblx0aXNBbmNlc3Rvck9mKGNvb3JkKSB7XHJcblx0XHRpZiAodGhpcy56ID49IGNvb3JkLnopIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgZGlmZiA9IGNvb3JkLnogLSB0aGlzLno7XHJcblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIGRpZmYpO1xyXG5cdFx0Y29uc3QgeCA9IE1hdGguZmxvb3IoY29vcmQueCAvIHNjYWxlKTtcclxuXHRcdGlmICh0aGlzLnggIT09IHgpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgeSA9IE1hdGguZmxvb3IoY29vcmQueSAvIHNjYWxlKTtcclxuXHRcdHJldHVybiB0aGlzLnkgPT09IHk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUZXN0IGlmIHRoZSBjb29yZCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIHByb3ZpZGVkIGNvb3JkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIGNvb3JkIG9iamVjdCB0byB0ZXN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlZCBjb29yZCBpcyBhIGRlc2NlbmRhbnQuXHJcblx0ICovXHJcblx0aXNEZXNjZW5kYW50T2YoY29vcmQpIHtcclxuXHRcdHJldHVybiBjb29yZC5pc0FuY2VzdG9yT2YodGhpcyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIGNvb3JkLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RpbGVDb29yZH0gVGhlIG5vcm1hbGl6ZWQgY29vcmQuXHJcblx0ICovXHJcblx0bm9ybWFsaXplKCkge1xyXG5cdFx0Y29uc3QgZGltID0gTWF0aC5wb3coMiwgdGhpcy56KTtcclxuXHRcdHJldHVybiBuZXcgVGlsZUNvb3JkKFxyXG5cdFx0XHR0aGlzLnosXHJcblx0XHRcdG1vZCh0aGlzLngsIGRpbSksXHJcblx0XHRcdG1vZCh0aGlzLnksIGRpbSkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgcGxvdCBjb29yZGluYXRlIGZvciB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRoZSBjb29yZC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwbG90IHBvc2l0aW9uIG9mIHRoZSBjb29yZC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbigpIHtcclxuXHRcdGNvbnN0IGRpbSA9IE1hdGgucG93KDIsIHRoaXMueik7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB0aGlzLnggLyBkaW0sXHJcblx0XHRcdHk6IHRoaXMueSAvIGRpbVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHBsb3QgY29vcmRpbmF0ZSBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY29vcmQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGxvdCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyLlxyXG5cdCAqL1xyXG5cdGdldENlbnRlcigpIHtcclxuXHRcdGNvbnN0IGRpbSA9IE1hdGgucG93KDIsIHRoaXMueik7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiAodGhpcy54ICsgMC41KSAvIGRpbSxcclxuXHRcdFx0eTogKHRoaXMueSArIDAuNSkgLyBkaW1cclxuXHRcdH07XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVDb29yZDtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xyXG5jb25zdCBMYXllciA9IHJlcXVpcmUoJy4uL0xheWVyJyk7XHJcbmNvbnN0IFRpbGVQeXJhbWlkID0gcmVxdWlyZSgnLi9UaWxlUHlyYW1pZCcpO1xyXG5cclxuLy8gUHJpdmF0ZSBNZXRob2RzXHJcblxyXG5jb25zdCByZXF1ZXN0VmlzaWJsZVRpbGVzID0gZnVuY3Rpb24obGF5ZXIpIHtcclxuXHQvLyBnZXQgdmlzaWJsZSBjb29yZHNcclxuXHRjb25zdCBjb29yZHMgPSBsYXllci5wbG90LmdldFRhcmdldFZpc2libGVDb29yZHMoKTtcclxuXHQvLyByZXF1ZXN0IHRpbGVzXHJcblx0bGF5ZXIucmVxdWVzdFRpbGVzKGNvb3Jkcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgdGlsZS1iYXNlZCBsYXllci5cclxuICovXHJcbmNsYXNzIFRpbGVMYXllciBleHRlbmRzIExheWVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFRpbGVMYXllciBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBsYXllciBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm9wYWNpdHkgLSBUaGUgbGF5ZXIgb3BhY2l0eS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy56SW5kZXggLSBUaGUgbGF5ZXIgei1pbmRleC5cclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaGlkZGVuIC0gV2hldGhlciBvciBub3QgdGhlIGxheWVyIGlzIHZpc2libGUuXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLm11dGVkIC0gV2hldGhlciBvciBub3QgdGhlIGxheWVyIGlzIG11dGVkLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNhY2hlU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0ZW1wb3JhcnkgdGlsZSBjYWNoZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5udW1QZXJzaXN0ZW50TGV2ZWxzIC0gVGhlIG51bWJlciBvZiBwZXJzaXN0ZW50IGxldmVscyBpbiB0aGUgdGlsZSBweXJhbWlkLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0c3VwZXIob3B0aW9ucyk7XHJcblx0XHR0aGlzLm11dGVkID0gZGVmYXVsdFRvKG9wdGlvbnMubXV0ZWQsIGZhbHNlKTtcclxuXHRcdHRoaXMucHlyYW1pZCA9IG5ldyBUaWxlUHlyYW1pZCh0aGlzLCBvcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIGF0dGFjaGVkIHRvIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgbGF5ZXIgdG8uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGlsZUxheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25BZGQocGxvdCkge1xyXG5cdFx0c3VwZXIub25BZGQocGxvdCk7XHJcblx0XHQvLyByZXF1ZXN0IHRpbGVzIGlmIG5vdCBtdXRlZFxyXG5cdFx0aWYgKCF0aGlzLmlzTXV0ZWQoKSkge1xyXG5cdFx0XHRyZXF1ZXN0VmlzaWJsZVRpbGVzKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBwbG90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQbG90fSBwbG90IC0gVGhlIHBsb3QgdG8gcmVtb3ZlIHRoZSBsYXllciBmcm9tLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RpbGVMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uUmVtb3ZlKHBsb3QpIHtcclxuXHRcdC8vIGNsZWFyIHRoZSB1bmRlcmx5aW5nIHB5cmFtaWRcclxuXHRcdHRoaXMucHlyYW1pZC5jbGVhcigpO1xyXG5cdFx0c3VwZXIub25SZW1vdmUocGxvdCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHRpbGUgcHlyYW1pZCBvZiB0aGUgbGF5ZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGlsZVB5cmFtaWR9IFRoZSB0aWxlIHB5cmFtaWQgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGdldFB5cmFtaWQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5weXJhbWlkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWFrZSB0aGUgbGF5ZXIgaW52aXNpYmxlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RpbGVMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGhpZGUoKSB7XHJcblx0XHRzdXBlci5oaWRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE11dGVzIHRoZSBsYXllciwgaXQgd2lsbCBubyBsb25nZXIgc2VuZCBhbnkgdGlsZSByZXF1ZXN0cy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUaWxlTGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRtdXRlKCkge1xyXG5cdFx0dGhpcy5tdXRlZCA9IHRydWU7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVubXV0ZXMgdGhlIGxheWVyIGFuZCBpbW1lZGlhdGVseSByZXF1ZXN0cyBhbGwgdmlzaWJsZSB0aWxlcy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUaWxlTGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHR1bm11dGUoKSB7XHJcblx0XHRpZiAodGhpcy5pc011dGVkKCkpIHtcclxuXHRcdFx0dGhpcy5tdXRlZCA9IGZhbHNlO1xyXG5cdFx0XHRpZiAodGhpcy5wbG90KSB7XHJcblx0XHRcdFx0Ly8gcmVxdWVzdCB2aXNpYmxlIHRpbGVzXHJcblx0XHRcdFx0cmVxdWVzdFZpc2libGVUaWxlcyh0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxheWVyIGlzIG11dGVkLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBsYXllciBpcyBtdXRlZC5cclxuXHQgKi9cclxuXHRpc011dGVkKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubXV0ZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVbm11dGVzIGFuZCBzaG93cyB0aGUgbGF5ZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGlsZUxheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZW5hYmxlKCkge1xyXG5cdFx0dGhpcy5zaG93KCk7XHJcblx0XHR0aGlzLnVubXV0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNdXRlcyBhbmQgaGlkZXMgdGhlIGxheWVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RpbGVMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGRpc2FibGUoKSB7XHJcblx0XHR0aGlzLmhpZGUoKTtcclxuXHRcdHRoaXMubXV0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxheWVyIGlzIGRpc2FibGVkIChtdXRlZCBhbmQgaGlkZGVuKS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgZGlzYWJsZWQuXHJcblx0ICovXHJcblx0aXNEaXNhYmxlZCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzTXV0ZWQoKSAmJiB0aGlzLmlzSGlkZGVuKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhcnMgYW55IHBlcnNpc3RlZCBzdGF0ZSBpbiB0aGUgbGF5ZXIgYW5kIHJlZnJlc2hlcyB0aGUgdW5kZXJseWluZ1xyXG5cdCAqIGRhdGEuIFRoaXMgaW52b2x2ZXMgZW1wdHlpbmcgdGhlIHRpbGUgcHlyYW1pZCBhbmQgcmUtcmVxdWVzdGluZyBhbGwgdGhlXHJcblx0ICogdGlsZXMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGlsZUxheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0IC8qKlxyXG4gXHQgKiBDbGVhcnMgYW55IHBlcnNpc3RlZCBzdGF0ZSBpbiB0aGUgbGF5ZXIgYW5kIHJlZnJlc2hlcyB0aGUgdW5kZXJseWluZ1xyXG4gXHQgKiBkYXRhLlxyXG4gXHQgKi9cclxuXHRyZWZyZXNoKCkge1xyXG5cdFx0Ly8gY2xlYXIgdGhlIHVuZGVybHlpbmcgcHlyYW1pZFxyXG5cdFx0dGhpcy5weXJhbWlkLmNsZWFyKCk7XHJcblx0XHQvLyByZXF1ZXN0IGlmIGF0dGFjaGVkIGFuZCBub3QgbXV0ZWRcclxuXHRcdGlmICh0aGlzLnBsb3QgJiYgIXRoaXMuaXNNdXRlZCgpKSB7XHJcblx0XHRcdC8vIHJlcXVlc3QgdmlzaWJsZSB0aWxlc1xyXG5cdFx0XHRyZXF1ZXN0VmlzaWJsZVRpbGVzKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0c3VwZXIucmVmcmVzaCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXF1ZXN0IGEgc3BlY2lmaWMgdGlsZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBjb29yZCAtIFRoZSBjb29yZCBvZiB0aGUgdGlsZSB0byByZXF1ZXN0LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSB1cG9uIGNvbXBsZXRpb24uXHJcblx0ICovXHJcblx0cmVxdWVzdFRpbGUoY29vcmQsIGRvbmUpIHtcclxuXHRcdGRvbmUobnVsbCwgbnVsbCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXF1ZXN0IGFuIGFycmF5IG9mIHRpbGVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtBcnJheX0gY29vcmRzIC0gVGhlIGNvb3JkcyBvZiB0aGUgdGlsZXMgdG8gcmVxdWVzdC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUaWxlTGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRyZXF1ZXN0VGlsZXMoY29vcmRzKSB7XHJcblx0XHRpZiAodGhpcy5pc011dGVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHR0aGlzLnB5cmFtaWQucmVxdWVzdFRpbGVzKGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZUxheWVyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcGFydGlhbCB0aWxlLlxyXG4gKi9cclxuY2xhc3MgVGlsZVBhcnRpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgVGlsZVBhcnRpYWwgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQSBUaWxlUGFydGlhbCBpcyB1c2VkIHRvIHJlbmRlciBhdCBsZWFzdCBhIHBvcnRpb24gb2YgYSBtaXNzaW5nIHRpbGUgYXRcclxuXHQgKiB0aGUgY2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsLiBUaGVyZSBhcmUgdGhyZWUgY2FzZXMgb2ZcclxuXHQgKiBpbnN0YW50aWF0aW9uLlxyXG5cdCAqXHJcblx0ICogQSkgQ2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsIGlzIGFuIGFuY2VzdG9yIHRpbGUuXHJcblx0ICogICAgLSBUaGUgXCJ0YXJnZXRcIiB0aWxlIGlzIGNvbXBsZXRlbHkgY292ZXJlZCBieSBhIHBvcnRpb24gb2YgdGhlIFwiZm91bmRcIlxyXG5cdCAqICAgICAgdGlsZS5cclxuXHQgKiAgICAtIFRoZXJlIGlzIG5vIHBvc2l0aW9uYWwgb2Zmc2V0IG5vciBzY2FsaW5nIG9mIHRoZSBcImZvdW5kXCIgdGlsZSwgaXRcclxuXHQgKiAgICAgIHdpbGwgY292ZXIgdGhlIFwidGFyZ2V0XCIgdGlsZSBpbiBpdHMgZW50aXJlbHkuXHJcblx0ICogICAgLSBUaGVyZSBpcyBhIHV2IG9mZnNldCB0byByZW5kZXIgdGhlIHJlbGV2YW50IHBvcnRpb24gb2YgdGhlIFwiZm91bmRcIlxyXG5cdCAqICAgICAgdGlsZS5cclxuXHQgKlxyXG5cdCAqIEIpIENsb3Nlc3QgYXZhaWxhYmxlIGxldmVsLW9mLWRldGFpbCBpcyBhIGRlc2NlbmRhbnQgdGlsZS5cclxuXHQgKiAgICAtIFRoZSBcInRhcmdldFwiIHRpbGUgaXMgcGFydGlhbGx5IGNvdmVyZWQgYnkgdGhlIFwiZm91bmRcIiB0aWxlLlxyXG5cdCAqICAgIC0gVGhlcmUgaXMgYSBwb3NpdGlvbmFsIG9mZnNldCBhbmQgc2NhbGUgb2YgdGhlIFwiZm91bmRcIiB0aWxlIHJlbGF0aXZlXHJcblx0ICogICAgICB0byB0aGUgXCJ0YXJnZXRcIiB0aWxlLlxyXG5cdCAqICAgIC0gVGhlcmUgaXMgbm8gdXYgb2Zmc2V0LCB0aGUgXCJmb3VuZFwiIHRpbGUgaXMgcmVuZGVyZWQgaW4gaXRzIGVudGlyZXR5LlxyXG5cdCAqXHJcblx0ICogQykgQ2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBcInRhcmdldFwiLCBidXRcclxuXHQgKiAgICBpcyB1c2VkIHRvIGNvdmVyIGEgbWlzc2luZyBkZXNjZW5kYW50LiBUaGlzIG9jY3VycyB3aGVuIG9uZSBvciBtb3JlXHJcblx0ICogICAgZGVzY2VuZGFudCB0aWxlcyBjb3ZlciBhIHBvcnRpb24gb2YgdGhlIFwidGFyZ2V0XCIgdGlsZSwgYnV0IGFuIGFuY2VzdG9yXHJcblx0ICogICAgaXMgcmVxdWlyZWQgdG8gZmlsbCBpbiBhIG1pc3NpbmcgZGVzY2VuZGFudC5cclxuXHQgKiAgICAtIFRoZSBcInRhcmdldFwiIHRpbGUgaXMgcGFydGlhbGx5IGNvdmVyZWQgYnkgdGhlIFwiZm91bmRcIiB0aWxlLlxyXG5cdCAqICAgIC0gVGhlcmUgaXMgYSBwb3NpdGlvbmFsIG9mZnNldCBhbmQgc2NhbGUgb2YgdGhlIFwiZm91bmRcIiB0aWxlIHJlbGF0aXZlXHJcblx0ICogICAgICB0byB0aGUgZGVzY2VuZGFudCB0aGUgdGlsZSBpcyBjb3ZlcmluZy5cclxuXHQgKiAgICAtIFRoZXJlIGlzIGEgdXYgb2Zmc2V0IHRvIHJlbmRlciB0aGUgcmVsZXZhbnQgcG9ydGlvbiBvZiB0aGUgXCJmb3VuZFwiXHJcblx0ICogICAgICB0aWxlIHdoaWNoIGNvdmVycyB0aGUgZGVzY2VuZGFudC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Q29vcmR9IHRhcmdldCAtIFRoZSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIHRoYXQgaXMgYmVpbmcgc3Vic3RpdHV0ZWQuXHJcblx0ICogQHBhcmFtIHtUaWxlfSB0aWxlIC0gVGhlIHRpbGUgZGF0YSBvZiB0aGUgcGFydGlhbCBmb3VuZC5cclxuXHQgKiBAcGFyYW0ge0Nvb3JkfSByZWxhdGl2ZSAtIFRoZSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIHRvIHBvc2l0aW9uIHRoZSBmb3VuZCB0aWxlIHJlbGF0aXZlIHRvLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHRhcmdldCwgdGlsZSwgcmVsYXRpdmUpIHtcclxuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG5cdFx0dGhpcy50aWxlID0gdGlsZTtcclxuXHRcdHRoaXMucmVsYXRpdmUgPSByZWxhdGl2ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlIGEgVGlsZVBhcnRpYWwgb2JqZWN0IGZyb20gdGhlIHRpbGUgaXRzZWxmLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUaWxlfSB0aWxlIC0gVGhlIHRpbGUgZGF0YSBvZiB0aGUgcGFydGlhbC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUaWxlUGFydGlhbH0gVGhlIFRpbGVQYXJ0aWFsIG9iamVjdC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZnJvbVRpbGUodGlsZSkge1xyXG5cdFx0cmV0dXJuIG5ldyBUaWxlUGFydGlhbCh0aWxlLCB0aWxlLCBudWxsKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlIGEgVGlsZVBhcnRpYWwgb2JqZWN0IGZyb20gYW4gYW5jZXN0b3IuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Nvb3JkfSB0YXJnZXQgLSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSB0aGF0IGlzIGJlaW5nIHN1YnN0aXR1dGVkLlxyXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSAtIFRoZSB0aWxlIGFuY2VzdG9yIGRhdGEgb2YgdGhlIHBhcnRpYWwuXHJcblx0ICogQHBhcmFtIHtDb29yZH0gcmVsYXRpdmUgLSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSB0byBwb3NpdGlvbiB0aGUgZm91bmQgdGlsZSByZWxhdGl2ZSB0by5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUaWxlUGFydGlhbH0gVGhlIFRpbGVQYXJ0aWFsIG9iamVjdC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZnJvbUFuY2VzdG9yKHRhcmdldCwgdGlsZSwgcmVsYXRpdmUpIHtcclxuXHRcdHJldHVybiBuZXcgVGlsZVBhcnRpYWwodGFyZ2V0LCB0aWxlLCByZWxhdGl2ZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZSBhIFRpbGVQYXJ0aWFsIG9iamVjdCBmcm9tIGEgZGVzY2VuZGFudC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Q29vcmR9IHRhcmdldCAtIFRoZSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIHRoYXQgaXMgYmVpbmcgc3Vic3RpdHV0ZWQuXHJcblx0ICogQHBhcmFtIHtUaWxlfSB0aWxlIC0gVGhlIHRpbGUgYW5jZXN0b3IgZGF0YSBvZiB0aGUgcGFydGlhbC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUaWxlUGFydGlhbH0gVGhlIFRpbGVQYXJ0aWFsIG9iamVjdC5cclxuXHQgKi9cclxuIFx0c3RhdGljIGZyb21EZXNjZW5kYW50KHRhcmdldCwgdGlsZSkge1xyXG4gXHRcdHJldHVybiBuZXcgVGlsZVBhcnRpYWwodGFyZ2V0LCB0aWxlLCBudWxsKTtcclxuIFx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVQYXJ0aWFsO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XHJcbmNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnbG9kYXNoL3Rocm90dGxlJyk7XHJcbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L0V2ZW50VHlwZScpO1xyXG5jb25zdCBUaWxlRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9UaWxlRXZlbnQnKTtcclxuY29uc3QgTFJVQ2FjaGUgPSByZXF1aXJlKCcuLi8uLi91dGlsL0xSVUNhY2hlJyk7XHJcbmNvbnN0IFRpbGUgPSByZXF1aXJlKCcuL1RpbGUnKTtcclxuY29uc3QgVGlsZVBhcnRpYWwgPSByZXF1aXJlKCcuL1RpbGVQYXJ0aWFsJyk7XHJcblxyXG4vLyBDb25zdGFudHNcclxuXHJcbi8qKlxyXG4gKiBudW1iZXIgb2YgdGhlIHRpbGVzIGhlbGQgaW4gdGhlIHB5cmFtaWQuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgQ0FDSEVfU0laRSA9IDI1NjtcclxuXHJcbi8qKlxyXG4gKiBudW1iZXIgb2YgcGVyc2lzdGVudCB6b29tIGxldmVscyBoZWxkIGluIHRoZSBweXJhbWlkcy5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBQRVJTSVNUQU5UX0xFVkVMUyA9IDQ7XHJcblxyXG4vKipcclxuICogTG9hZGVkIGV2ZW50IHRocm90dGxlIGluIG1pbGxpc2Vjb25kcy5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBMT0FERURfVEhST1RUTEVfTVMgPSAyMDA7XHJcblxyXG4vKipcclxuICogVGhlIG1heGltdW0gZGlzdGFuY2UgdG8gdHJhdmVyc2Ugd2hlbiBjaGVja2luZyBmb3IgdGlsZSBkZXNjZW5kYW50cy5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBNQVhfREVTQ0VOREVOVF9ESVNUID0gNDtcclxuXHJcbi8vIFByaXZhdGUgTWV0aG9kc1xyXG5cclxuY29uc3QgYWRkID0gZnVuY3Rpb24ocHlyYW1pZCwgdGlsZSkge1xyXG5cdGlmICh0aWxlLmNvb3JkLnogPCBweXJhbWlkLm51bVBlcnNpc3RlbnRMZXZlbHMpIHtcclxuXHRcdC8vIHBlcnNpc3RlbnQgdGlsZXNcclxuXHRcdGlmIChweXJhbWlkLnBlcnNpc3RlbnRzLmhhcyh0aWxlLmNvb3JkLmhhc2gpKSB7XHJcblx0XHRcdHRocm93IGBUaWxlIG9mIGNvb3JkICR7dGlsZS5jb29yZC5oYXNofSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgcHlyYW1pZGA7XHJcblx0XHR9XHJcblx0XHRweXJhbWlkLnBlcnNpc3RlbnRzLnNldCh0aWxlLmNvb3JkLmhhc2gsIHRpbGUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBub24tcGVyc2lzdGVudCB0aWxlc1xyXG5cdFx0aWYgKHB5cmFtaWQudGlsZXMuaGFzKHRpbGUuY29vcmQuaGFzaCkpIHtcclxuXHRcdFx0dGhyb3cgYFRpbGUgb2YgY29vcmQgJHt0aWxlLmNvb3JkLmhhc2h9IGFscmVhZHkgZXhpc3RzIGluIHRoZSBweXJhbWlkYDtcclxuXHRcdH1cclxuXHRcdHB5cmFtaWQudGlsZXMuc2V0KHRpbGUuY29vcmQuaGFzaCwgdGlsZSk7XHJcblx0fVxyXG5cdC8vIHN0b3JlIGluIGxldmVsIGFycmF5c1xyXG5cdGlmICghcHlyYW1pZC5sZXZlbHMuaGFzKHRpbGUuY29vcmQueikpIHtcclxuXHRcdHB5cmFtaWQubGV2ZWxzLnNldCh0aWxlLmNvb3JkLnosIFtdKTtcclxuXHR9XHJcblx0cHlyYW1pZC5sZXZlbHMuZ2V0KHRpbGUuY29vcmQueikucHVzaCh0aWxlKTtcclxuXHQvLyBlbWl0IGFkZFxyXG5cdHB5cmFtaWQubGF5ZXIuZW1pdChFdmVudFR5cGUuVElMRV9BREQsIG5ldyBUaWxlRXZlbnQocHlyYW1pZC5sYXllciwgdGlsZSkpO1xyXG59O1xyXG5cclxuY29uc3QgcmVtb3ZlID0gZnVuY3Rpb24ocHlyYW1pZCwgdGlsZSkge1xyXG5cdC8vIG9ubHkgY2hlY2sgZm9yIHBlcnNpc3RlbnQgc2luY2Ugd2UgaXQgd2lsbCBhbHJlYWR5IGJlIHJlbW92ZWQgZnJvbSBscnVcclxuXHQvLyBjYWNoZVxyXG5cdGlmICh0aWxlLmNvb3JkLnogPCBweXJhbWlkLm51bVBlcnNpc3RlbnRMZXZlbHMpIHtcclxuXHRcdGlmICghcHlyYW1pZC5wZXJzaXN0ZW50cy5oYXModGlsZS5jb29yZC5oYXNoKSkge1xyXG5cdFx0XHR0aHJvdyBgVGlsZSBvZiBjb29yZCAke3RpbGUuY29vcmQuaGFzaH0gZG9lcyBub3QgZXhpc3RzIGluIHRoZSBweXJhbWlkYDtcclxuXHRcdH1cclxuXHRcdHB5cmFtaWQucGVyc2lzdGVudHMuZGVsZXRlKHRpbGUuY29vcmQuaGFzaCk7XHJcblx0fVxyXG5cdC8vIHJlbW92ZSBmcm9tIGxldmVsc1xyXG5cdGNvbnN0IGxldmVsID0gcHlyYW1pZC5sZXZlbHMuZ2V0KHRpbGUuY29vcmQueik7XHJcblx0bGV2ZWwuc3BsaWNlKGxldmVsLmluZGV4T2YodGlsZSksIDEpO1xyXG5cdGlmIChsZXZlbC5sZW5ndGggPT09IDApIHtcclxuXHRcdHB5cmFtaWQubGV2ZWxzLmRlbGV0ZSh0aWxlLmNvb3JkLnopO1xyXG5cdH1cclxuXHQvLyBlbWl0IHJlbW92ZVxyXG5cdHB5cmFtaWQubGF5ZXIuZW1pdChFdmVudFR5cGUuVElMRV9SRU1PVkUsIG5ldyBUaWxlRXZlbnQocHlyYW1pZC5sYXllciwgdGlsZSkpO1xyXG59O1xyXG5cclxuY29uc3Qgc3VtUG93ZXJPZkZvdXIgPSBmdW5jdGlvbihuKSB7XHJcblx0cmV0dXJuICgxLzMpICogKE1hdGgucG93KDQsIG4pIC0gMSk7XHJcbn07XHJcblxyXG5jb25zdCBjaGVja0lmTG9hZGVkID0gZnVuY3Rpb24ocHlyYW1pZCkge1xyXG5cdC8vIGlmIG5vIG1vcmUgcGVuZGluZyB0aWxlcywgZW1pdCBsb2FkXHJcblx0aWYgKHB5cmFtaWQucGVuZGluZy5zaXplID09PSAwKSB7XHJcblx0XHRweXJhbWlkLmVtaXRMb2FkKG5ldyBUaWxlRXZlbnQocHlyYW1pZC5sYXllciwgbnVsbCkpO1xyXG5cdH1cclxufTtcclxuXHJcbmNvbnN0IHNvcnRBcm91bmRDZW50ZXIgPSBmdW5jdGlvbihwbG90LCBwYWlycykge1xyXG5cdC8vIGdldCB0aGUgcGxvdCBjZW50ZXIgcG9zaXRpb25cclxuXHRjb25zdCBjZW50ZXIgPSBwbG90LmdldFRhcmdldFZpZXdwb3J0Q2VudGVyKCk7XHJcblx0Ly8gc29ydCB0aGUgcmVxdWVzdHMgYnkgZGlzdGFuY2UgZnJvbSBjZW50ZXIgdGlsZVxyXG5cdHBhaXJzLnNvcnQoKGEsIGIpID0+IHtcclxuXHRcdGNvbnN0IGFDZW50ZXIgPSBhLmNvb3JkLmdldENlbnRlcigpO1xyXG5cdFx0Y29uc3QgYkNlbnRlciA9IGIuY29vcmQuZ2V0Q2VudGVyKCk7XHJcblx0XHRjb25zdCBkYXggPSBjZW50ZXIueCAtIGFDZW50ZXIueDtcclxuXHRcdGNvbnN0IGRheSA9IGNlbnRlci55IC0gYUNlbnRlci55O1xyXG5cdFx0Y29uc3QgZGJ4ID0gY2VudGVyLnggLSBiQ2VudGVyLng7XHJcblx0XHRjb25zdCBkYnkgPSBjZW50ZXIueSAtIGJDZW50ZXIueTtcclxuXHRcdGNvbnN0IGRhID0gZGF4ICogZGF4ICsgZGF5ICogZGF5O1xyXG5cdFx0Y29uc3QgZGIgPSBkYnggKiBkYnggKyBkYnkgKiBkYnk7XHJcblx0XHRyZXR1cm4gZGEgLSBkYjtcclxuXHR9KTtcclxuXHRyZXR1cm4gcGFpcnM7XHJcbn07XHJcblxyXG5jb25zdCByZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24ocGFpcnMpIHtcclxuXHRjb25zdCBzZWVuID0gbmV3IE1hcCgpO1xyXG5cdHJldHVybiBwYWlycy5maWx0ZXIoZnVuY3Rpb24ocGFpcikge1xyXG5cdFx0Y29uc3QgaGFzaCA9IHBhaXIubmNvb3JkLmhhc2g7XHJcblx0XHRyZXR1cm4gc2Vlbi5oYXMoaGFzaCkgPyBmYWxzZSA6IChzZWVuLnNldChoYXNoLCB0cnVlKSk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5jb25zdCByZW1vdmVQZW5kaW5nT3JFeGlzdGluZyA9IGZ1bmN0aW9uKHB5cmFtaWQsIHBhaXJzKSB7XHJcblx0cmV0dXJuIHBhaXJzLmZpbHRlcihwYWlyID0+IHtcclxuXHRcdC8vIHdlIGFscmVhZHkgaGF2ZSB0aGUgdGlsZSwgb3IgaXQncyBjdXJyZW50bHkgcGVuZGluZ1xyXG5cdFx0Ly8gTk9URTogdXNlIGBnZXRgIGhlcmUgdG8gdXBkYXRlIHRoZSByZWNlbnRuZXNzIG9mIHRoZSB0aWxlIGluIExSVVxyXG5cdFx0cmV0dXJuICFweXJhbWlkLmdldChwYWlyLm5jb29yZCkgJiYgIXB5cmFtaWQuaXNQZW5kaW5nKHBhaXIubmNvb3JkKTtcclxuXHR9KTtcclxufTtcclxuXHJcbmNvbnN0IGZsYWdUaWxlQXNTdGFsZSA9IGZ1bmN0aW9uKHB5cmFtaWQsIHRpbGUpIHtcclxuXHRjb25zdCBoYXNoID0gdGlsZS5jb29yZC5oYXNoO1xyXG5cdGxldCB1aWRzID0gcHlyYW1pZC5zdGFsZS5nZXQoaGFzaCk7XHJcblx0aWYgKCF1aWRzKSB7XHJcblx0XHR1aWRzID0gbmV3IE1hcCgpO1xyXG5cdFx0cHlyYW1pZC5zdGFsZS5zZXQoaGFzaCwgdWlkcyk7XHJcblx0fVxyXG5cdHVpZHMuc2V0KHRpbGUudWlkLCB0cnVlKTtcclxufTtcclxuXHJcbmNvbnN0IGlzVGlsZVN0YWxlID0gZnVuY3Rpb24ocHlyYW1pZCwgdGlsZSkge1xyXG5cdGNvbnN0IGhhc2ggPSB0aWxlLmNvb3JkLmhhc2g7XHJcblx0Ly8gY2hlY2sgaWYgdWlkIGlzIGZsYWdnZWQgYXMgc3RhbGVcclxuXHRjb25zdCB1aWRzID0gcHlyYW1pZC5zdGFsZS5nZXQoaGFzaCk7XHJcblx0aWYgKHVpZHMgJiYgdWlkcy5oYXModGlsZS51aWQpKSB7XHJcblx0XHQvLyB0aWxlIGlzIHN0YWxlXHJcblx0XHR1aWRzLmRlbGV0ZSh0aWxlLnVpZCk7XHJcblx0XHRpZiAodWlkcy5zaXplID09PSAwKSB7XHJcblx0XHRcdHB5cmFtaWQuc3RhbGUuZGVsZXRlKGhhc2gpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbmNvbnN0IHNob3VsZERpc2NhcmQgPSBmdW5jdGlvbihweXJhbWlkLCB0aWxlKSB7XHJcblx0Y29uc3QgcGxvdCA9IHB5cmFtaWQubGF5ZXIucGxvdDtcclxuXHRpZiAoIXBsb3QpIHtcclxuXHRcdC8vIGxheWVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBwbG90LCBkaXNjYXJkIHRpbGVcclxuXHRcdC8vIE5PVEU6IHRoaXMgc2hvdWxkIF9ORVZFUl8gaGFwcGVuLCBzaW5jZSB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlIGZyb21cclxuXHRcdC8vIHRoZSBwbG90LCB0aGUgcGVuZGluZyB0aWxlcyBhcmUgYWxsIGZsYWdnZWQgYXMgc3RhbGUuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0Ly8gY2hlY2sgaWYgdGlsZSBpcyBpbiB2aWV3LCBpZiBub3QsIGRpc2NhcmRcclxuXHRjb25zdCB2aWV3cG9ydCA9IHBsb3QuZ2V0VGFyZ2V0Vmlld3BvcnQoKTtcclxuXHRyZXR1cm4gIXZpZXdwb3J0LmlzSW5WaWV3KHRpbGUuY29vcmQsIHBsb3Qud3JhcGFyb3VuZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcHlyYW1pZCBvZiB0aWxlcy5cclxuICovXHJcbmNsYXNzIFRpbGVQeXJhbWlkIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFRpbGVQeXJhbWlkIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBweXJhbWlkIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2FjaGVTaXplIC0gVGhlIHNpemUgb2YgdGhlIHRpbGUgY2FjaGUuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubnVtUGVyc2lzdGVudExldmVscyAtIFRoZSBudW1iZXIgb2YgcGVyc2lzdGVudCBsZXZlbHMgaW4gdGhlIHB5cmFtaWQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IobGF5ZXIsIG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHR0aHJvdyAnTm8gbGF5ZXIgcGFyYW1ldGVyIHByb3ZpZGVkJztcclxuXHRcdH1cclxuXHRcdHRoaXMuY2FjaGVTaXplID0gZGVmYXVsdFRvKG9wdGlvbnMuY2FjaGVTaXplLCBDQUNIRV9TSVpFKTtcclxuXHRcdHRoaXMubnVtUGVyc2lzdGVudExldmVscyA9IGRlZmF1bHRUbyhvcHRpb25zLm51bVBlcnNpc3RlbnRMZXZlbHMsIFBFUlNJU1RBTlRfTEVWRUxTKTtcclxuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcclxuXHRcdHRoaXMubGV2ZWxzID0gbmV3IE1hcCgpO1xyXG5cdFx0dGhpcy5wZXJzaXN0ZW50cyA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXMucGVuZGluZyA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXMuc3RhbGUgPSBuZXcgTWFwKCk7XHJcblx0XHR0aGlzLnRpbGVzID0gbmV3IExSVUNhY2hlKHtcclxuXHRcdFx0Y2FwYWNpdHk6IHRoaXMuY2FjaGVTaXplLFxyXG5cdFx0XHRvblJlbW92ZTogdGlsZSA9PiB7XHJcblx0XHRcdFx0cmVtb3ZlKHRoaXMsIHRpbGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdC8vIGNyZWF0ZSB0aHJvdHRsZWQgZW1pdCBsb2FkIGV2ZW50IGZvciB0aGlzIGxheWVyXHJcblx0XHR0aGlzLmVtaXRMb2FkID0gdGhyb3R0bGUoZXZlbnQgPT4ge1xyXG5cdFx0XHR0aGlzLmxheWVyLmVtaXQoRXZlbnRUeXBlLkxPQUQsIGV2ZW50KTtcclxuXHRcdH0sIExPQURFRF9USFJPVFRMRV9NUyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB0b3RhbCBjYXBhY2l0eSBvZiB0aGUgdGlsZSBweXJhbWlkLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHRvdGFsIGNhcGFjaXR5IG9mIHRoZSBweXJhbWlkLlxyXG5cdCAqL1xyXG5cdGdldENhcGFjaXR5KCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVTaXplICsgc3VtUG93ZXJPZkZvdXIodGhpcy5udW1QZXJzaXN0ZW50TGV2ZWxzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtcHRpZXMgdGhlIGN1cnJlbnQgcHlyYW1pZCBvZiBhbGwgdGlsZXMsIGZsYWdzIGFueSBwZW5kaW5nIHRpbGVzIGFzXHJcblx0ICogc3RhbGUuXHJcblx0ICovXHJcblx0Y2xlYXIoKSB7XHJcblx0XHQvLyBhbnkgcGVuZGluZyB0aWxlcyBhcmUgbm93IGZsYWdnZWQgYXMgc3RhbGVcclxuXHRcdHRoaXMucGVuZGluZy5mb3JFYWNoKHRpbGUgPT4ge1xyXG5cdFx0XHQvLyBmbGFnIHVpZCBhcyBzdGFsZVxyXG5cdFx0XHRmbGFnVGlsZUFzU3RhbGUodGhpcywgdGlsZSk7XHJcblx0XHR9KTtcclxuXHRcdHRoaXMucGVuZGluZyA9IG5ldyBNYXAoKTsgLy8gZnJlc2ggbWFwXHJcblx0XHQvLyBjbGVhciBwZXJzaXN0ZW50IHRpbGVzXHJcblx0XHR0aGlzLnBlcnNpc3RlbnRzLmZvckVhY2godGlsZSA9PiB7XHJcblx0XHRcdHJlbW92ZSh0aGlzLCB0aWxlKTtcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5wZXJzaXN0ZW50cy5jbGVhcigpO1xyXG5cdFx0Ly8gY2xlYXIgbHJ1IGNhY2hlXHJcblx0XHR0aGlzLnRpbGVzLmNsZWFyKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUZXN0IHdoZXRoZXIgb3Igbm90IGEgY29vcmQgaXMgaGVsZCBpbiBjYWNoZSBpbiB0aGUgcHlyYW1pZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBuY29vcmQgLSBUaGUgbm9ybWFsaXplZCBjb29yZCB0byB0ZXN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBjb29yZCBleGlzdHMgaW4gdGhlIHB5cmFtaWQuXHJcblx0ICovXHJcblx0aGFzKG5jb29yZCkge1xyXG5cdFx0aWYgKG5jb29yZC56IDwgdGhpcy5udW1QZXJzaXN0ZW50TGV2ZWxzKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnBlcnNpc3RlbnRzLmhhcyhuY29vcmQuaGFzaCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy50aWxlcy5oYXMobmNvb3JkLmhhc2gpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSXRlcmF0ZXMgb3ZlciBhbmQgZXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGZvciBhbGwgdGlsZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdGlsZS5cclxuXHQgKi9cclxuXHRmb3JFYWNoKGZuKSB7XHJcblx0XHR0aGlzLnBlcnNpc3RlbnRzLmZvckVhY2goZm4pO1xyXG5cdFx0dGhpcy50aWxlcy5mb3JFYWNoKGZuKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3Qgd2hldGhlciBvciBub3QgYSBjb29yZCBpcyBjdXJyZW50bHkgcGVuZGluZy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBuY29vcmQgLSBUaGUgbm9ybWFsaXplZCBjb29yZCB0byB0ZXN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBjb29yZCBpcyBjdXJyZW50bHkgcGVuZGluZy5cclxuXHQgKi9cclxuXHRpc1BlbmRpbmcobmNvb3JkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wZW5kaW5nLmhhcyhuY29vcmQuaGFzaCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB0aWxlIG1hdGNoaW5nIHRoZSBwcm92aWRlZCBjb29yZC4gSWYgdGhlIHRpbGUgZG9lcyBub3RcclxuXHQgKiBleGlzdCwgcmV0dXJucyB1bmRlZmluZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gbmNvb3JkIC0gVGhlIG5vcm1hbGl6ZWQgY29vcmQgb2YgdGhlIHRpbGUgdG8gcmV0dXJuLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RpbGV9IFRoZSB0aWxlIG9iamVjdC5cclxuXHQgKi9cclxuXHRnZXQobmNvb3JkKSB7XHJcblx0XHRpZiAobmNvb3JkLnogPCB0aGlzLm51bVBlcnNpc3RlbnRMZXZlbHMpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMucGVyc2lzdGVudHMuZ2V0KG5jb29yZC5oYXNoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnRpbGVzLmdldChuY29vcmQuaGFzaCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBhbmNlc3RvciB0aWxlIG9mIHRoZSBjb29yZCBhdCB0aGUgcHJvdmlkZWQgb2Zmc2V0LiBJZiBub1xyXG5cdCAqIHRpbGUgZXhpc3RzIGluIHRoZSBweXJhbWlkLCByZXR1cm5zIHVuZGVmaW5lZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBuY29vcmQgLSBUaGUgbm9ybWFsaXplZCBjb29yZCBvZiB0aGUgdGlsZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGlzdCAtIFRoZSBvZmZzZXQgZnJvbSB0aGUgdGlsZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUaWxlfSBUaGUgYW5jZXN0b3IgdGlsZSBvZiB0aGUgcHJvdmlkZWQgY29vcmQuXHJcblx0ICovXHJcblx0Z2V0QW5jZXN0b3IobmNvb3JkLCBkaXN0KSB7XHJcblx0XHRjb25zdCBhbmNlc3RvciA9IG5jb29yZC5nZXRBbmNlc3RvcihkaXN0KTtcclxuXHRcdHJldHVybiB0aGlzLmdldChhbmNlc3Rvcik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBkZXNjZW5kYW50IHRpbGVzIG9mIHRoZSBjb29yZCBhdCB0aGUgcHJvdmlkZWQgb2Zmc2V0LiBJZiBhdFxyXG5cdCAqIGxlYXN0IG9uZSB0aWxlIGV4aXN0cyBpbiB0aGUgcHlyYW1pZCwgYW4gYXJyYXkgb2Ygc2l6ZSA0XmRpc3Qgd2lsbCBiZVxyXG5cdCAqIHJldHVybmVkLiBFYWNoIGVsZW1lbnQgd2lsbCBlaXRoZXIgYmUgYSB0aWxlIChpbiB0aGUgY2FzZSB0aGF0IGl0IGV4aXN0cylcclxuXHQgKiBvciBhIGNvb3JkIChpbiB0aGUgY2FzZSB0aGF0IGl0IGRvZXMgbm90IGV4aXN0KS4gSWYgbm8gZGVzY2VuZGFudCB0aWxlc1xyXG5cdCAqIGFyZSBmb3VuZCBpbiB0aGUgcHlyYW1pZCwgcmV0dXJucyB1bmRlZmluZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gbmNvb3JkIC0gVGhlIG5vcm1hbGl6ZWQgY29vcmQgb2YgdGhlIHRpbGUuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRpc3QgLSBUaGUgb2Zmc2V0IGZyb20gdGhlIHRpbGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBkZXNjZW5kYW50IHRpbGVzIGFuZCBvciBjb29yZGluYXRlcyBvZiB0aGUgcHJvdmlkZWQgY29vcmQuXHJcblx0ICovXHJcblx0Z2V0RGVzY2VuZGFudHMobmNvb3JkLCBkaXN0KSB7XHJcblx0XHQvLyBnZXQgY29vcmQgZGVzY2VuZGFudHNcclxuXHRcdGNvbnN0IGRlc2NlbmRhbnRzID0gbmNvb3JkLmdldERlc2NlbmRhbnRzKGRpc3QpO1xyXG5cdFx0Ly8gY2hlY2sgaWYgd2UgaGF2ZSBhbnlcclxuXHRcdGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cdFx0Zm9yIChsZXQgaT0wOyBpPGRlc2NlbmRhbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLmhhcyhkZXNjZW5kYW50c1tpXSkpIHtcclxuXHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdC8vIGlmIHNvIHJldHVybiB3aGF0IHdlIGhhdmVcclxuXHRcdGlmIChmb3VuZCkge1xyXG5cdFx0XHRjb25zdCByZXMgPSBuZXcgQXJyYXkoZGVzY2VuZGFudHMubGVuZ3RoKTtcclxuXHRcdFx0Zm9yIChsZXQgaT0wOyBpPGRlc2NlbmRhbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0Y29uc3QgZGVzY2VuZGFudCA9IGRlc2NlbmRhbnRzW2ldO1xyXG5cdFx0XHRcdC8vIGFkZCB0aWxlIGlmIGl0IGV4aXN0cywgY29vcmQgaWYgaXQgZG9lc24ndFxyXG5cdFx0XHRcdHJlc1tpXSA9IHRoaXMuZ2V0KGRlc2NlbmRhbnQpIHx8IGRlc2NlbmRhbnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXF1ZXN0cyB0aWxlcyBmb3IgdGhlIHByb3ZpZGVkIGNvb3Jkcy4gSWYgdGhlIHRpbGVzIGFscmVhZHkgZXhpc3RcclxuXHQgKiBpbiB0aGUgcHlyYW1pZCBvciBpcyBjdXJyZW50bHkgcGVuZGluZyBubyByZXF1ZXN0IGlzIG1hZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgLSBUaGUgYXJyYXkgb2YgY29vcmRzIHRvIHJlcXVlc3QuXHJcblx0ICovXHJcblx0cmVxdWVzdFRpbGVzKGNvb3Jkcykge1xyXG5cclxuXHRcdC8vIHdlIG5lZWQgYm90aCB0aGUgbm9ybWFsaXplZCBhbiB1bi1ub3JtYWxpemVkIGNvb3Jkcy5cclxuXHRcdC8vIG5vcm1hbGl6ZWQgY29vcmRzIGFyZSB1c2VkIGZvciByZXF1ZXN0cyB3aGlsZSB1bi1ub3JtYWxpemVkIGFyZSB1c2VkXHJcblx0XHQvLyB0byBzb3J0IHRoZW0gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcclxuXHRcdGxldCBwYWlycyA9IGNvb3Jkcy5tYXAoY29vcmQgPT4ge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNvb3JkOiBjb29yZCxcclxuXHRcdFx0XHRuY29vcmQ6IGNvb3JkLm5vcm1hbGl6ZSgpXHJcblx0XHRcdH07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyByZW1vdmUgYW55IGR1cGxpY2F0ZXNcclxuXHRcdHBhaXJzID0gcmVtb3ZlRHVwbGljYXRlcyhwYWlycyk7XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIGFueSB0aWxlcyB3ZSBhbHJlYWR5IGhhdmUgb3IgdGhhdCBhcmUgY3VycmVudGx5IHBlbmRpbmdcclxuXHRcdHBhaXJzID0gcmVtb3ZlUGVuZGluZ09yRXhpc3RpbmcodGhpcywgcGFpcnMpO1xyXG5cclxuXHRcdC8vIHNvcnQgY29vcmRzIGJ5IGRpc3RhbmNlIGZyb20gdmlld3BvcnQgY2VudGVyXHJcblx0XHRwYWlycyA9IHNvcnRBcm91bmRDZW50ZXIodGhpcy5sYXllci5wbG90LCBwYWlycyk7XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgdGlsZXMgYW5kIGZsYWcgYXMgcGVuZGluZ1xyXG5cdFx0Ly8gTk9URTogd2UgZmxhZyB0aGVtIGFsbCBub3cgaW5jYXNlIGEgYGNsZWFyYCBpcyBjYWxsZWQgaW5zaWRlIHRoZVxyXG5cdFx0Ly8gYHJlcXVlc3RUaWxlYCBjYWxsLlxyXG5cdFx0Y29uc3QgdGlsZXMgPSBwYWlycy5tYXAocGFpciA9PiB7XHJcblx0XHRcdGNvbnN0IHRpbGUgPSBuZXcgVGlsZShwYWlyLm5jb29yZCk7XHJcblx0XHRcdC8vIGFkZCB0aWxlIHRvIHBlbmRpbmcgYXJyYXlcclxuXHRcdFx0dGhpcy5wZW5kaW5nLnNldCh0aWxlLmNvb3JkLmhhc2gsIHRpbGUpO1xyXG5cdFx0XHRyZXR1cm4gdGlsZTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIHJlcXVlc3QgdGhlIHRpbGVzXHJcblx0XHRmb3IgKGxldCBpPTA7IGk8dGlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgdGlsZSA9IHRpbGVzW2ldO1xyXG5cdFx0XHQvLyBlbWl0IHJlcXVlc3RcclxuXHRcdFx0dGhpcy5sYXllci5lbWl0KEV2ZW50VHlwZS5USUxFX1JFUVVFU1QsIG5ldyBUaWxlRXZlbnQodGhpcy5sYXllciwgdGlsZSkpO1xyXG5cdFx0XHQvLyByZXF1ZXN0IHRpbGVcclxuXHRcdFx0dGhpcy5sYXllci5yZXF1ZXN0VGlsZSh0aWxlLmNvb3JkLCAoZXJyLCBkYXRhKSA9PiB7XHJcblx0XHRcdFx0Ly8gY2hlY2sgaWYgc3RhbGUsIGNsZWFycyBzdGFsZSBzdGF0dXNcclxuXHRcdFx0XHRjb25zdCBpc1N0YWxlID0gaXNUaWxlU3RhbGUodGhpcywgdGlsZSk7XHJcblx0XHRcdFx0Ly8gaWYgbm90IHN0YWxlIHJlbW92ZSB0aWxlIGZyb20gcGVuZGluZ1xyXG5cdFx0XHRcdGlmICghaXNTdGFsZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5wZW5kaW5nLmRlbGV0ZSh0aWxlLmNvb3JkLmhhc2gpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBjaGVjayBlcnJcclxuXHRcdFx0XHRpZiAoZXJyICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHQvLyBhZGQgZXJyXHJcblx0XHRcdFx0XHR0aWxlLmVyciA9IGVycjtcclxuXHRcdFx0XHRcdC8vIGVtaXQgZmFpbHVyZVxyXG5cdFx0XHRcdFx0dGhpcy5sYXllci5lbWl0KEV2ZW50VHlwZS5USUxFX0ZBSUxVUkUsIG5ldyBUaWxlRXZlbnQodGhpcy5sYXllciwgdGlsZSkpO1xyXG5cdFx0XHRcdFx0Ly8gaWYgbm90IHN0YWxlLCBjaGVjayBpZiBsb2FkZWRcclxuXHRcdFx0XHRcdGlmICghaXNTdGFsZSkge1xyXG5cdFx0XHRcdFx0XHRjaGVja0lmTG9hZGVkKHRoaXMpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBhZGQgZGF0YSB0byB0aGUgdGlsZVxyXG5cdFx0XHRcdHRpbGUuZGF0YSA9IGRhdGE7XHJcblx0XHRcdFx0Ly8gY2hlY2sgaWYgdGlsZSBzaG91bGQgYmUgZGlzY2FyZGVkXHJcblx0XHRcdFx0aWYgKGlzU3RhbGUgfHwgc2hvdWxkRGlzY2FyZCh0aGlzLCB0aWxlKSkge1xyXG5cdFx0XHRcdFx0Ly8gZW1pdCBkaXNjYXJkXHJcblx0XHRcdFx0XHR0aGlzLmxheWVyLmVtaXQoRXZlbnRUeXBlLlRJTEVfRElTQ0FSRCwgbmV3IFRpbGVFdmVudCh0aGlzLmxheWVyLCB0aWxlKSk7XHJcblx0XHRcdFx0XHQvLyBpZiBub3Qgc3RhbGUsIGNoZWNrIGlmIGxvYWRlZFxyXG5cdFx0XHRcdFx0aWYgKCFpc1N0YWxlKSB7XHJcblx0XHRcdFx0XHRcdGNoZWNrSWZMb2FkZWQodGhpcyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGFkZCB0byB0aWxlIHB5cmFtaWRcclxuXHRcdFx0XHRhZGQodGhpcywgdGlsZSk7XHJcblx0XHRcdFx0Ly8gY2hlY2sgaWYgbG9hZGVkXHJcblx0XHRcdFx0Y2hlY2tJZkxvYWRlZCh0aGlzKTtcclxuXHRcdFx0XHQvLyBmbGFnIGFzIGRpcnR5XHJcblx0XHRcdFx0dGhpcy5sYXllci5wbG90LnNldERpcnR5KCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSWYgdGhlIHRpbGUgZXhpc3RzIGluIHRoZSBweXJhbWlkLCByZXR1cm4gaXQuIE90aGVyd2lzZSByZXR1cm4gdGhlXHJcblx0ICogY2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsIGZvciB0aWxlLCB0aGlzIG1heSBiZSBhIHNpbmdsZSBhbmNlc3RvclxyXG5cdCAqIG9yIG11bHRpcGxlIGRlc2NlbmRhbnRzLCBvciBhIGNvbWJpbmF0aW9uIG9mIGJvdGguXHJcblx0ICpcclxuXHQgKiBJZiBubyBhbmNlc3RvciBvciBkZXNjZW5kYW50cyBleGlzdCwgcmV0dXJuIHVuZGVmaW5lZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBuY29vcmQgLSBUaGUgbm9ybWFsaXplZCBjb29yZCBvZiB0aGUgdGlsZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIHRpbGUgcGFydGlhbHMgdGhhdCBjbG9zZXN0IG1hdGNoIHRoZSBwcm92aWRlZCBjb29yZC5cclxuXHQgKi9cclxuXHRnZXRBdmFpbGFibGVMT0QobmNvb3JkKSB7XHJcblx0XHQvLyBjaGVjayBpZiB3ZSBoYXZlIHRoZSB0aWxlXHJcblx0XHRjb25zdCB0aWxlID0gdGhpcy5nZXQobmNvb3JkKTtcclxuXHRcdGlmICh0aWxlKSB7XHJcblx0XHRcdC8vIGlmIGV4aXN0cywgcmV0dXJuIGl0XHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0VGlsZVBhcnRpYWwuZnJvbVRpbGUodGlsZSlcclxuXHRcdFx0XTtcclxuXHRcdH1cclxuXHRcdC8vIGlmIG5vdCwgZmluZCB0aGUgY2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsXHJcblxyXG5cdFx0Ly8gZmlyc3QsIGdldCB0aGUgYXZhaWxhYmxlIGxldmVscyBvZiBkZXRhaWwsIGFzY2VuZGluZyBpbiBkaXN0YW5jZVxyXG5cdFx0Ly8gZnJvbSB0aGUgb3JpZ2luYWwgY29vcmQgem9vbVxyXG5cdFx0Y29uc3Qgem9vbSA9IG5jb29yZC56O1xyXG5cdFx0Y29uc3QgbGV2ZWxzID0gW107XHJcblx0XHR0aGlzLmxldmVscy5mb3JFYWNoKChfLCBrZXkpID0+IHtcclxuXHRcdFx0aWYgKGtleSAhPT0gem9vbSkge1xyXG5cdFx0XHRcdGxldmVscy5wdXNoKGtleSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bGV2ZWxzLnNvcnQoKGEsIGIpID0+IHtcclxuXHRcdFx0Ly8gZ2l2ZSBwcmlvcml0eSB0byBhbmNlc3RvciBsZXZlbHMgc2luY2UgdGhleSBhcmUgY2hlYXBlclxyXG5cdFx0XHRjb25zdCBkYSA9IChhID4gem9vbSkgPyAoYSAtIHpvb20pIDogKHpvb20gLSBhIC0gMC41KTtcclxuXHRcdFx0Y29uc3QgZGIgPSAoYiA+IHpvb20pID8gKGIgLSB6b29tKSA6ICh6b29tIC0gYiAtIDAuNSk7XHJcblx0XHRcdHJldHVybiBkYSAtIGRiO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgcmVzdWx0cyA9IFtdO1xyXG5cdFx0Y29uc3QgcXVldWUgPSBbXTtcclxuXHRcdGxldCBjdXJyZW50ID0gbmNvb3JkO1xyXG5cdFx0bGV0IGxldmVsID0gbGV2ZWxzLnNoaWZ0KCk7XHJcblxyXG5cdFx0Ly8gc2Vjb25kLCBpdGVyYXRlIHRocm91Z2ggYXZhaWxhYmxlIGxldmVscyBzZWFyY2hpbmcgZm9yIHRoZSBjbG9zZXN0XHJcblx0XHQvLyBsZXZlbC1vZi1kZXRhaWwgZm9yIHRoZSBjdXJyZW50IGhlYWQgb2YgdGhlIHF1ZXVlXHJcblx0XHR3aGlsZSAoY3VycmVudCAhPT0gdW5kZWZpbmVkICYmIGxldmVsICE9PSB1bmRlZmluZWQpIHtcclxuXHJcblx0XHRcdGlmIChsZXZlbCA8IGN1cnJlbnQueikge1xyXG5cdFx0XHRcdC8vIHRyeSB0byBmaW5kIGFuY2VzdG9yXHJcblx0XHRcdFx0Y29uc3QgZGlzdCA9IGN1cnJlbnQueiAtIGxldmVsO1xyXG5cdFx0XHRcdGNvbnN0IGFuY2VzdG9yID0gdGhpcy5nZXRBbmNlc3RvcihjdXJyZW50LCBkaXN0KTtcclxuXHRcdFx0XHRpZiAoYW5jZXN0b3IpIHtcclxuXHRcdFx0XHRcdC8vIHRpbGUgZm91bmQsIGNyZWF0ZSBhIHRpbGUgcGFydGlhbCBmcm9tIHRoZSBhbmNlc3RvclxyXG5cdFx0XHRcdFx0cmVzdWx0cy5wdXNoKFxyXG5cdFx0XHRcdFx0XHRUaWxlUGFydGlhbC5mcm9tQW5jZXN0b3IoXHJcblx0XHRcdFx0XHRcdFx0bmNvb3JkLCAvLyB0YXJnZXRcclxuXHRcdFx0XHRcdFx0XHRhbmNlc3RvciwgLy8gdGlsZVxyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQpKTsgLy8gcmVsYXRpdmVcclxuXHRcdFx0XHRcdC8vIHBvcCBuZXh0IGNvb3JkIHRvIHNlYXJjaCBvZmYgdGhlIHF1ZXVlXHJcblx0XHRcdFx0XHRjdXJyZW50ID0gcXVldWUuc2hpZnQoKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNoZWNrcyBhcmUgbXVjaCBtb3JlIGV4cGVuc2l2ZSwgc28gbGltaXQgdGhpc1xyXG5cdFx0XHRcdC8vIGJhc2VkIG9uIGRpc3RhbmNlIHRvIHRoZSBvcmlnaW5hbCBjb29yZCB6b29tXHJcblx0XHRcdFx0Ly8gTk9URTogdGhpcyBkaXN0YW5jZSBjYWxjdWxhdGlvbiBpcyBzYWZlIGJlY2F1c2UgaXQgaXMgYWx3YXlzXHJcblx0XHRcdFx0Ly8gdHJ1ZSB0aGF0IFwiY3VycmVudC56ID49IHpvb21cIiBiZWNhdXNlIG9ubHkgZGVzY2VuZGFudCBjb29yZHNcclxuXHRcdFx0XHQvLyBhcmUgYXBwZW5kZWQgdG8gdGhlIHF1ZXVlLlxyXG5cdFx0XHRcdC8vIHRoZXJlZm9yZSBpbiB0aGUgY2FzZSB0aGF0IFwibGV2ZWwgPj0gY3VycmVudC56XCIsIHRoZW5cclxuXHRcdFx0XHQvLyBcImxldmVsID49IHpvb21cIiBtdXN0IGJlIHRydWUgYXMgd2VsbC5cclxuXHRcdFx0XHRjb25zdCBuZGlzdCA9IGxldmVsIC0gem9vbTtcclxuXHRcdFx0XHRpZiAobmRpc3QgPCBNQVhfREVTQ0VOREVOVF9ESVNUKSB7XHJcblx0XHRcdFx0XHQvLyB0cnkgdG8gZmluZCBkZXNjZW5kYW50XHJcblx0XHRcdFx0XHRjb25zdCBkaXN0ID0gbGV2ZWwgLSBjdXJyZW50Lno7XHJcblx0XHRcdFx0XHRjb25zdCBkZXNjZW5kYW50cyA9IHRoaXMuZ2V0RGVzY2VuZGFudHMoY3VycmVudCwgZGlzdCk7XHJcblx0XHRcdFx0XHRpZiAoZGVzY2VuZGFudHMpIHtcclxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaj0wOyBqPGRlc2NlbmRhbnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgZGVzY2VuZGFudCA9IGRlc2NlbmRhbnRzW2pdO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChkZXNjZW5kYW50LmNvb3JkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyB0aWxlIGZvdW5kLCAgY3JlYXRlIGEgdGlsZSBwYXJ0aWFsIGZyb20gdGhlXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBkZXNjZW5kYW50XHJcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goXHJcblx0XHRcdFx0XHRcdFx0XHRcdFRpbGVQYXJ0aWFsLmZyb21EZXNjZW5kYW50KFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5jb29yZCwgLy8gdGFyZ2V0XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVzY2VuZGFudCkpOyAvLyB0aWxlXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIG5vIHRpbGUgZm91bmQsIGRlc2NlbmRhbnQgaXMgYSBjb29yZFxyXG5cdFx0XHRcdFx0XHRcdFx0cXVldWUucHVzaChkZXNjZW5kYW50KTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Y3VycmVudCA9IHF1ZXVlLnNoaWZ0KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIG5vdGhpbmcgZm91bmQgaW4gbGV2ZWwsIHdlIGNhbiBzYWZlbHkgcmVtb3ZlIGl0IGZyb20gdGhlIHNlYXJjaFxyXG5cdFx0XHRsZXZlbCA9IGxldmVscy5zaGlmdCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZXN1bHRzLmxlbmd0aCA+IDApID8gcmVzdWx0cyA6IHVuZGVmaW5lZDtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZVB5cmFtaWQ7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBzaXplIG9mIHRoZSBjZWxsLCBpbiBwaXhlbHMuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgQ0VMTF9TSVpFID0gTWF0aC5wb3coMiwgMTYpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBoYWxmIHNpemUgb2YgdGhlIGNlbGwsIGluIHBpeGVscy5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBDRUxMX0hBTEZfU0laRSA9IENFTExfU0laRSAvIDI7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2VsbCBmb3IgY2xpcHBpbmcgYSByZW5kZXJpbmcgc3BhY2UuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jbGFzcyBDZWxsIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IENlbGwgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBUaGUgem9vbSB0aGUgdGhlIGNlbGxzIGlzIGdlbmVyYXRlZCBmb3IuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGNlbnRlciAtIFRoZSBwbG90IHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNlbGwuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGV4dGVudCAtIFRoZSBwaXhlbCBleHRlbnQgb2YgdGhlIHBsb3QgYXQgdGhlIHRpbWUgb2YgZ2VuZXJhdGlvbi5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcih6b29tLCBjZW50ZXIsIGV4dGVudCkge1xyXG5cdFx0Y29uc3QgaGFsZlNpemUgPSBDRUxMX0hBTEZfU0laRSAvIGV4dGVudDtcclxuXHRcdGNvbnN0IG9mZnNldCA9IHtcclxuXHRcdFx0eDogY2VudGVyLnggLSBoYWxmU2l6ZSxcclxuXHRcdFx0eTogY2VudGVyLnkgLSBoYWxmU2l6ZVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuem9vbSA9IHpvb207XHJcblx0XHR0aGlzLmhhbGZTaXplID0gaGFsZlNpemU7XHJcblx0XHR0aGlzLmNlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0dGhpcy5leHRlbnQgPSBleHRlbnQ7XHJcblx0XHR0aGlzLmJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHRcdGNlbnRlci54IC0gaGFsZlNpemUsXHJcblx0XHRcdGNlbnRlci54ICsgaGFsZlNpemUsXHJcblx0XHRcdGNlbnRlci55IC0gaGFsZlNpemUsXHJcblx0XHRcdGNlbnRlci55ICsgaGFsZlNpemUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUHJvamVjdCBhIG5vcm1hbGl6ZWQgcGxvdCBjb29yZGluYXRlIHRvIHRoZSBwaXhlbCBzcGFjZSBvZiB0aGUgY2VsbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3MgLSBUaGUgbm9ybWFsaXplZCBwbG90IGNvb3JkaW5hdGUuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBUaGUgem9vbSBvZiB0aGUgcGxvdCBwaXhlbCBzcGFjZSB0byBwcm9qZWN0IHRvLiBPcHRpb25hbC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjb29yZGluYXRlIGluIGNlbGwgcGl4ZWwgc3BhY2UuXHJcblx0ICovXHJcblx0cHJvamVjdChwb3MsIHpvb20gPSB0aGlzLnpvb20pIHtcclxuXHRcdGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSAtIHRoaXMuem9vbSkgKiB0aGlzLmV4dGVudDtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IChwb3MueCAtIHRoaXMub2Zmc2V0LngpICogc2NhbGUsXHJcblx0XHRcdHk6IChwb3MueSAtIHRoaXMub2Zmc2V0LnkpICogc2NhbGVcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVbnByb2plY3QgYSBjb29yZGluYXRlIGZyb20gdGhlIHBpeGVsIHNwYWNlIG9mIHRoZSBjZWxsIHRvIGEgbm9ybWFsaXplZFxyXG5cdCAqIHBsb3QgY29vcmRpbmF0ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBweCAtIFRoZSBwbG90IHBpeGVsIGNvb3JkaW5hdGUuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBUaGUgem9vbSBvZiB0aGUgcGxvdCBwaXhlbCBzcGFjZSB0byB1bnByb2plY3QgZnJvbS4gT3B0aW9uYWwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbm9ybWFsaXplZCBwbG90IGNvb3JkaW5hdGUuXHJcblx0ICovXHJcblx0dW5wcm9qZWN0KHB4LCB6b29tID0gdGhpcy56b29tKSB7XHJcblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20gLSB0aGlzLnpvb20pICogdGhpcy5leHRlbnQ7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiAocHgueCAvIHNjYWxlKSArIHRoaXMub2Zmc2V0LngsXHJcblx0XHRcdHk6IChweC55IC8gc2NhbGUpICsgdGhpcy5vZmZzZXQueVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlbGw7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xhbXAgPSByZXF1aXJlKCdsb2Rhc2gvY2xhbXAnKTtcbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcbmNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnbG9kYXNoL3Rocm90dGxlJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4uL2V2ZW50L0V2ZW50VHlwZScpO1xuY29uc3QgRXZlbnRCcm9hZGNhc3RlciA9IHJlcXVpcmUoJy4uL2V2ZW50L0V2ZW50QnJvYWRjYXN0ZXInKTtcbmNvbnN0IEV2ZW50RGVsZWdhdG9yID0gcmVxdWlyZSgnLi4vZXZlbnQvRXZlbnREZWxlZ2F0b3InKTtcbmNvbnN0IEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnQvRXZlbnQnKTtcbmNvbnN0IFJlc2l6ZUV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnQvUmVzaXplRXZlbnQnKTtcbmNvbnN0IFJlbmRlckJ1ZmZlciA9IHJlcXVpcmUoJy4uL3dlYmdsL1JlbmRlckJ1ZmZlcicpO1xuY29uc3QgQ2xpY2tIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL0NsaWNrSGFuZGxlcicpO1xuY29uc3QgTW91c2VIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL01vdXNlSGFuZGxlcicpO1xuY29uc3QgUGFuSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9QYW5IYW5kbGVyJyk7XG5jb25zdCBab29tSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9ab29tSGFuZGxlcicpO1xuY29uc3QgQ2VsbCA9IHJlcXVpcmUoJy4vQ2VsbCcpO1xuY29uc3QgVmlld3BvcnQgPSByZXF1aXJlKCcuL1ZpZXdwb3J0Jyk7XG5cbi8vIENvbnN0YW50c1xuXG4vKipcbiAqIFBhbiByZXF1ZXN0IHRocm90dGxlIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgUEFOX1RIUk9UVExFX01TID0gMTAwO1xuXG4vKipcbiAqIFJlc2l6ZSByZXF1ZXN0IHRocm90dGxlIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgUkVTSVpFX1RIUk9UVExFX01TID0gMjAwO1xuXG4vKipcbiAqIFpvb20gcmVxdWVzdCB0aHJvdHRsZSBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IFpPT01fVEhST1RUTEVfTVMgPSA0MDA7XG5cbi8qKlxuICogVGhlIG1heGltdW0gem9vbSBkZWx0YSB1bnRpbCBhIGNlbGwgdXBkYXRlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBDRUxMX1pPT01fREVMVEEgPSAxLjA7XG5cbi8qKlxuICogVGhlIG1heGltdW0gem9vbSBsZXZlbCBzdXBwb3J0ZWQuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1BWF9aT09NID0gMjQ7XG5cbi8qKlxuICogQ2xpY2sgaGFuZGxlciBzeW1ib2wuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtTeW1ib2x9XG4gKi9cbmNvbnN0IENMSUNLID0gU3ltYm9sKCk7XG5cbi8qKlxuICogTW91c2UgaGFuZGxlciBzeW1ib2wuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtTeW1ib2x9XG4gKi9cbmNvbnN0IE1PVVNFID0gU3ltYm9sKCk7XG5cbi8qKlxuICogUGFuIGhhbmRsZXIgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBQQU4gPSBTeW1ib2woKTtcblxuLyoqXG4gKiBab29tIGhhbmRsZXIgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBaT09NID0gU3ltYm9sKCk7XG5cbi8qKlxuICogRXZlbnQgaGFuZGxlcnMgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBIQU5ETEVSUyA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIEV2ZW50IGRlbGVnYXRvcnMgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBERUxFR0FUT1IgPSBTeW1ib2woKTtcblxuLyoqXG4gKiBFdmVudCBicm9hZGNhc3RlcnMgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBCUk9BRENBU1RFUiA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIERpcnR5IHBsb3Qgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBESVJUWSA9IFN5bWJvbCgpO1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxuY29uc3QgcmVxdWVzdFRpbGVzID0gZnVuY3Rpb24oKSB7XG5cdC8vIGdldCBhbGwgdmlzaWJsZSBjb29yZHMgaW4gdGhlIHRhcmdldCB2aWV3cG9ydFxuXHRjb25zdCBjb29yZHMgPSB0aGlzLmdldFRhcmdldFZpc2libGVDb29yZHMoKTtcblx0Ly8gZm9yIGVhY2ggbGF5ZXJcblx0dGhpcy5sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG5cdFx0aWYgKGxheWVyLnJlcXVlc3RUaWxlcykge1xuXHRcdFx0Ly8gcmVxdWVzdCB0aWxlc1xuXHRcdFx0bGF5ZXIucmVxdWVzdFRpbGVzKGNvb3Jkcyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5jb25zdCByZXNpemUgPSBmdW5jdGlvbihwbG90KSB7XG5cdGNvbnN0IGN1cnJlbnQgPSB7XG5cdFx0d2lkdGg6IHBsb3QuY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdGhlaWdodDogcGxvdC5jb250YWluZXIub2Zmc2V0SGVpZ2h0XG5cdH07XG5cdGNvbnN0IHByZXYgPSBwbG90LmdldFZpZXdwb3J0UGl4ZWxTaXplKCk7XG5cdGNvbnN0IGNlbnRlciA9IHBsb3Qudmlld3BvcnQuZ2V0Q2VudGVyKCk7XG5cblx0aWYgKHByZXYud2lkdGggIT09IGN1cnJlbnQud2lkdGggfHxcblx0XHRwcmV2LmhlaWdodCAhPT0gY3VycmVudC5oZWlnaHQgfHxcblx0XHRwbG90LnBpeGVsUmF0aW8gIT09IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG5cdFx0Ly8gc3RvcmUgZGV2aWNlIHBpeGVsIHJhdGlvXG5cdFx0cGxvdC5waXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cdFx0Ly8gcmVzaXplIGNhbnZhc1xuXHRcdHBsb3QuY2FudmFzLnN0eWxlLndpZHRoID0gY3VycmVudC53aWR0aCArICdweCc7XG5cdFx0cGxvdC5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gY3VycmVudC5oZWlnaHQgKyAncHgnO1xuXHRcdHBsb3QuY2FudmFzLndpZHRoID0gY3VycmVudC53aWR0aCAqIHBsb3QucGl4ZWxSYXRpbztcblx0XHRwbG90LmNhbnZhcy5oZWlnaHQgPSBjdXJyZW50LmhlaWdodCAqIHBsb3QucGl4ZWxSYXRpbztcblx0XHQvLyByZXNpemUgcmVuZGVyYnVmZmVyXG5cdFx0cGxvdC5yZW5kZXJCdWZmZXIucmVzaXplKFxuXHRcdFx0Y3VycmVudC53aWR0aCAqIHBsb3QucGl4ZWxSYXRpbyxcblx0XHRcdGN1cnJlbnQuaGVpZ2h0ICogcGxvdC5waXhlbFJhdGlvKTtcblx0XHQvLyB1cGRhdGUgdmlld3BvcnRcblx0XHRjb25zdCBleHRlbnQgPSBwbG90LmdldFBpeGVsRXh0ZW50KCk7XG5cdFx0cGxvdC52aWV3cG9ydC53aWR0aCA9IGN1cnJlbnQud2lkdGggLyBleHRlbnQ7XG5cdFx0cGxvdC52aWV3cG9ydC5oZWlnaHQgPSBjdXJyZW50LmhlaWdodCAvIGV4dGVudDtcblx0XHQvLyByZS1jZW50ZXIgdmlld3BvcnRcblx0XHRwbG90LnZpZXdwb3J0LmNlbnRlck9uKGNlbnRlcik7XG5cdFx0Ly8gcmVxdWVzdCB0aWxlc1xuXHRcdHBsb3QucmVzaXplUmVxdWVzdCgpO1xuXHRcdC8vIGVtaXQgcmVzaXplXG5cdFx0cGxvdC5zZXREaXJ0eSgpO1xuXHRcdHBsb3QuZW1pdChFdmVudFR5cGUuUkVTSVpFLCBuZXcgUmVzaXplRXZlbnQocGxvdCwgcHJldiwgY3VycmVudCkpO1xuXHR9XG59O1xuXG5jb25zdCB1cGRhdGVDZWxsID0gZnVuY3Rpb24ocGxvdCkge1xuXHRjb25zdCB6b29tID0gcGxvdC5nZXRUYXJnZXRab29tKCk7XG5cdGNvbnN0IGNlbnRlciA9IHBsb3QuZ2V0VGFyZ2V0Vmlld3BvcnRDZW50ZXIoKTtcblx0Y29uc3QgZXh0ZW50ID0gcGxvdC5nZXRUYXJnZXRQaXhlbEV4dGVudCgpO1xuXHRjb25zdCBzaXplID0gcGxvdC5nZXRWaWV3cG9ydFBpeGVsU2l6ZSgpO1xuXHRjb25zdCBjZWxsID0gbmV3IENlbGwoem9vbSwgY2VudGVyLCBleHRlbnQpO1xuXHRsZXQgcmVmcmVzaCA9IGZhbHNlO1xuXHQvLyBjaGVjayBpZiBubyBjZWxsIGV4aXN0c1xuXHRpZiAoIXBsb3QuY2VsbCkge1xuXHRcdHJlZnJlc2ggPSB0cnVlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIGNoZWNrIGlmIHdlIGFyZSBvdXRzaWRlIG9mIG9uZSB6b29tIGxldmVsIGZyb20gbGFzdFxuXHRcdGNvbnN0IHpvb21EaXN0ID0gTWF0aC5hYnMocGxvdC5jZWxsLnpvb20gLSBjZWxsLnpvb20pO1xuXHRcdGlmICh6b29tRGlzdCA+PSBDRUxMX1pPT01fREVMVEEpIHtcblx0XHRcdHJlZnJlc2ggPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBjaGVjayBpZiB3ZSBhcmUgd2l0aGluZyBidWZmZXIgZGlzdGFuY2Ugb2YgdGhlIGNlbGwgYm91bmRzXG5cdFx0XHRjb25zdCB4RGlzdCA9IHBsb3QuY2VsbC5oYWxmU2l6ZSAtIChzaXplLndpZHRoIC8gcGxvdC5jZWxsLmV4dGVudCk7XG5cdFx0XHRjb25zdCB5RGlzdCA9IHBsb3QuY2VsbC5oYWxmU2l6ZSAtIChzaXplLmhlaWdodCAvIHBsb3QuY2VsbC5leHRlbnQpO1xuXHRcdFx0aWYgKE1hdGguYWJzKGNlbGwuY2VudGVyLnggLSBwbG90LmNlbGwuY2VudGVyLngpID4geERpc3QgfHxcblx0XHRcdFx0TWF0aC5hYnMoY2VsbC5jZW50ZXIueSAtIHBsb3QuY2VsbC5jZW50ZXIueSkgPiB5RGlzdCkge1xuXHRcdFx0XHRyZWZyZXNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYgKHJlZnJlc2gpIHtcblx0XHQvLyB1cGRhdGUgY2VsbFxuXHRcdHBsb3QuY2VsbCA9IGNlbGw7XG5cdFx0Ly8gZW1pdCBjZWxsIHJlZnJlc2hcblx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLkNFTExfVVBEQVRFLCBuZXcgRXZlbnQoY2VsbCkpO1xuXHR9XG59O1xuXG5jb25zdCByZXNldCA9IGZ1bmN0aW9uKHBsb3QpIHtcblx0aWYgKCFwbG90LndyYXBhcm91bmQpIHtcblx0XHQvLyBpZiB0aGVyZSBpcyBubyB3cmFwYXJvdW5kLCBkbyBub3QgcmVzZXRcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyByZXNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydCByZWxhdGl2ZSB0byB0aGUgcGxvdCBzdWNoIHRoYXRcblx0Ly8gdGhlIHBsb3QgbmF0aXZlIGNvb3JkaW5hdGUgcmFuZ2UgaXMgd2l0aGluIHRoZSB2aWV3cG9ydHMgYm91bmRzLlxuXG5cdC8vIGdldCB2aWV3cG9ydCB3aWR0aCBpbiBwbG90IGNvb3Jkc1xuXHRjb25zdCB3aWR0aCA9IE1hdGguY2VpbChwbG90LnZpZXdwb3J0LndpZHRoIC8gMS4wKTtcblxuXHQvLyBwYXN0IHRoZSBsZWZ0IGJvdW5kIG9mIHRoZSB2aWV3cG9ydFxuXHRpZiAocGxvdC52aWV3cG9ydC54ID4gMS4wKSB7XG5cdFx0cGxvdC52aWV3cG9ydC54IC09IHdpZHRoO1xuXHRcdGlmIChwbG90LmlzUGFubmluZygpKSB7XG5cdFx0XHRwbG90LnBhbkFuaW1hdGlvbi5zdGFydC54IC09IHdpZHRoO1xuXHRcdH1cblx0fVxuXHQvLyBwYXN0IHRoZSByaWdodCBib3VuZCBvZiB0aGUgdmlld3BvcnRcblx0aWYgKHBsb3Qudmlld3BvcnQueCArIHBsb3Qudmlld3BvcnQud2lkdGggPCAwKSB7XG5cdFx0cGxvdC52aWV3cG9ydC54ICs9IHdpZHRoO1xuXHRcdGlmIChwbG90LmlzUGFubmluZygpKSB7XG5cdFx0XHRwbG90LnBhbkFuaW1hdGlvbi5zdGFydC54ICs9IHdpZHRoO1xuXHRcdH1cblx0fVxufTtcblxuY29uc3QgZnJhbWUgPSBmdW5jdGlvbihwbG90KSB7XG5cblx0Ly8gZ2V0IGZyYW1lIHRpbWVzdGFtcFxuXHRjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG5cdC8vIGVtaXQgZnJhbWUgZXZlbnRcblx0cGxvdC5lbWl0KEV2ZW50VHlwZS5GUkFNRSwgbmV3IEV2ZW50KHBsb3QsIHRpbWVzdGFtcCkpO1xuXG5cdC8vIHVwZGF0ZSBzaXplXG5cdHJlc2l6ZShwbG90KTtcblxuXHRpZiAoIXBsb3QuZGlydHlDaGVja2luZyB8fCBwbG90LmlzRGlydHkoKSkge1xuXG5cdFx0Ly8gY2xlYXIgZmxhZyBub3csIHRoaXMgd2F5IGxheWVycyB0aGF0IG1heSBiZSBhbmltYXRpbmcgY2FuIHNpZ25hbFxuXHRcdC8vIHRoYXQgdGhlIGFuaW1hdGlvbiBpcyBub3QgY29tcGxldGUgYnkgZmxhZ2dpbmcgYXMgZGlydHkgZHVyaW5nIHRoZVxuXHRcdC8vIGRyYXcgY2FsbC5cblx0XHRwbG90LmNsZWFyRGlydHkoKTtcblxuXHRcdC8vIGFwcGx5IHRoZSB6b29tIGFuaW1hdGlvblxuXHRcdGlmIChwbG90LmlzWm9vbWluZygpKSB7XG5cdFx0XHRpZiAocGxvdC56b29tQW5pbWF0aW9uLnVwZGF0ZSh0aW1lc3RhbXApKSB7XG5cdFx0XHRcdHBsb3Quem9vbUFuaW1hdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYXBwbHkgdGhlIHBhbiBhbmltYXRpb25cblx0XHRpZiAocGxvdC5pc1Bhbm5pbmcoKSkge1xuXHRcdFx0aWYgKHBsb3QucGFuQW5pbWF0aW9uLnVwZGF0ZSh0aW1lc3RhbXApKSB7XG5cdFx0XHRcdHBsb3QucGFuQW5pbWF0aW9uID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBsb3QucGFuUmVxdWVzdCgpO1xuXHRcdH1cblxuXHRcdC8vIHJlc2V0IHZpZXdwb3J0IC8gcGxvdFxuXHRcdHJlc2V0KHBsb3QpO1xuXG5cdFx0Ly8gdXBkYXRlIGNlbGxcblx0XHR1cGRhdGVDZWxsKHBsb3QpO1xuXG5cdFx0Ly8gZ2V0IGNvbnRleHRcblx0XHRjb25zdCBnbCA9IHBsb3QuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xuXG5cdFx0Ly8gY2xlYXIgdGhlIGJhY2tidWZmZXJcblx0XHRnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuXHRcdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXG5cdFx0Ly8gc2V0IHRoZSB2aWV3cG9ydFxuXHRcdGNvbnN0IHNpemUgPSBwbG90LmdldFZpZXdwb3J0UGl4ZWxTaXplKCk7XG5cdFx0Z2wudmlld3BvcnQoXG5cdFx0XHQwLCAwLFxuXHRcdFx0c2l6ZS53aWR0aCAqIHBsb3QucGl4ZWxSYXRpbyxcblx0XHRcdHNpemUuaGVpZ2h0ICogcGxvdC5waXhlbFJhdGlvKTtcblxuXHRcdC8vIHNvcnQgbGF5ZXJzIGJ5IHotaW5kZXhcblx0XHRjb25zdCBsYXllcnMgPSBwbG90LmdldFNvcnRlZExheWVycygpO1xuXG5cdFx0Ly8gcmVuZGVyIGVhY2ggbGF5ZXJcblx0XHRsYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG5cdFx0XHRpZiAoIWxheWVyLmlzSGlkZGVuKCkpIHtcblx0XHRcdFx0bGF5ZXIuZHJhdyh0aW1lc3RhbXApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gcmVxdWVzdCBuZXh0IGZyYW1lXG5cdHBsb3QuZnJhbWVSZXF1ZXN0ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcblx0XHRmcmFtZShwbG90KTtcblx0fSk7XG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHBsb3QuXG4gKi9cbmNsYXNzIFBsb3QgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUGxvdCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIFRoZSBzZWxlY3RvciBmb3IgdGhlIGNvbnRhaW5lciBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbG90IG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbGVTaXplIC0gVGhlIGRpbWVuc2lvbiBpbiBwaXhlbHMgb2YgYSB0aWxlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy56b29tIC0gVGhlIHpvb20gb2YgdGhlIHBsb3QuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1pblpvb20gLSBUaGUgbWluaW11bSB6b29tIG9mIHRoZSBwbG90LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXhab29tIC0gVGhlIG1heGltdW0gem9vbSBvZiB0aGUgcGxvdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuY2VudGVyIC0gVGhlIGNlbnRlciBvZiB0aGUgcGxvdCwgaW4gcGxvdCBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy53cmFwYXJvdW5kIC0gV2hldGhlciBvciBub3QgdGhlIHBsb3Qgd3JhcHMgYXJvdW5kLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY29udGV4dCAtIFRoZSByZW5kZXJpbmcgY29udGV4dCB0eXBlLCBkZWZhdWx0cyB0byBgd2ViZ2xgLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY29udGV4dEF0dHJpYnV0ZXMgLSBUaGUgcmVuZGVyaW5nIGNvbnRleHQgYXR0cmlidHVlcyBhcmd1bWVudC4gT3B0aW9uYWwuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5kaXJ0eUNoZWNraW5nIC0gV2hldGhlciBvciBub3QgdGhlIHBsb3QgdXNlcyBkaXJ0eSBjaGVja2luZyBvciByZW5kZXJzIGV2ZXJ5IGZyYW1lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5wYW5UaHJvdHRsZSAtIFBhbiByZXF1ZXN0IHRocm90dGxlIHRpbWVvdXQgaW4gbXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnJlc2l6ZVRocm90dGxlIC0gUmVzaXplIHJlcXVlc3QgdGhyb3R0bGUgdGltZW91dCBpbiBtcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuem9vbVRocm90dGxlIC0gWm9vbSByZXF1ZXN0IHRocm90dGxlIHRpbWVvdXQgaW4gbXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmluZXJ0aWEgLSBXaGV0aGVyIG9yIG5vdCBwYW4gaW5lcnRpYSBpcyBlbmFibGVkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5pbmVydGlhRWFzaW5nIC0gVGhlIGluZXJ0aWEgZWFzaW5nIGZhY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAtIFRoZSBpbmVydGlhIGRlY2VsZXJhdGlvbiBmYWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNvbnRpbnVvdXNab29tIC0gV2hldGhlciBvciBub3QgY29udGludW91cyB6b29tIGlzIGVuYWJsZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpvb21EdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgem9vbSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heENvbmN1cnJlbnRab29tcyAtIFRoZSBtYXhpbXVtIGNvbmN1cnJlbnQgem9vbXMgaW4gYSBzaW5nbGUgYmF0Y2guXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmRlbHRhUGVyWm9vbSAtIFRoZSBzY3JvbGwgZGVsdGEgcmVxdWlyZWQgcGVyIHpvb20gbGV2ZWwuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpvb21EZWJvdW5jZSAtIFRoZSBkZWJvdW5jZSBkdXJhdGlvbiBvZiB0aGUgem9vbSBpbiBtcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cdFx0aWYgKCF0aGlzLmNvbnRhaW5lcikge1xuXHRcdFx0dGhyb3cgYEVsZW1lbnQgY291bGQgbm90IGJlIGZvdW5kIGZvciBzZWxlY3RvciAke3NlbGVjdG9yfWA7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHBpeGVsIHJhdGlvXG5cdFx0dGhpcy5waXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cblx0XHQvLyBjcmVhdGUgY2FudmFzIGVsZW1lbnRcblx0XHR0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gYCR7dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGh9cHhgO1xuXHRcdHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodH1weGA7XG5cdFx0dGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcblx0XHR0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG5cdFx0dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG5cdFx0Ly8gZ2V0IHJlbmRlcmluZyBjb250ZXh0XG5cdFx0dGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMuY29udGV4dEF0dHJpYnV0ZXMpIHx8XG5cdFx0XHR0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zLmNvbnRleHRBdHRyaWJ1dGVzKTsgLy8gTVMgRWRnZVxuXHRcdGlmICghdGhpcy5jdHgpIHtcblx0XHRcdHRocm93ICdVbmFibGUgdG8gY3JlYXRlIGEgV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBwbGVhc2UgZW5zdXJlIHlvdXIgYnJvd3NlciBzdXBwb3J0cyBXZWJHTCc7XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIHJlbmRlcmJ1ZmZlclxuXHRcdHRoaXMucmVuZGVyQnVmZmVyID0gbmV3IFJlbmRlckJ1ZmZlcihcblx0XHRcdHRoaXMuY3R4LFxuXHRcdFx0dGhpcy5jYW52YXMud2lkdGgsXG5cdFx0XHR0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0Ly8gdGlsZSBzaXplIGluIHBpeGVsc1xuXHRcdHRoaXMudGlsZVNpemUgPSBkZWZhdWx0VG8ob3B0aW9ucy50aWxlU2l6ZSwgMjU2KTtcblxuXHRcdC8vIG1pbiBhbmQgbWF4IHpvb20gb2YgdGhlIHBsb3Rcblx0XHR0aGlzLm1pblpvb20gPSBkZWZhdWx0VG8ob3B0aW9ucy5taW5ab29tLCAwKTtcblx0XHR0aGlzLm1heFpvb20gPSBkZWZhdWx0VG8ob3B0aW9ucy5tYXhab29tLCBNQVhfWk9PTSk7XG5cblx0XHQvLyBjdXJyZW50IHpvb20gb2YgdGhlIHBsb3Rcblx0XHR0aGlzLnpvb20gPSBkZWZhdWx0VG8ob3B0aW9ucy56b29tLCAwKTtcblx0XHR0aGlzLnpvb20gPSBjbGFtcCh0aGlzLnpvb20sIHRoaXMubWluWm9vbSwgdGhpcy5tYXhab29tKTtcblxuXHRcdC8vIHNldCB2aWV3cG9ydFxuXHRcdGNvbnN0IHNwYW4gPSBNYXRoLnBvdygyLCB0aGlzLnpvb20pO1xuXHRcdGNvbnN0IHdpZHRoID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGggLyBzcGFuO1xuXHRcdGNvbnN0IGhlaWdodCA9IHRoaXMuY2FudmFzLm9mZnNldEhlaWdodCAvIHNwYW47XG5cdFx0dGhpcy52aWV3cG9ydCA9IG5ldyBWaWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuXHRcdC8vIGNlbnRlciB0aGUgcGxvdFxuXHRcdGNvbnN0IGNlbnRlciA9IGRlZmF1bHRUbyhvcHRpb25zLmNlbnRlciwgeyB4OiAwLjUsIHk6IDAuNSB9KTtcblx0XHR0aGlzLnZpZXdwb3J0LmNlbnRlck9uKGNlbnRlcik7XG5cblx0XHQvLyBnZW5lcmF0ZSBjZWxsXG5cdFx0dGhpcy5jZWxsID0gbnVsbDtcblx0XHR1cGRhdGVDZWxsKHRoaXMpO1xuXG5cdFx0Ly8gd3JhcGFyb3VuZFxuXHRcdHRoaXMud3JhcGFyb3VuZCA9IGRlZmF1bHRUbyhvcHRpb25zLndyYXBhcm91bmQsIGZhbHNlKTtcblxuXHRcdC8vIHRocm90dGxlZCByZXF1ZXN0IG1ldGhvZHNcblx0XHRjb25zdCBwYW5UaHJvdHRsZSA9IGRlZmF1bHRUbyhvcHRpb25zLnBhblRocm90dGxlLCBQQU5fVEhST1RUTEVfTVMpO1xuXHRcdGNvbnN0IHJlc2l6ZVRocm90dGxlID0gZGVmYXVsdFRvKG9wdGlvbnMucmVzaXplVGhyb3R0bGUsIFJFU0laRV9USFJPVFRMRV9NUyk7XG5cdFx0Y29uc3Qgem9vbVRocm90dGxlID0gZGVmYXVsdFRvKG9wdGlvbnMuem9vbVRocm90dGxlLCBaT09NX1RIUk9UVExFX01TKTtcblx0XHR0aGlzLnBhblJlcXVlc3QgPSB0aHJvdHRsZShyZXF1ZXN0VGlsZXMsIHBhblRocm90dGxlLCB7XG5cdFx0XHRsZWFkaW5nOiBmYWxzZSAvLyBpbnZva2Ugb25seSBvbiB0cmFpbGluZyBlZGdlXG5cdFx0fSk7XG5cdFx0dGhpcy5yZXNpemVSZXF1ZXN0ID0gdGhyb3R0bGUocmVxdWVzdFRpbGVzLCByZXNpemVUaHJvdHRsZSwge1xuXHRcdFx0bGVhZGluZzogZmFsc2UgLy8gaW52b2tlIG9ubHkgb24gdHJhaWxpbmcgZWRnZVxuXHRcdH0pO1xuXHRcdHRoaXMuem9vbVJlcXVlc3QgPSB0aHJvdHRsZShyZXF1ZXN0VGlsZXMsIHpvb21UaHJvdHRsZSwge1xuXHRcdFx0bGVhZGluZzogZmFsc2UgLy8gaW52b2tlIG9ubHkgb24gdHJhaWxpbmcgZWRnZVxuXHRcdH0pO1xuXG5cdFx0Ly8gbGF5ZXJzXG5cdFx0dGhpcy5sYXllcnMgPSBbXTtcblxuXHRcdC8vIGZyYW1lIHJlcXVlc3Rcblx0XHR0aGlzLmZyYW1lUmVxdWVzdCA9IG51bGw7XG5cblx0XHQvLyBjcmVhdGUgYW5kIGVuYWJsZSBoYW5kbGVyc1xuXHRcdHRoaXNbSEFORExFUlNdID0gbmV3IE1hcCgpO1xuXHRcdHRoaXNbSEFORExFUlNdLnNldChDTElDSywgbmV3IENsaWNrSGFuZGxlcih0aGlzLCBvcHRpb25zKSk7XG5cdFx0dGhpc1tIQU5ETEVSU10uc2V0KE1PVVNFLCBuZXcgTW91c2VIYW5kbGVyKHRoaXMsIG9wdGlvbnMpKTtcblx0XHR0aGlzW0hBTkRMRVJTXS5zZXQoUEFOLCBuZXcgUGFuSGFuZGxlcih0aGlzLCBvcHRpb25zKSk7XG5cdFx0dGhpc1tIQU5ETEVSU10uc2V0KFpPT00sIG5ldyBab29tSGFuZGxlcih0aGlzLCBvcHRpb25zKSk7XG5cdFx0dGhpc1tIQU5ETEVSU10uZm9yRWFjaChoYW5kbGVyID0+IHtcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XG5cdFx0fSk7XG5cblx0XHQvLyBkZWxlZ2F0b3Jcblx0XHR0aGlzW0RFTEVHQVRPUl0gPSBuZXcgRXZlbnREZWxlZ2F0b3IodGhpcyk7XG5cdFx0Ly8gZGVsZWdhdGUgbW91c2UgLyBjbGljayBldmVudHMgdG8gbGF5ZXJzXG5cdFx0dGhpc1tERUxFR0FUT1JdLmRlbGVnYXRlKEV2ZW50VHlwZS5DTElDSyk7XG5cdFx0dGhpc1tERUxFR0FUT1JdLmRlbGVnYXRlKEV2ZW50VHlwZS5EQkxfQ0xJQ0spO1xuXHRcdHRoaXNbREVMRUdBVE9SXS5kZWxlZ2F0ZShFdmVudFR5cGUuTU9VU0VfTU9WRSk7XG5cdFx0dGhpc1tERUxFR0FUT1JdLmRlbGVnYXRlKEV2ZW50VHlwZS5NT1VTRV9VUCk7XG5cdFx0dGhpc1tERUxFR0FUT1JdLmRlbGVnYXRlKEV2ZW50VHlwZS5NT1VTRV9ET1dOKTtcblxuXHRcdC8vIGJyb2FkY2FzdGVyXG5cdFx0dGhpc1tCUk9BRENBU1RFUl0gPSBuZXcgRXZlbnRCcm9hZGNhc3Rlcih0aGlzKTtcblx0XHQvLyBicm9hZGNhc3Qgem9vbSAvIHBhbiBldmVudHMgdG8gbGF5ZXJzXG5cdFx0dGhpc1tCUk9BRENBU1RFUl0uYnJvYWRjYXN0KEV2ZW50VHlwZS5aT09NX1NUQVJUKTtcblx0XHR0aGlzW0JST0FEQ0FTVEVSXS5icm9hZGNhc3QoRXZlbnRUeXBlLlpPT00pO1xuXHRcdHRoaXNbQlJPQURDQVNURVJdLmJyb2FkY2FzdChFdmVudFR5cGUuWk9PTV9FTkQpO1xuXHRcdHRoaXNbQlJPQURDQVNURVJdLmJyb2FkY2FzdChFdmVudFR5cGUuUEFOX1NUQVJUKTtcblx0XHR0aGlzW0JST0FEQ0FTVEVSXS5icm9hZGNhc3QoRXZlbnRUeXBlLlBBTik7XG5cdFx0dGhpc1tCUk9BRENBU1RFUl0uYnJvYWRjYXN0KEV2ZW50VHlwZS5QQU5fRU5EKTtcblxuXHRcdC8vIHdoZXRoZXIgb3Igbm90IHRvIHVzZSBkaXJ0eSBjaGVja2luZ1xuXHRcdHRoaXMuZGlydHlDaGVja2luZyA9IGRlZmF1bHRUbyhvcHRpb25zLmRpcnR5Q2hlY2tpbmcsIHRydWUpO1xuXG5cdFx0Ly8gZmxhZyBhcyBkaXJ0eVxuXHRcdHRoaXNbRElSVFldID0gdHJ1ZTtcblxuXHRcdC8vIGJlZ2luIGZyYW1lIGxvb3Bcblx0XHRmcmFtZSh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcGxvdHMgYXNzb2NpYXRpb24gd2l0aCB0aGUgdW5kZXJseWluZyBjYW52YXMgZWxlbWVudCBhbmRcblx0ICogZGlzYWJsZXMgYWxsIGV2ZW50IGhhbmRsZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UGxvdH0gVGhlIHBsb3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdC8vIHN0b3AgYW5pbWF0aW9uIGxvb3Bcblx0XHRjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lUmVxdWVzdCk7XG5cdFx0dGhpcy5mcmFtZVJlcXVlc3QgPSBudWxsO1xuXHRcdC8vIGRpc2FibGUgaGFuZGxlcnNcblx0XHR0aGlzW0hBTkRMRVJTXS5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuXHRcdFx0aGFuZGxlci5kaXNhYmxlKCk7XG5cdFx0fSk7XG5cdFx0Ly8gcmVtb3ZlIGxheWVyc1xuXHRcdHRoaXMubGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuXHRcdFx0dGhpcy5yZW1vdmUobGF5ZXIpO1xuXHRcdH0pO1xuXHRcdC8vIGRlc3Ryb3kgY29udGV4dFxuXHRcdHRoaXMuY3R4ID0gbnVsbDtcblx0XHQvLyByZW1vdmUgY2FudmFzXG5cdFx0dGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuXHRcdHRoaXMuY2FudmFzID0gbnVsbDtcblx0XHR0aGlzLmNvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5yZW5kZXJCdWZmZXIgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsYWdzIHRoZSBwbG90IGFzIGRpcnR5IHNpbmdhbGxpbmcgdGhhdCBpdCBzaG91bGQgYmUgcmVkcmF3biBpbiB0aGUgbmV4dFxuXHQgKiBmcmFtZS5cblx0ICovXG5cdHNldERpcnR5KCkge1xuXHRcdHRoaXNbRElSVFldID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgcGxvdCBpcyBkaXJ0eSBhbmQgcmVxdWlyZXMgYSByZWRyYXcuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcGxvdCBzaG91bGQgYmUgcmVkcmF3bi5cbiBcdCovXG5cdGlzRGlydHkoKSB7XG5cdFx0cmV0dXJuIHRoaXNbRElSVFldIHx8IHRoaXMuaXNQYW5uaW5nKCkgfHwgdGhpcy5pc1pvb21pbmcoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGRpcnR5IGZsYWcgZm9yIHRoZSBuZXh0IGZyYW1lLlxuXHQgKi9cblx0Y2xlYXJEaXJ0eSgpIHtcblx0XHR0aGlzW0RJUlRZXSA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBsYXllciB0byB0aGUgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYWRkIHRvIHRoZSBwbG90LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UGxvdH0gVGhlIHBsb3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRhZGQobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyKSB7XG5cdFx0XHR0aHJvdyAnTm8gYXJndW1lbnQgcHJvdmlkZWQnO1xuXHRcdH1cblx0XHRpZiAodGhpcy5sYXllcnMuaW5kZXhPZihsYXllcikgIT09IC0xKSB7XG5cdFx0XHR0aHJvdyAnUHJvdmlkZWQgbGF5ZXIgaXMgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgcGxvdCc7XG5cdFx0fVxuXHRcdHRoaXMubGF5ZXJzLnB1c2gobGF5ZXIpO1xuXHRcdGxheWVyLm9uQWRkKHRoaXMpO1xuXHRcdHRoaXMuc2V0RGlydHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGEgbGF5ZXIgZnJvbSB0aGUgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gcmVtb3ZlIGZyb20gdGhlIHBsb3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQbG90fSBUaGUgcGxvdCBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHJlbW92ZShsYXllcikge1xuXHRcdGlmICghbGF5ZXIpIHtcblx0XHRcdHRocm93ICdObyBhcmd1bWVudCBwcm92aWRlZCc7XG5cdFx0fVxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5sYXllcnMuaW5kZXhPZihsYXllcik7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0dGhyb3cgJ1Byb3ZpZGVkIGxheWVyIGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgcGxvdCc7XG5cdFx0fVxuXHRcdHRoaXMubGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0dGhpcy5zZXREaXJ0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJlbmRlcmluZyBjb250ZXh0IG9mIHRoZSBwbG90LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGNvbnRleHQgb2JqZWN0LlxuXHQgKi9cblx0Z2V0UmVuZGVyaW5nQ29udGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jdHg7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgdGhlIGxheWVyIG9iamVjdHMgYXR0YWNoZWQgdG8gdGhlIHBsb3QsIGluIGRlc2NlbmRpbmdcblx0ICogb3JkZXIgb2Ygei1pbmRleC5cblx0ICovXG5cdGdldFNvcnRlZExheWVycygpIHtcblx0XHQvLyBzb3J0IGJ5IHotaW5kZXhcblx0XHRyZXR1cm4gdGhpcy5sYXllcnMuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0cmV0dXJuIGEuZ2V0WkluZGV4KCkgLSBiLmdldFpJbmRleCgpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gb2YgdGhlIHBsb3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjdXJyZW50IHpvb20gb2YgdGhlIHBsb3QuXG5cdCAqL1xuXHRnZXRab29tKCkge1xuXHRcdHJldHVybiB0aGlzLnpvb207XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdGFyZ2V0IHpvb20gb2YgdGhlIHBsb3QuIElmIHRoZSBwbG90IGlzIGFjdGl2ZWx5IHpvb21pbmcsIGl0XG5cdCAqIHdpbGwgcmV0dXJuIHRoZSBkZXN0aW5hdGlvbiB6b29tLiBJZiB0aGUgcGxvdCBpcyBub3QgYWN0aXZlbHkgem9vbWluZywgaXRcblx0ICogd2lsbCByZXR1cm4gdGhlIGN1cnJlbnQgem9vbS5cblx0ICpcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHRhcmdldCB6b29tIG9mIHRoZSBwbG90LlxuXHQgKi9cblx0Z2V0VGFyZ2V0Wm9vbSgpIHtcblx0XHRpZiAodGhpcy5pc1pvb21pbmcoKSkge1xuXHRcdFx0Ly8gaWYgem9vbWluZywgdXNlIHRoZSB0YXJnZXQgbGV2ZWxcblx0XHRcdHJldHVybiB0aGlzLnpvb21BbmltYXRpb24udGFyZ2V0Wm9vbTtcblx0XHR9XG5cdFx0Ly8gaWYgbm90IHpvb21pbmcsIHVzZSB0aGUgY3VycmVudCBsZXZlbFxuXHRcdHJldHVybiB0aGlzLnpvb207XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCB2aWV3cG9ydCBvZiB0aGUgcGxvdC5cblx0ICpcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGN1cnJlbnQgdmlld3BvcnQgb2YgdGhlIHBsb3QuXG5cdCAqL1xuXHRnZXRWaWV3cG9ydCgpIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3cG9ydDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0YXJnZXQgdmlld3BvcnQgb2YgdGhlIHBsb3QuIElmIHRoZSBwbG90IGlzIGFjdGl2ZWx5IHpvb21pbmcsXG5cdCAqIGl0IHdpbGwgcmV0dXJuIHRoZSB0YXJnZXQgdmlld3BvcnQuIElmIHRoZSBwbG90IGlzIG5vdCBhY3RpdmVseSB6b29taW5nLFxuXHQgKiBpdCB3aWxsIHJldHVybiB0aGUgY3VycmVudCB2aWV3cG9ydC5cblx0ICpcblx0ICogQHJldHVybnMge1ZpZXdwb3J0fSBUaGUgdGFyZ2V0IHZpZXdwb3J0IG9mIHRoZSBwbG90LlxuXHQgKi9cblx0Z2V0VGFyZ2V0Vmlld3BvcnQoKSB7XG5cdFx0aWYgKHRoaXMuaXNab29taW5nKCkpIHtcblx0XHRcdC8vIGlmIHpvb21pbmcsIHVzZSB0aGUgdGFyZ2V0IHZpZXdwb3J0XG5cdFx0XHRyZXR1cm4gdGhpcy56b29tQW5pbWF0aW9uLnRhcmdldFZpZXdwb3J0O1xuXHRcdH1cblx0XHQvLyBpZiBub3Qgem9vbWluZywgdXNlIHRoZSBjdXJyZW50IHZpZXdwb3J0XG5cdFx0cmV0dXJuIHRoaXMudmlld3BvcnQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCBjZW50ZXIgaW4gcGxvdCBjb29yZGluYXRlcy5cblx0ICovXG5cdGdldFZpZXdwb3J0UG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0UG9zaXRpb24oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0YXJnZXQgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRoZSB2aWV3cG9ydC4gSWYgdGhlIHBsb3QgaXMgYWN0aXZlbHkgem9vbWluZ1xuXHQgKiBvciBwYW5uaW5nLCBpdCB3aWxsIHJldHVybiB0aGUgZGVzdGluYXRpb24gY2VudGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdGFyZ2V0IGNlbnRlciBpbiBwbG90IGNvb3JkaW5hdGVzLlxuXHQgKi9cblx0Z2V0VGFyZ2V0Vmlld3BvcnRQb3NpdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRUYXJnZXRWaWV3cG9ydCgpLmdldFBvc2l0aW9uKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCBjZW50ZXIgaW4gcGxvdCBjb29yZGluYXRlcy5cblx0ICovXG5cdGdldFZpZXdwb3J0Q2VudGVyKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRhcmdldCBjZW50ZXIgb2YgdGhlIHBsb3QgaW4gcGxvdCBjb29yZGluYXRlcy4gSWYgdGhlIHBsb3QgaXNcblx0ICogYWN0aXZlbHkgem9vbWluZyBvciBwYW5uaW5nLCBpdCB3aWxsIHJldHVybiB0aGUgZGVzdGluYXRpb24gY2VudGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdGFyZ2V0IGNlbnRlciBpbiBwbG90IGNvb3JkaW5hdGVzLlxuXHQgKi9cblx0Z2V0VGFyZ2V0Vmlld3BvcnRDZW50ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFyZ2V0Vmlld3BvcnQoKS5nZXRDZW50ZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0aWxlIGNvb3JkaW5hdGVzIHZpc2libGUgaW4gdGhlIHRhcmdldCB2aWV3cG9ydC5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgdmlzaWJsZSB0aWxlIGNvb3Jkcy5cblx0ICovXG5cdGdldFRhcmdldFZpc2libGVDb29yZHMoKSB7XG5cdFx0Y29uc3QgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHRoaXMuZ2V0VGFyZ2V0Wm9vbSgpKTsgLy8gdXNlIHRhcmdldCB6b29tXG5cdFx0Y29uc3Qgdmlld3BvcnQgPSB0aGlzLmdldFRhcmdldFZpZXdwb3J0KCk7IC8vIHVzZSB0YXJnZXQgdmlld3BvcnRcblx0XHRyZXR1cm4gdmlld3BvcnQuZ2V0VmlzaWJsZUNvb3Jkcyh0aWxlWm9vbSwgdGhpcy53cmFwYXJvdW5kKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0aWxlIGNvb3JkaW5hdGVzIGN1cnJlbnRseSB2aXNpYmxlIGluIHRoZSBjdXJyZW50IHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiB2aXNpYmxlIHRpbGUgY29vcmRzLlxuXHQgKi9cblx0Z2V0VmlzaWJsZUNvb3JkcygpIHtcblx0XHRjb25zdCB0aWxlWm9vbSA9IE1hdGgucm91bmQodGhpcy56b29tKTsgLy8gdXNlIGN1cnJlbnQgem9vbVxuXHRcdGNvbnN0IHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydDsgLy8gdXNlIGN1cnJlbnQgdmlld3BvcnRcblx0XHRyZXR1cm4gdmlld3BvcnQuZ2V0VmlzaWJsZUNvb3Jkcyh0aWxlWm9vbSwgdGhpcy53cmFwYXJvdW5kKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwbG90IHNpemUgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGxvdCBzaXplIGluIHBpeGVscy5cblx0ICovXG5cdGdldFBpeGVsRXh0ZW50KCkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCB0aGlzLnpvb20pICogdGhpcy50aWxlU2l6ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0YXJnZXQgcGxvdCBzaXplIGluIHBpeGVscy5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHRhcmdldCBwbG90IHNpemUgaW4gcGl4ZWxzLlxuXHQgKi9cblx0Z2V0VGFyZ2V0UGl4ZWxFeHRlbnQoKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHRoaXMuZ2V0VGFyZ2V0Wm9vbSgpKSAqIHRoaXMudGlsZVNpemU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmlld3BvcnQgc2l6ZSBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB2aWV3cG9ydCBzaXplIGluIHBpeGVscy5cblx0ICovXG5cdGdldFZpZXdwb3J0UGl4ZWxTaXplKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXdwb3J0LmdldFBpeGVsU2l6ZSh0aGlzLnpvb20sIHRoaXMudGlsZVNpemUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRhcmdldCB2aWV3cG9ydCBzaXplIGluIHBpeGVscy5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHRhcmdldCB2aWV3cG9ydCBzaXplIGluIHBpeGVscy5cblx0ICovXG5cdGdldFRhcmdldFZpZXdwb3J0UGl4ZWxTaXplKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFRhcmdldFZpZXdwb3J0KCkuZ2V0UGl4ZWxTaXplKHRoaXMuem9vbSwgdGhpcy50aWxlU2l6ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmlld3BvcnQgb2Zmc2V0IGluIHBpeGVscy5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHZpZXdwb3J0IG9mZnNldCBpbiBwaXhlbHMuXG5cdCAqL1xuXHRnZXRWaWV3cG9ydFBpeGVsT2Zmc2V0KCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXdwb3J0LmdldFBpeGVsT2Zmc2V0KHRoaXMuem9vbSwgdGhpcy50aWxlU2l6ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdGFyZ2V0IHZpZXdwb3J0IG9mZnNldCBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB0YXJnZXQgdmlld3BvcnQgb2Zmc2V0IGluIHBpeGVscy5cblx0ICovXG5cdGdldFRhcmdldFZpZXdwb3J0UGl4ZWxPZmZzZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFyZ2V0Vmlld3BvcnQoKS5nZXRQaXhlbE9mZnNldCh0aGlzLnpvb20sIHRoaXMudGlsZVNpemUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgRE9NIGV2ZW50IGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBsb3QgcG9zaXRpb24uXG5cdCAqIENvb3JkaW5hdGUgWzAsIDBdIGlzIGJvdHRvbS1sZWZ0IG9mIHRoZSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBtb3VzZSBldmVudC5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHBsb3QgcG9zaXRpb24uXG5cdCAqL1xuXHRtb3VzZVRvUGxvdENvb3JkKGV2ZW50KSB7XG5cdFx0Y29uc3QgZXh0ZW50ID0gdGhpcy5nZXRQaXhlbEV4dGVudCgpO1xuXHRcdGNvbnN0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0UGl4ZWxTaXplKCk7XG5cdFx0Y29uc3QgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcblx0XHRjb25zdCBib3VuZHMgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0Y29uc3QgeCA9IGV2ZW50LnBhZ2VYIC0gYm91bmRzLmxlZnQ7XG5cdFx0Y29uc3QgeSA9IGV2ZW50LnBhZ2VZIC0gYm91bmRzLnRvcDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdGhpcy52aWV3cG9ydC54ICsgKHggLyBleHRlbnQpLFxuXHRcdFx0eTogdGhpcy52aWV3cG9ydC55ICsgKChzaXplLmhlaWdodCAtIHkpIC8gZXh0ZW50KVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogVGFrZXMgYSBET00gZXZlbnQgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgdmlld3BvcnQgcGl4ZWwgcG9zaXRpb24uXG5cdCAqIENvb3JkaW5hdGUgWzAsIDBdIGlzIGJvdHRvbS1sZWZ0IG9mIHRoZSB2aWV3cG9ydC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB2aWV3cG9ydCBwaXhlbCBjb29yZGluYXRlLlxuXHQgKi9cblx0bW91c2VUb1ZpZXdwb3J0UGl4ZWwoZXZlbnQpIHtcblx0XHRjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFBpeGVsU2l6ZSgpO1xuXHRcdGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG5cdFx0Y29uc3QgYm91bmRzID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IHggPSBldmVudC5wYWdlWCAtIGJvdW5kcy5sZWZ0O1xuXHRcdGNvbnN0IHkgPSBldmVudC5wYWdlWSAtIGJvdW5kcy50b3A7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiBzaXplLmhlaWdodCAtIHlcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgY29vcmRpbmF0ZSBpbiB2aWV3cG9ydCBwaXhlbCBzcGFjZSB0byBhIG5vcm1hbGl6ZWQgcGxvdFxuXHQgKiBjb29yZGluYXRlLlxuXHQgKiBDb29yZGluYXRlIFswLCAwXSBpcyBib3R0b20tbGVmdCBvZiB0aGUgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHB4IC0gVGhlIHZpZXdwb3J0IHBpeGVsIGNvb3JkaW5hdGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBub3JtYWxpemVkIHBsb3QgY29vcmRpbmF0ZS5cblx0ICovXG5cdHZpZXdwb3J0UGl4ZWxUb1Bsb3RDb29yZChweCkge1xuXHRcdGNvbnN0IGV4dGVudCA9IHRoaXMuZ2V0UGl4ZWxFeHRlbnQoKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogcHgueCAvIGV4dGVudCxcblx0XHRcdHk6IHB4LnkgLyBleHRlbnRcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgY29vcmRpbmF0ZSBpbiBub3JtYWxpemVkIHBsb3Qgc3BhY2UgdG8gdmlld3BvcnQgcGl4ZWwgc3BhY2UuXG5cdCAqIENvb3JkaW5hdGUgWzAsIDBdIGlzIGJvdHRvbS1sZWZ0IG9mIHRoZSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9zIC0gVGhlIG5vcm1hbGl6ZWQgcGxvdCBjb29yZGluYXRlXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB2aWV3cG9ydCBwaXhlbCBjb29yZGluYXRlLlxuXHQgKi9cblx0cGxvdENvb3JkVG9WaWV3cG9ydFBpeGVsKHBvcykge1xuXHRcdGNvbnN0IGV4dGVudCA9IHRoaXMucGxvdC5nZXRQaXhlbEV4dGVudCgpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBwb3MueCAqIGV4dGVudCxcblx0XHRcdHk6IHBvcy55ICogZXh0ZW50XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSB2aWV3cG9ydC5cblx0ICpcblx0ICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gVGhlIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIG1hdHJpeC5cblx0ICovXG5cdGdldE9ydGhvTWF0cml4KCkge1xuXHRcdGNvbnN0IHNpemUgPSB0aGlzLmdldFZpZXdwb3J0UGl4ZWxTaXplKCk7XG5cdFx0Y29uc3QgbGVmdCA9IDA7XG5cdFx0Y29uc3QgcmlnaHQgPSBzaXplLndpZHRoO1xuXHRcdGNvbnN0IGJvdHRvbSA9IDA7XG5cdFx0Y29uc3QgdG9wID0gc2l6ZS5oZWlnaHQ7XG5cdFx0Y29uc3QgbmVhciA9IC0xO1xuXHRcdGNvbnN0IGZhciA9IDE7XG5cdFx0Y29uc3QgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG5cdFx0Y29uc3QgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG5cdFx0Y29uc3QgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuXHRcdGNvbnN0IG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXHRcdG91dFswXSA9IC0yICogbHI7XG5cdFx0b3V0WzFdID0gMDtcblx0XHRvdXRbMl0gPSAwO1xuXHRcdG91dFszXSA9IDA7XG5cdFx0b3V0WzRdID0gMDtcblx0XHRvdXRbNV0gPSAtMiAqIGJ0O1xuXHRcdG91dFs2XSA9IDA7XG5cdFx0b3V0WzddID0gMDtcblx0XHRvdXRbOF0gPSAwO1xuXHRcdG91dFs5XSA9IDA7XG5cdFx0b3V0WzEwXSA9IDIgKiBuZjtcblx0XHRvdXRbMTFdID0gMDtcblx0XHRvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcblx0XHRvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcblx0XHRvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG5cdFx0b3V0WzE1XSA9IDE7XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYW5zIHRvIHRoZSB0YXJnZXQgcGxvdCBjb29yZGluYXRlLiBDYW5jZWxzIGFueSBjdXJyZW50IHpvb20gb3IgcGFuXG5cdCAqIGFuaW1hdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgLSBUaGUgdGFyZ2V0IHBsb3QgcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSAtIFdoZXRoZXIgb3Igbm90IHRvIGFuaW1hdGUgdGhlIHBhbi4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UGxvdH0gVGhlIHBsb3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwYW5Ubyhwb3MsIGFuaW1hdGUgPSB0cnVlKSB7XG5cdFx0Ly8gY2FuY2VsIGV4aXN0aW5nIGFuaW1hdGlvbnNcblx0XHR0aGlzLmNhbmNlbFBhbigpO1xuXHRcdHRoaXMuY2FuY2VsWm9vbSgpO1xuXHRcdHRoaXNbSEFORExFUlNdLmdldChQQU4pLnBhblRvKHBvcywgYW5pbWF0ZSk7XG5cdFx0dGhpcy5zZXREaXJ0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFpvb21zIGluIHRvIHRoZSB0YXJnZXQgem9vbSBsZXZlbC4gVGhpcyBpcyBib3VuZGVkIGJ5IHRoZSBwbG90IG9iamVjdHNcblx0ICogbWluWm9vbSBhbmQgbWF4Wm9vbSBhdHRyaWJ1dGVzLiBDYW5jZWxzIGFueSBjdXJyZW50IHpvb20gb3IgcGFuXG5cdCAqIGFuaW1hdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCAtIFRoZSB0YXJnZXQgem9vbSBsZXZlbC5cblx0ICogQHBhcmFtIHtib29sZWFufSBhbmltYXRlIC0gV2hldGhlciBvciBub3QgdG8gYW5pbWF0ZSB0aGUgem9vbS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UGxvdH0gVGhlIHBsb3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHR6b29tVG8obGV2ZWwsIGFuaW1hdGUgPSB0cnVlKSB7XG5cdFx0Ly8gY2FuY2VsIGV4aXN0aW5nIGFuaW1hdGlvbnNcblx0XHR0aGlzLmNhbmNlbFBhbigpO1xuXHRcdHRoaXMuY2FuY2VsWm9vbSgpO1xuXHRcdHRoaXNbSEFORExFUlNdLmdldChaT09NKS56b29tVG8obGV2ZWwsIGFuaW1hdGUpO1xuXHRcdHRoaXMuc2V0RGlydHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBab29tcyBpbiB0byB0aGUgdGFyZ2V0IHpvb20gbGV2ZWwsIGNlbnRlcmVkIG9uIHRoZSB0YXJnZXQgY29vcmRpbmF0ZXMuIFRoZSB6b29tIGlzIGJvdW5kZWQgYnkgdGhlIHBsb3Qgb2JqZWN0c1xuXHQgKiBtaW5ab29tIGFuZCBtYXhab29tIGF0dHJpYnV0ZXMuIENhbmNlbHMgYW55IGN1cnJlbnQgem9vbSBvciBwYW4gYW5pbWF0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxldmVsIC0gVGhlIHRhcmdldCB6b29tIGxldmVsLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBUaGUgdGFyZ2V0IGNlbnRlciBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtib29sZWFufSBhbmltYXRlIC0gV2hldGhlciBvciBub3QgdG8gYW5pbWF0ZSB0aGUgem9vbS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UGxvdH0gVGhlIHBsb3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHR6b29tVG9Qb3NpdGlvbihsZXZlbCwgcG9zaXRpb24sIGFuaW1hdGUgPSB0cnVlKSB7XG5cdFx0Ly8gY2FuY2VsIGV4aXN0aW5nIGFuaW1hdGlvbnNcblx0XHR0aGlzLmNhbmNlbFBhbigpO1xuXHRcdHRoaXMuY2FuY2VsWm9vbSgpO1xuXHRcdHRoaXNbSEFORExFUlNdLmdldChaT09NKS56b29tVG9Qb3NpdGlvbihsZXZlbCwgcG9zaXRpb24sIGFuaW1hdGUpO1xuXHRcdHRoaXMuc2V0RGlydHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBGaXQgdGhlIHBsb3QgdG8gYSBwcm92aWRlZCBib3VuZHMgaW4gcGxvdCBjb29yZGluYXRlcy5cblx0ICpcblx0ICogQHBhcmFtIHtCb3VuZHN9IGJvdW5kcyAtIFRoZSBib3VuZHMgb2JqZWN0LCBpbiBwbG90IGNvb3JkaW5hdGVzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UGxvdH0gVGhlIHBsb3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRmaXRUb0JvdW5kcyhib3VuZHMpIHtcblx0XHRjb25zdCB0YXJnZXRab29tID0gdGhpcy5nZXRUYXJnZXRab29tKCk7XG5cdFx0Y29uc3QgdGFyZ2V0Vmlld3BvcnQgPSB0aGlzLmdldFRhcmdldFZpZXdwb3J0KCk7XG5cdFx0Y29uc3Qgc2NhbGVYID0gdGFyZ2V0Vmlld3BvcnQud2lkdGggLyBib3VuZHMuZ2V0V2lkdGgoKTtcblx0XHRjb25zdCBzY2FsZVkgPSB0YXJnZXRWaWV3cG9ydC5oZWlnaHQgLyBib3VuZHMuZ2V0SGVpZ2h0KCk7XG5cdFx0Y29uc3Qgc2NhbGUgPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG5cdFx0bGV0IHpvb20gPSBNYXRoLmxvZzIoc2NhbGUpICsgdGFyZ2V0Wm9vbTtcblx0XHR6b29tID0gY2xhbXAoem9vbSwgdGhpcy5taW5ab29tLCB0aGlzLm1heFpvb20pO1xuXHRcdGlmICghdGhpcy5jb250aW51b3VzWm9vbSkge1xuXHRcdFx0em9vbSA9IE1hdGguZmxvb3Ioem9vbSk7XG5cdFx0fVxuXHRcdGNvbnN0IGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLnpvb21Ubyh6b29tLCBmYWxzZSk7XG5cdFx0dGhpcy5wYW5UbyhjZW50ZXIsIGZhbHNlKTtcblx0XHR0aGlzLnNldERpcnR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxvdCBpcyBhY3RpdmVseSBwYW5uaW5nLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbH0gV2hldGhlciBvciBub3QgdGhlIHBsb3QgaXMgcGFubmluZy5cblx0ICovXG5cdGlzUGFubmluZygpIHtcblx0XHRyZXR1cm4gISF0aGlzLnBhbkFuaW1hdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbG90IGlzIGFjdGl2ZWx5IHpvb21pbmcuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sfSBXaGV0aGVyIG9yIG5vdCB0aGUgcGxvdCBpcyB6b29taW5nLlxuXHQgKi9cblx0aXNab29taW5nKCkge1xuXHRcdHJldHVybiAhIXRoaXMuem9vbUFuaW1hdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW5jZWxzIGFueSBjdXJyZW50IHBhbiBhbmltYXRpb24uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcGxvdCB3YXMgcGFubmluZy5cblx0ICovXG5cdGNhbmNlbFBhbigpIHtcblx0XHRpZiAodGhpcy5pc1Bhbm5pbmcoKSkge1xuXHRcdFx0dGhpcy5wYW5BbmltYXRpb24uY2FuY2VsKCk7XG5cdFx0XHR0aGlzLnBhbkFuaW1hdGlvbiA9IG51bGw7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbmNlbHMgYW55IGN1cnJlbnQgem9vbSBhbmltYXRpb24uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcGxvdCB3YXMgem9vbWluZy5cblx0ICovXG5cdGNhbmNlbFpvb20oKSB7XG5cdFx0aWYgKHRoaXMuaXNab29taW5nKCkpIHtcblx0XHRcdHRoaXMuem9vbUFuaW1hdGlvbi5jYW5jZWwoKTtcblx0XHRcdHRoaXMuem9vbUFuaW1hdGlvbiA9IG51bGw7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgdGhlIHBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSBwbG90LlxuXHQgKi9cblx0ZW5hYmxlUGFubmluZygpIHtcblx0XHR0aGlzW0hBTkRMRVJTXS5nZXQoUEFOKS5lbmFibGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyB0aGUgcGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHBsb3QuXG5cdCAqL1xuXHRkaXNhYmxlUGFubmluZygpIHtcblx0XHR0aGlzW0hBTkRMRVJTXS5nZXQoUEFOKS5kaXNhYmxlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyB0aGUgem9vbSBldmVudCBoYW5kbGVyIG9uIHRoZSBwbG90LlxuXHQgKi9cblx0ZW5hYmxlWm9vbWluZygpIHtcblx0XHR0aGlzW0hBTkRMRVJTXS5nZXQoWk9PTSkuZW5hYmxlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZXMgdGhlIHpvb20gZXZlbnQgaGFuZGxlciBvbiB0aGUgcGxvdC5cblx0ICovXG5cdGRpc2FibGVab29taW5nKCkge1xuXHRcdHRoaXNbSEFORExFUlNdLmdldChaT09NKS5kaXNhYmxlKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbnkgaGlnaGxpZ2h0ZWQgZGF0YS5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGhpZ2hsaWdodGVkIGRhdGEuXG5cdCAqL1xuXHRnZXRIaWdobGlnaHRlZCgpIHtcblx0XHRjb25zdCBsYXllcnMgPSB0aGlzLmxheWVycztcblx0XHRmb3IgKGxldCBpPTA7IGk8bGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBoaWdobGlnaHQgPSBsYXllcnNbaV0uZ2V0SGlnaGxpZ2h0ZWQoKTtcblx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0cmV0dXJuIGhpZ2hsaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBhcmd1bWVudCBpcyBoaWdobGlnaHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byB0ZXN0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlcmUgaXMgaGlnaGxpZ2h0ZWQgZGF0YS5cblx0ICovXG5cdGlzSGlnaGxpZ2h0ZWQoZGF0YSkge1xuXHRcdGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdGZvciAobGV0IGk9MDsgaTxsYXllcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChsYXllcnNbaV0uaXNIaWdobGlnaHRlZChkYXRhKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW55IHNlbGVjdGVkIGRhdGEuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHNlbGVjdGVkIGRhdGEuXG5cdCAqL1xuXHRnZXRTZWxlY3RlZCgpIHtcblx0XHRjb25zdCBzZWxlY3Rpb24gPSBbXTtcblx0XHRjb25zdCBsYXllcnMgPSB0aGlzLmxheWVycztcblx0XHRmb3IgKGxldCBpPTA7IGk8bGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBzZWxlY3RlZCA9IGxheWVyc1tpXS5nZXRTZWxlY3RlZCgpO1xuXHRcdFx0Zm9yIChsZXQgaj0wOyBqPHNlbGVjdGVkLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHNlbGVjdGlvbi5wdXNoKHNlbGVjdGVkW2pdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHNlbGVjdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50IGlzIHNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHRvIHRlc3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgZGF0YSBpcyBzZWxlY3RlZC5cblx0ICovXG5cdGlzU2VsZWN0ZWQoZGF0YSkge1xuXHRcdGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdGZvciAobGV0IGk9MDsgaTxsYXllcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChsYXllcnNbaV0uaXNTZWxlY3RlZChkYXRhKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgY29udGFpbmluZyBlbGVtZW50IG9mIHRoZSBwbG90LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBjb250YWluZXIgb2YgdGhlIHBsb3QuXG5cdCAqL1xuXHRnZXRDb250YWluZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGxvdDtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlb21ldHJ5L0JvdW5kcycpO1xyXG5jb25zdCBUaWxlQ29vcmQgPSByZXF1aXJlKCcuLi9sYXllci90aWxlL1RpbGVDb29yZCcpO1xyXG5cclxuLy8gUHJpdmF0ZSBNZXRob2RzXHJcblxyXG5jb25zdCBnZXRWaXNpYmxlVGlsZUJvdW5kcyA9IGZ1bmN0aW9uKHZpZXdwb3J0LCB0aWxlWm9vbSwgd3JhcGFyb3VuZCkge1xyXG5cdGNvbnN0IGJvdW5kcyA9IHZpZXdwb3J0LmdldFRpbGVCb3VuZHModGlsZVpvb20pO1xyXG5cdC8vIG1pbiAvIG1heCB0aWxlIGNvb3Jkc1xyXG5cdGNvbnN0IGRpbSA9IE1hdGgucG93KDIsIHRpbGVab29tKTtcclxuXHRjb25zdCBtaW4gPSAwO1xyXG5cdGNvbnN0IG1heCA9IGRpbSAtIDE7XHJcblx0Ly8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIHpvb20gbGV2ZWxcclxuXHRjb25zdCBsYXllckJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHR3cmFwYXJvdW5kID8gLUluZmluaXR5IDogbWluLFxyXG5cdFx0d3JhcGFyb3VuZCA/IEluZmluaXR5IDogbWF4LFxyXG5cdFx0bWluLFxyXG5cdFx0bWF4KTtcclxuXHQvLyBjaGVjayBpZiB0aGUgbGF5ZXIgaXMgd2l0aGluIHRoZSB2aWV3cG9ydFxyXG5cdGlmICghYm91bmRzLm92ZXJsYXBzKGxheWVyQm91bmRzKSkge1xyXG5cdFx0Ly8gdGhlcmUgaXMgbm8gb3ZlcmxhcFxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblx0Ly8gY2xhbXAgaG9yaXpvbnRhbCBib3VuZHMgaWYgdGhlcmUgaXMgbm8gd3JhcGFyb3VuZFxyXG5cdGNvbnN0IGxlZnQgPSB3cmFwYXJvdW5kID8gYm91bmRzLmxlZnQgOiBNYXRoLm1heChtaW4sIGJvdW5kcy5sZWZ0KTtcclxuXHRjb25zdCByaWdodCA9IHdyYXBhcm91bmQgPyBib3VuZHMucmlnaHQgOiBNYXRoLm1pbihtYXgsIGJvdW5kcy5yaWdodCk7XHJcblx0Ly8gY2xhbXAgdmVydGljYWwgYm91bmRzXHJcblx0Y29uc3QgYm90dG9tID0gTWF0aC5tYXgobWluLCBib3VuZHMuYm90dG9tKTtcclxuXHRjb25zdCB0b3AgPSBNYXRoLm1pbihtYXgsIGJvdW5kcy50b3ApO1xyXG5cdHJldHVybiBuZXcgQm91bmRzKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCk7XHJcbn07XHJcblxyXG5jb25zdCBpc1dpdGhpblJhbmdlID0gZnVuY3Rpb24obWluLCBtYXgsIG0sIG4pIHtcclxuXHQvLyBHaXZlbjpcclxuXHQvLyAgICAxKSBBbiBpbnRlZ2VyIHJhbmdlIHIgPSBbbWluIDogbWF4XS5cclxuXHQvLyAgICAyKSBBbiBwb3dlci1vZi10d28gaW50ZWdlciBtLlxyXG5cdC8vICAgIDMpIEFuIGludGVnZXIgbiB3aXRoaW4gdGhlIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgWzAgOiBtKS5cclxuXHQvLyAgICA0KSBBbiBpbnRlZ2VyIGNvbnN0YW50IGsuXHJcblx0Ly8gQ2hlY2sgaWYgbiwgb3IgYW55IHZhbHVlcyBvZiBtICsvLSBrbiwgaXMgd2l0aGluIHRoZSByYW5nZSBSLlxyXG5cdC8vXHJcblx0Ly8gRXg6XHJcblx0Ly8gICAgIG1pbjogLTNcclxuXHQvLyAgICAgbWF4OiA2XHJcblx0Ly8gICAgIG06IDhcclxuXHQvLyAgICAgbjogN1xyXG5cdC8vXHJcblx0Ly8gUmV0dXJuIHRydWUgYmVjYXVzZSA3IC0gOCA9IC0xLCB3aGljaCBpcyB3aXRoaW4gdGhlIHJhbmdlIC0zIHRvIDYuXHJcblxyXG5cdC8vIHdpdGhpbiByYW5nZVxyXG5cdGlmIChtaW4gPD0gbiAmJiBuIDw9IG1heCkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvLyBpZiB0aGUgcmFuZ2UgaXMgYWJvdmUgbiwgZmluZCBob3cgbWFueSBtJ3MgZml0XHJcblx0Ly8gaW4gdGhlIGRpc3RhbmNlIGJldHdlZW4gbiBhbmQgbWluXHJcblx0aWYgKG1pbiA+IG4pIHtcclxuXHRcdGNvbnN0IGsgPSBNYXRoLmNlaWwoKG1pbiAtIG4pIC8gbSk7XHJcblx0XHRyZXR1cm4gbiArIGsgKiBtIDw9IG1heDtcclxuXHR9XHJcblxyXG5cdC8vIGlmIHRoZSByYW5nZSBpcyBiZWxvdyBuLCBmaW5kIGhvdyBtYW55IG0ncyBmaXRcclxuXHQvLyBpbiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBtYXggYW5kIG5cclxuXHRjb25zdCBrID0gTWF0aC5jZWlsKChuIC0gbWF4KSAvIG0pO1xyXG5cdHJldHVybiBuIC0gayAqIG0gPj0gbWluO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHZpZXdwb3J0LlxyXG4gKi9cclxuY2xhc3MgVmlld3BvcnQge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgVmlld3BvcnQgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSB2aWV3cG9ydC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHZpZXdwb3J0LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdmlld3BvcnQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB0aWxlIGJvdW5kcyBvZiB0aGUgdmlld3BvcnQuIEJvdW5kcyBlZGdlcyBhcmUgaW5jbHVzaXZlLlxyXG5cdCAqIE5PVEU6IHRoaXMgaW5jbHVkZXMgd3JhcGFyb3VuZCBjb29yZGluYXRlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlWm9vbSAtIFRoZSB6b29tIG9mIHRoZSB0aWxlcyB3aXRoaW4gdGhlIHZpZXdwb3J0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0JvdW5kc30gVGhlIHRpbGUgYm91bmRzIG9mIHRoZSB2aWV3cG9ydC5cclxuXHQgKi9cclxuXHRnZXRUaWxlQm91bmRzKHRpbGVab29tKSB7XHJcblx0XHQvLyBjYWxjIGhvdyBtYW55IGZpdCBhcmUgaW4gdGhlIHBsb3RcclxuXHRcdGNvbnN0IHRpbGVTcGFuID0gMSAvIE1hdGgucG93KDIsIHRpbGVab29tKTtcclxuXHRcdC8vIGRldGVybWluZSBib3VuZHNcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKFxyXG5cdFx0XHRNYXRoLmZsb29yKHRoaXMueCAvIHRpbGVTcGFuKSxcclxuXHRcdFx0TWF0aC5jZWlsKCh0aGlzLnggKyB0aGlzLndpZHRoKSAvIHRpbGVTcGFuKSAtIDEsXHJcblx0XHRcdE1hdGguZmxvb3IodGhpcy55IC8gdGlsZVNwYW4pLFxyXG5cdFx0XHRNYXRoLmNlaWwoKHRoaXMueSArIHRoaXMuaGVpZ2h0KSAvIHRpbGVTcGFuKSAtIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgdGhhdCBhcmUgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlsZVpvb20gLSBUaGUgem9vbSBvZiB0aGUgdGlsZXMgd2l0aGluIHRoZSB2aWV3cG9ydC4gT3B0aW9uYWwuXHJcblx0ICogQHBhcmFtIHtib29sZWFufSB3cmFwYXJvdW5kIC0gVGhlIGlmIHRoZSBob3Jpem9udGFsIGF4aXMgc2hvdWxkIHdyYXBhcm91bmQuIE9wdGlvbmFsLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgdmlzaWJsZSB0aWxlIGNvb3Jkcy5cclxuXHQgKi9cclxuXHRnZXRWaXNpYmxlQ29vcmRzKHRpbGVab29tLCB3cmFwYXJvdW5kID0gZmFsc2UpIHtcclxuXHRcdC8vIGdldCB0aGUgYm91bmRzIGZvciB3aGF0IHRpbGVzIGFyZSBpbiB2aWV3XHJcblx0XHRjb25zdCBib3VuZHMgPSBnZXRWaXNpYmxlVGlsZUJvdW5kcyh0aGlzLCB0aWxlWm9vbSwgd3JhcGFyb3VuZCk7XHJcblx0XHQvLyBjaGVjayBpZiBubyBjb29yZHMgYXJlIGluIHZpZXdcclxuXHRcdGlmICghYm91bmRzKSB7XHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHRcdC8vIHJldHVybiBhbiBhcnJheSBvZiB0aGUgY29vcmRzXHJcblx0XHRjb25zdCBjb29yZHMgPSBbXTtcclxuXHRcdGZvciAobGV0IHg9Ym91bmRzLmxlZnQ7IHg8PWJvdW5kcy5yaWdodDsgeCsrKSB7XHJcblx0XHRcdGZvciAobGV0IHk9Ym91bmRzLmJvdHRvbTsgeTw9Ym91bmRzLnRvcDsgeSsrKSB7XHJcblx0XHRcdFx0Y29vcmRzLnB1c2gobmV3IFRpbGVDb29yZCh0aWxlWm9vbSwgeCwgeSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY29vcmRzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgY29vcmQgaXMgd2l0aGluIHRoZSB2aWV3cG9ydC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBjb29yZCAtIFRoZSBjb29yZC5cclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHdyYXBhcm91bmQgLSBUaGUgaWYgdGhlIGhvcml6b250YWwgYXhpcyBzaG91bGQgd3JhcGFyb3VuZC4gT3B0aW9uYWwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGNvb3JkIGlzIGluIHZpZXcuXHJcblx0ICovXHJcblx0aXNJblZpZXcoY29vcmQsIHdyYXBhcm91bmQgPSBmYWxzZSkge1xyXG5cdFx0Ly8gZ2V0IHRoZSBib3VuZHMgZm9yIHdoYXQgdGlsZXMgYXJlIGluIHZpZXdcclxuXHRcdGNvbnN0IGJvdW5kcyA9IGdldFZpc2libGVUaWxlQm91bmRzKHRoaXMsIGNvb3JkLnosIHdyYXBhcm91bmQpO1xyXG5cdFx0Ly8gY2hlY2sgaWYgbm8gY29vcmRzIGFyZSBpbiB2aWV3XHJcblx0XHRpZiAoIWJvdW5kcykge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRjb25zdCBkaW0gPSBNYXRoLnBvdygyLCBjb29yZC56KTtcclxuXHRcdHJldHVybiBpc1dpdGhpblJhbmdlKGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQsIGRpbSwgY29vcmQueCkgJiZcclxuXHRcdFx0aXNXaXRoaW5SYW5nZShib3VuZHMuYm90dG9tLCBib3VuZHMudG9wLCBkaW0sIGNvb3JkLnkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHZpZXdwb3J0IHRoYXQgaGFzIGJlZW4gem9vbWVkIGFyb3VuZCBhIHByb3ZpZGVkIHBvc2l0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBUaGUgY3VycmVudCB6b29tIG9mIHRoZSB2aWV3cG9ydC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0Wm9vbSAtIFRoZSB0YXJnZXQgem9vbSBvZiB0aGUgdmlld3BvcnQuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFBvcyAtIFRoZSB0YXJnZXQgcG9zaXRpb24gdG8gem9vbSBhcm91bmQuXHJcblx0ICogQHBhcmFtIHtib29sZWFufSByZWxhdGl2ZSAtIFRoZSB0YXJnZXQgcG9zaXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gd2hlbiB0cnVlLCBhbmQgY2VudGVyZWRcclxuXHQgKiB3aGVuIGZhbHNlLiAgVGhpcyBwYXJhbWF0ZXIgZGVmYXVsdHMgdG8gdHJ1ZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtWaWV3cG9ydH0gVGhlIG5ldyB2aWV3cG9ydCBvYmplY3QuXHJcblx0ICovXHJcblx0em9vbVRvUG9zKHpvb20sIHRhcmdldFpvb20sIHRhcmdldFBvcywgcmVsYXRpdmUgPSB0cnVlKSB7XHJcblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHRhcmdldFpvb20gLSB6b29tKTtcclxuXHRcdGNvbnN0IHNjYWxlZFdpZHRoID0gdGhpcy53aWR0aCAvIHNjYWxlO1xyXG5cdFx0Y29uc3Qgc2NhbGVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyBzY2FsZTtcclxuXHRcdGNvbnN0IHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KFxyXG5cdFx0XHR0YXJnZXRQb3MueCAtICgodGFyZ2V0UG9zLnggLSB0aGlzLngpIC8gc2NhbGUpLFxyXG5cdFx0XHR0YXJnZXRQb3MueSAtICgodGFyZ2V0UG9zLnkgLSB0aGlzLnkpIC8gc2NhbGUpLFxyXG5cdFx0XHRzY2FsZWRXaWR0aCxcclxuXHRcdFx0c2NhbGVkSGVpZ2h0KTtcclxuXHRcdGlmICghcmVsYXRpdmUpIHtcclxuXHRcdFx0dmlld3BvcnQuY2VudGVyT24odGFyZ2V0UG9zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2aWV3cG9ydDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGxvd2VyLWxlZnQgY29ybmVyIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydCBpbiBwbG90XHJcblx0ICogY29vcmRpbmF0ZXMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGxvdCBwb3NpdGlvbi5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHRoaXMueCxcclxuXHRcdFx0eTogdGhpcy55XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBpbiBwbG90IGNvb3JkaW5hdGVzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHBsb3QgY2VudGVyLlxyXG5cdCAqL1xyXG5cdGdldENlbnRlcigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHRoaXMueCArIHRoaXMud2lkdGggLyAyLFxyXG5cdFx0XHR5OiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDJcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB2aWV3cG9ydHMgc2l6ZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gem9vbSAtIFRoZSB6b29tIG9mIHRoZSBwbG90LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlU2l6ZSAtIFRoZSBzaXplIG9mIGEgdGlsZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdmlldyBzaXplIGluIHBpeGVscy5cclxuXHQgKi9cclxuXHRnZXRQaXhlbFNpemUoem9vbSwgdGlsZVNpemUpIHtcclxuXHRcdGNvbnN0IGV4dGVudCA9IE1hdGgucG93KDIsIHpvb20pICogdGlsZVNpemU7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR3aWR0aDogTWF0aC5yb3VuZCh0aGlzLndpZHRoICogZXh0ZW50KSxcclxuXHRcdFx0aGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogZXh0ZW50KVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHZpZXdwb3J0cyBvZmZzZXQgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBUaGUgem9vbSBvZiB0aGUgcGxvdC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlsZVNpemUgLSBUaGUgc2l6ZSBvZiBhIHRpbGUgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHZpZXcgb2Zmc2V0IGluIHBpeGVscy5cclxuXHQgKi9cclxuXHRnZXRQaXhlbE9mZnNldCh6b29tLCB0aWxlU2l6ZSkge1xyXG5cdFx0Y29uc3QgZXh0ZW50ID0gTWF0aC5wb3coMiwgem9vbSkgKiB0aWxlU2l6ZTtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHRoaXMueCAqIGV4dGVudCxcclxuXHRcdFx0eTogdGhpcy55ICogZXh0ZW50XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2VudGVycyB0aGUgdmlld3BvcnQgb24gYSBnaXZlbiBwbG90IGNvb3JkaW5hdGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9zIC0gVGhlIHBvc2l0aW9uIHRvIGNlbnRlciB0aGUgdmlld3BvcnQgb24uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Vmlld3BvcnR9IFRoZSB2aWV3cG9ydCBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRjZW50ZXJPbihwb3MpIHtcclxuXHRcdHRoaXMueCA9IHBvcy54IC0gdGhpcy53aWR0aCAvIDI7XHJcblx0XHR0aGlzLnkgPSBwb3MueSAtIHRoaXMuaGVpZ2h0IC8gMjtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnQ7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gYW5pbWF0aW9uLlxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IEFuaW1hdGlvbiBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgb2YgdGhlIGFuaW1hdGlvbi5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBsb3QgLSBUaGUgcGxvdCB0YXJnZXQgb2YgdGhlIGFuaW1hdGlvbi5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocGFyYW1zKSB7XHJcblx0XHR0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcblx0XHR0aGlzLmR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uO1xyXG5cdFx0dGhpcy5wbG90ID0gcGFyYW1zLnBsb3Q7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB0LXZhbHVlIG9mIHRoZSBhbmltYXRpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIHRpbWVzdGFtcC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSBUaGUgZnJhbWUgdGltZXN0YW1wLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHQtdmFsdWUgZm9yIHRoZSBjb3JyZXNwb25kaW5nIHRpbWVzdGFtcC5cclxuXHQgKi9cclxuXHRnZXRUKHRpbWVzdGFtcCkge1xyXG5cdFx0aWYgKHRoaXMuZHVyYXRpb24gPiAwKSB7XHJcblx0XHRcdHJldHVybiBNYXRoLm1pbigxLjAsICh0aW1lc3RhbXAgLSB0aGlzLnRpbWVzdGFtcCkgLyB0aGlzLmR1cmF0aW9uKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAxLjA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSB0aGUgcGxvdCBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcclxuXHQgKiBhbmltYXRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gVGhlIGZyYW1lIHRpbWVzdGFtcC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5cclxuXHQgKi9cclxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG5cdHVwZGF0ZSh0aW1lc3RhbXApIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2FuY2VsIHRoZSBhbmltYXRpb24gYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBwbG90LlxyXG5cdCAqL1xyXG5cdGNhbmNlbCgpIHtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXBsZXRlIHRoZSBhbmltYXRpb24gYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBwbG90LlxyXG5cdCAqL1xyXG5cdGZpbmlzaCgpIHtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBFdmVudFR5cGUgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudFR5cGUnKTtcclxuY29uc3QgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudCcpO1xyXG5jb25zdCBBbmltYXRpb24gPSByZXF1aXJlKCcuL0FuaW1hdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHBhbiBhbmltYXRpb24uXHJcbiAqL1xyXG5jbGFzcyBQYW5BbmltYXRpb24gZXh0ZW5kcyBBbmltYXRpb24ge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUGFuQW5pbWF0aW9uIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBvZiB0aGUgYW5pbWF0aW9uLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucGxvdCAtIFRoZSBwbG90IHRhcmdldCBvZiB0aGUgYW5pbWF0aW9uLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZHVyYXRpb24gLSBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gVGhlIHN0YXJ0IHRpbWVzdGFtcCBvZiB0aGUgYW5pbWF0aW9uLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZGVsdGEgLSBUaGUgcG9zaXRpb25hbCBkZWx0YSBvZiB0aGUgYW5pbWF0aW9uLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZWFzaW5nIC0gVGhlIGVhc2luZyBmYWN0b3Igb2YgdGhlIGFuaW1hdGlvbi5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xyXG5cdFx0c3VwZXIocGFyYW1zKTtcclxuXHRcdHRoaXMuc3RhcnQgPSBwYXJhbXMuc3RhcnQ7XHJcblx0XHR0aGlzLmRlbHRhID0gcGFyYW1zLmRlbHRhO1xyXG5cdFx0dGhpcy5lbmQgPSB7XHJcblx0XHRcdHg6IHRoaXMuc3RhcnQueCArIHRoaXMuZGVsdGEueCxcclxuXHRcdFx0eTogdGhpcy5zdGFydC55ICsgdGhpcy5kZWx0YS55LFxyXG5cdFx0fTtcclxuXHRcdHRoaXMuZWFzaW5nID0gcGFyYW1zLmVhc2luZztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwbG90IGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxyXG5cdCAqIGFuaW1hdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSBUaGUgZnJhbWUgdGltZXN0YW1wLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZSh0aW1lc3RhbXApIHtcclxuXHRcdGNvbnN0IHQgPSB0aGlzLmdldFQodGltZXN0YW1wKTtcclxuXHRcdC8vIGNhbGN1bGF0ZSB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGFuaW1hdGlvblxyXG5cdFx0Y29uc3QgcHJvZ3Jlc3MgPSAxIC0gTWF0aC5wb3coMSAtIHQsIDEgLyB0aGlzLmVhc2luZyk7XHJcblx0XHQvLyBjYWNsdWxhdGUgdGhlIGN1cnJlbnQgcG9zaXRpb24gYWxvbmcgdGhlIHBhblxyXG5cdFx0Y29uc3QgcGxvdCA9IHRoaXMucGxvdDtcclxuXHRcdC8vIHNldCB0aGUgdmlld3BvcnQgcG9zaXRpb25zXHJcblx0XHRwbG90LnZpZXdwb3J0LnggPSB0aGlzLnN0YXJ0LnggKyB0aGlzLmRlbHRhLnggKiBwcm9ncmVzcztcclxuXHRcdHBsb3Qudmlld3BvcnQueSA9IHRoaXMuc3RhcnQueSArIHRoaXMuZGVsdGEueSAqIHByb2dyZXNzO1xyXG5cdFx0Ly8gY3JlYXRlIHBhbiBldmVudFxyXG5cdFx0Y29uc3QgZXZlbnQgPSBuZXcgRXZlbnQocGxvdCk7XHJcblx0XHQvLyBjaGVjayBpZiBhbmltYXRpb24gaXMgZmluaXNoZWRcclxuXHRcdGlmICh0IDwgMSkge1xyXG5cdFx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLlBBTiwgZXZlbnQpO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLlBBTl9FTkQsIGV2ZW50KTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2FuY2VscyB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgcGxvdC5cclxuXHQgKi9cclxuXHRjYW5jZWwoKSB7XHJcblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xyXG5cdFx0Ly8gZW1pdCBwYW4gZW5kXHJcblx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLlBBTl9FTkQsIG5ldyBFdmVudChwbG90KSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wbGV0ZSB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBwbG90LlxyXG5cdCAqL1xyXG5cdGZpbmlzaCgpIHtcclxuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLnBsb3Q7XHJcblx0XHQvLyBzZXQgdGhlIHZpZXdwb3J0IHBvc2l0aW9uc1xyXG5cdFx0cGxvdC52aWV3cG9ydC54ID0gdGhpcy5lbmQueDtcclxuXHRcdHBsb3Qudmlld3BvcnQueSA9IHRoaXMuZW5kLnk7XHJcblx0XHQvLyBlbWl0IHBhbiBlbmRcclxuXHRcdHBsb3QuZW1pdChFdmVudFR5cGUuUEFOX0VORCwgbmV3IEV2ZW50KHBsb3QpKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGFuQW5pbWF0aW9uO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBFdmVudFR5cGUgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudFR5cGUnKTtcclxuY29uc3QgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudCcpO1xyXG5jb25zdCBBbmltYXRpb24gPSByZXF1aXJlKCcuL0FuaW1hdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHpvb20gYW5pbWF0aW9uLlxyXG4gKi9cclxuY2xhc3MgWm9vbUFuaW1hdGlvbiBleHRlbmRzIEFuaW1hdGlvbiB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBab29tQW5pbWF0aW9uIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBvZiB0aGUgYW5pbWF0aW9uLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucGxvdCAtIFRoZSBwbG90IHRhcmdldCBvZiB0aGUgYW5pbWF0aW9uLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZHVyYXRpb24gLSBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnByZXZab29tIC0gVGhlIHN0YXJ0aW5nIHpvb20gb2YgdGhlIGFuaW1hdGlvbi5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnRhcmdldFpvb20gLSBUaGUgdGFyZ2V0IHpvb20gb2YgdGhlIGFuaW1hdGlvbi5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnByZXZWaWV3cG9ydCAtIFRoZSBzdGFydGluZyB2aWV3cG9ydCBvZiB0aGUgYW5pbWF0aW9uLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudGFyZ2V0Vmlld3BvcnQgLSBUaGUgdGFyZ2V0IHZpZXdwb3J0IG9mIHRoZSBhbmltYXRpb24uXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50YXJnZXRQb3MgLSBUaGUgdGFyZ2V0IHBvc2l0aW9uIG9mIHRoZSBhbmltYXRpb24sIGluIHBsb3QgY29vcmRpbmF0ZXMuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcclxuXHRcdHN1cGVyKHBhcmFtcyk7XHJcblx0XHR0aGlzLnByZXZab29tID0gcGFyYW1zLnByZXZab29tO1xyXG5cdFx0dGhpcy50YXJnZXRab29tID0gcGFyYW1zLnRhcmdldFpvb207XHJcblx0XHR0aGlzLnByZXZWaWV3cG9ydCA9IHBhcmFtcy5wcmV2Vmlld3BvcnQ7XHJcblx0XHR0aGlzLnRhcmdldFZpZXdwb3J0ID0gcGFyYW1zLnRhcmdldFZpZXdwb3J0O1xyXG5cdFx0dGhpcy50YXJnZXRQb3MgPSBwYXJhbXMudGFyZ2V0UG9zO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGUgem9vbSBvZiB0aGUgcGxvdCBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcclxuXHQgKiBhbmltYXRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gVGhlIGZyYW1lIHRpbWVzdGFtcC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5cclxuXHQgKi9cclxuXHR1cGRhdGUodGltZXN0YW1wKSB7XHJcblx0XHRjb25zdCB0ID0gdGhpcy5nZXRUKHRpbWVzdGFtcCk7XHJcblx0XHQvLyBjYWxjIG5ldyB6b29tXHJcblx0XHRjb25zdCByYW5nZSA9IHRoaXMudGFyZ2V0Wm9vbSAtIHRoaXMucHJldlpvb207XHJcblx0XHRjb25zdCB6b29tID0gdGhpcy5wcmV2Wm9vbSArIChyYW5nZSAqIHQpO1xyXG5cdFx0Y29uc3QgcGxvdCA9IHRoaXMucGxvdDtcclxuXHRcdC8vIHNldCBuZXcgem9vbVxyXG5cdFx0cGxvdC56b29tID0gem9vbTtcclxuXHRcdC8vIGNhbGMgbmV3IHZpZXdwb3J0IHBvc2l0aW9uIGZyb20gcHJldlxyXG5cdFx0cGxvdC52aWV3cG9ydCA9IHRoaXMucHJldlZpZXdwb3J0Lnpvb21Ub1BvcyhcclxuXHRcdFx0dGhpcy5wcmV2Wm9vbSxcclxuXHRcdFx0cGxvdC56b29tLFxyXG5cdFx0XHR0aGlzLnRhcmdldFBvcyk7XHJcblx0XHQvLyBjcmVhdGUgem9vbSBldmVudFxyXG5cdFx0Y29uc3QgZXZlbnQgPSBuZXcgRXZlbnQocGxvdCk7XHJcblx0XHQvLyBjaGVjayBpZiBhbmltYXRpb24gaXMgZmluaXNoZWRcclxuXHRcdGlmICh0IDwgMSkge1xyXG5cdFx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLlpPT00sIGV2ZW50KTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5aT09NX0VORCwgZXZlbnQpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDYW5jZWxzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBwbG90LlxyXG5cdCAqL1xyXG5cdGNhbmNlbCgpIHtcclxuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLnBsb3Q7XHJcblx0XHRpZiAoIXBsb3QuY29udGludW91c1pvb20pIHtcclxuXHRcdFx0Ly8gcm91bmQgdG8gdGhlIGNsb3Nlc3Qgem9vbVxyXG5cdFx0XHRwbG90Lnpvb20gPSBNYXRoLnJvdW5kKHBsb3Quem9vbSk7XHJcblx0XHRcdC8vIGNhbGMgdmlld3BvcnQgcG9zaXRpb24gZnJvbSBwcmV2XHJcblx0XHRcdHBsb3Qudmlld3BvcnQgPSB0aGlzLnByZXZWaWV3cG9ydC56b29tVG9Qb3MoXHJcblx0XHRcdFx0dGhpcy5wcmV2Wm9vbSxcclxuXHRcdFx0XHRwbG90Lnpvb20sXHJcblx0XHRcdFx0dGhpcy50YXJnZXRQb3MpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gZW1pdCB6b29tIGVuZFxyXG5cdFx0Y29uc3QgZXZlbnQgPSBuZXcgRXZlbnQocGxvdCk7XHJcblx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLlpPT01fRU5ELCBldmVudCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wbGV0ZSB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBwbG90LlxyXG5cdCAqL1xyXG5cdGZpbmlzaCgpIHtcclxuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLnBsb3Q7XHJcblx0XHRwbG90Lnpvb20gPSB0aGlzLnRhcmdldFpvb207XHJcblx0XHRwbG90LnZpZXdwb3J0ID0gdGhpcy50YXJnZXRWaWV3cG9ydDtcclxuXHRcdC8vIGVtaXQgem9vbSBlbmRcclxuXHRcdGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KHBsb3QpO1xyXG5cdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5aT09NX0VORCwgZXZlbnQpO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBab29tQW5pbWF0aW9uO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBFdmVudFR5cGUgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudFR5cGUnKTtcclxuY29uc3QgTW91c2VFdmVudCA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L01vdXNlRXZlbnQnKTtcclxuY29uc3QgRE9NSGFuZGxlciA9IHJlcXVpcmUoJy4vRE9NSGFuZGxlcicpO1xyXG5cclxuLy8gQ29uc3RhbnRzXHJcblxyXG4vKipcclxuICogRGlzdGFuY2UgaW4gcGl4ZWxzIHRoZSBtb3VzZSBjYW4gYmUgbW92ZWQgYmVmb3JlIHRoZSBjbGljayBldmVudCBpc1xyXG4gKiBjYW5jZWxsZWQuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgTU9WRV9UT0xFUkFOQ0UgPSAxNTtcclxuXHJcbi8vIFByaXZhdGUgTWV0aG9kc1xyXG5cclxuY29uc3QgY3JlYXRlRXZlbnQgPSBmdW5jdGlvbihoYW5kbGVyLCBwbG90LCBldmVudCkge1xyXG5cdHJldHVybiBuZXcgTW91c2VFdmVudChcclxuXHRcdHBsb3QsIC8vIHRhcmdldFxyXG5cdFx0ZXZlbnQsIC8vIG9yaWdpbmFsRXZlbnRcclxuXHRcdGhhbmRsZXIubW91c2VUb1Bsb3QoZXZlbnQpLCAvLyBwb3NcclxuXHRcdGhhbmRsZXIubW91c2VUb1ZpZXdQeChldmVudCkpOyAvLyBweFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsaWNrIGhhbmRsZXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jbGFzcyBDbGlja0hhbmRsZXIgZXh0ZW5kcyBET01IYW5kbGVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IENsaWNrSGFuZGxlciBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byBhdHRhY2ggdGhlIGhhbmRsZXIgdG8uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocGxvdCkge1xyXG5cdFx0c3VwZXIocGxvdCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFbmFibGVzIHRoZSBoYW5kbGVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0NsaWNrSGFuZGxlcn0gVGhlIGhhbmRsZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZW5hYmxlKCkge1xyXG5cdFx0c3VwZXIuZW5hYmxlKCk7XHJcblxyXG5cdFx0Y29uc3QgcGxvdCA9IHRoaXMucGxvdDtcclxuXHJcblx0XHRsZXQgbGFzdCA9IG51bGw7XHJcblx0XHR0aGlzLm1vdXNlZG93biA9IChldmVudCkgPT4ge1xyXG5cdFx0XHRsYXN0ID0gdGhpcy5tb3VzZVRvVmlld1B4KGV2ZW50KTtcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5tb3VzZXVwID0gKGV2ZW50KSA9PiB7XHJcblx0XHRcdGlmICghbGFzdCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb25zdCBwb3MgPSB0aGlzLm1vdXNlVG9WaWV3UHgoZXZlbnQpO1xyXG5cdFx0XHRjb25zdCBkaWZmID0ge1xyXG5cdFx0XHRcdHg6IGxhc3QueCAtIHBvcy54ICxcclxuXHRcdFx0XHR5OiBsYXN0LnkgLSBwb3MueVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRjb25zdCBkaXN0U3FyZCA9IGRpZmYueCAqIGRpZmYueCArIGRpZmYueSAqIGRpZmYueTtcclxuXHRcdFx0aWYgKGRpc3RTcXJkIDwgTU9WRV9UT0xFUkFOQ0UgKiBNT1ZFX1RPTEVSQU5DRSkge1xyXG5cdFx0XHRcdC8vIG1vdmVtZW50IHdhcyB3aXRoaW4gdG9sZXJhbmNlLCBlbWl0IGNsaWNrXHJcblx0XHRcdFx0cGxvdC5zZXREaXJ0eSgpO1xyXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0dGhpcy5wbG90LmVtaXQoRXZlbnRUeXBlLkNMSUNLLCBjcmVhdGVFdmVudCh0aGlzLCBwbG90LCBldmVudCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmRibGNsaWNrID0gKGV2ZW50KSA9PiB7XHJcblx0XHRcdHBsb3Quc2V0RGlydHkoKTtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0dGhpcy5wbG90LmVtaXQoRXZlbnRUeXBlLkRCTF9DTElDSywgY3JlYXRlRXZlbnQodGhpcywgcGxvdCwgZXZlbnQpKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgY29udGFpbmVyID0gcGxvdC5nZXRDb250YWluZXIoKTtcclxuXHRcdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bik7XHJcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cCk7XHJcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLmRibGNsaWNrKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc2FibGVzIHRoZSBoYW5kbGVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0NsaWNrSGFuZGxlcn0gVGhlIGhhbmRsZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZGlzYWJsZSgpIHtcclxuXHRcdHN1cGVyLmRpc2FibGUoKTtcclxuXHRcdGNvbnN0IGNvbnRhaW5lciA9IHRoaXMucGxvdC5nZXRDb250YWluZXIoKTtcclxuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bik7XHJcblx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cCk7XHJcblx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLmRibGNsaWNrKTtcclxuXHRcdHRoaXMubW91c2Vkb3duID0gbnVsbDtcclxuXHRcdHRoaXMubW91c2V1cCA9IG51bGw7XHJcblx0XHR0aGlzLmRibGNsaWNrID0gbnVsbDtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xpY2tIYW5kbGVyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgRE9NIGhhbmRsZXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jbGFzcyBET01IYW5kbGVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IERPTSBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byBhdHRhY2ggdGhlIGhhbmRsZXIgdG8uXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocGxvdCkge1xyXG5cdFx0dGhpcy5wbG90ID0gcGxvdDtcclxuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRW5hYmxlcyB0aGUgaGFuZGxlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtab29tSGFuZGxlcn0gVGhlIGhhbmRsZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZW5hYmxlKCkge1xyXG5cdFx0aWYgKHRoaXMuZW5hYmxlZCkge1xyXG5cdFx0XHR0aHJvdyAnSGFuZGxlciBpcyBhbHJlYWR5IGVuYWJsZWQnO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc2FibGVzIHRoZSBoYW5kbGVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1pvb21IYW5kbGVyfSBUaGUgaGFuZGxlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRkaXNhYmxlKCkge1xyXG5cdFx0aWYgKCF0aGlzLmVuYWJsZWQpIHtcclxuXHRcdFx0dGhyb3cgJ0hhbmRsZXIgaXMgYWxyZWFkeSBkaXNhYmxlZCc7XHJcblx0XHR9XHJcblx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRha2VzIGEgRE9NIGV2ZW50IGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBsb3QgcG9zaXRpb24uXHJcblx0ICogQ29vcmRpbmF0ZSBbMCwgMF0gaXMgYm90dG9tLWxlZnQgb2YgdGhlIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBtb3VzZSBldmVudC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwbG90IHBvc2l0aW9uLlxyXG5cdCAqL1xyXG5cdG1vdXNlVG9QbG90KGV2ZW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wbG90Lm1vdXNlVG9QbG90Q29vcmQoZXZlbnQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGFrZXMgYSBET00gZXZlbnQgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgdmlld3BvcnQgcGl4ZWwgcG9zaXRpb24uXHJcblx0ICogQ29vcmRpbmF0ZSBbMCwgMF0gaXMgYm90dG9tLWxlZnQgb2YgdGhlIHZpZXdwb3J0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdmlld3BvcnQgcGl4ZWwgY29vcmRpbmF0ZS5cclxuXHQgKi9cclxuXHRtb3VzZVRvVmlld1B4KGV2ZW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wbG90Lm1vdXNlVG9WaWV3cG9ydFBpeGVsKGV2ZW50KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRha2VzIGEgdmlld3BvcnQgcGl4ZWwgY29vcmRpbmF0ZSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwbG90XHJcblx0ICogcG9zaXRpb24uXHJcblx0ICogQ29vcmRpbmF0ZSBbMCwgMF0gaXMgYm90dG9tLWxlZnQgb2YgdGhlIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHggLSBUaGUgdmlld3BvcnQgcGl4ZWwgY29vcmRpbmF0ZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwbG90IHBvc2l0aW9uLlxyXG5cdCAqL1xyXG5cdHZpZXdQeFRvUGxvdChweCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucGxvdC52aWV3cG9ydFBpeGVsVG9QbG90Q29vcmQocHgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGFrZXMgYSBwbG90IHBvc2l0aW9uIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHZpZXdwb3J0IHBpeGVsXHJcblx0ICogY29vcmRpbmF0ZS5cclxuXHQgKiBDb29yZGluYXRlIFswLCAwXSBpcyBib3R0b20tbGVmdCBvZiB0aGUgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3MgLSBUaGUgcGxvdCBwb3NpdGlvbi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB2aWV3cG9ydCBwaXhlbCBjb29yZGluYXRlLlxyXG5cdCAqL1xyXG5cdHBsb3RUb1ZpZXdQeChwb3MpIHtcclxuXHRcdHJldHVybiB0aGlzLnBsb3QucGxvdENvb3JkVG9WaWV3cG9ydFBpeGVsKHBvcyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUYWtlcyBhIERPTSBldmVudCBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBkb3duLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgZG93bi5cclxuXHQgKi9cclxuXHRpc0xlZnRCdXR0b24oZXZlbnQpIHtcclxuXHRcdHJldHVybiAoZXZlbnQud2hpY2gpID8gZXZlbnQud2hpY2ggPT09IDEgOiBldmVudC5idXR0b24gPT09IDA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUYWtlcyBhIERPTSBldmVudCBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBtaWRkbGUgbW91c2UgYnV0dG9uIGlzIGRvd24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBtb3VzZSBldmVudC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBtaWRkbGUgbW91c2UgYnV0dG9uIGlzIGRvd24uXHJcblx0ICovXHJcblx0aXNNaWRkbGVCdXR0b24oZXZlbnQpIHtcclxuXHRcdHJldHVybiAoZXZlbnQud2hpY2gpID8gZXZlbnQud2hpY2ggPT09IDIgOiBldmVudC5idXR0b24gPT09IDE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUYWtlcyBhIERPTSBldmVudCBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSByaWdodCBtb3VzZSBidXR0b24gaXMgZG93bi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIG1vdXNlIGV2ZW50LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBpcyBkb3duLlxyXG5cdCAqL1xyXG5cdGlzUmlnaHRCdXR0b24oZXZlbnQpIHtcclxuXHRcdHJldHVybiAoZXZlbnQud2hpY2gpID8gZXZlbnQud2hpY2ggPT09IDMgOiBldmVudC5idXR0b24gPT09IDI7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERPTUhhbmRsZXI7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L0V2ZW50VHlwZScpO1xyXG5jb25zdCBNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvTW91c2VFdmVudCcpO1xyXG5jb25zdCBET01IYW5kbGVyID0gcmVxdWlyZSgnLi9ET01IYW5kbGVyJyk7XHJcblxyXG4vLyBQcml2YXRlIE1ldGhvZHNcclxuXHJcbmNvbnN0IGNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24oaGFuZGxlciwgcGxvdCwgZXZlbnQpIHtcclxuXHRyZXR1cm4gbmV3IE1vdXNlRXZlbnQoXHJcblx0XHRwbG90LCAvLyB0YXJnZXRcclxuXHRcdGV2ZW50LCAvLyBvcmlnaW5hbEV2ZW50XHJcblx0XHRoYW5kbGVyLm1vdXNlVG9QbG90KGV2ZW50KSwgLy8gcG9zXHJcblx0XHRoYW5kbGVyLm1vdXNlVG9WaWV3UHgoZXZlbnQpKTsgLy8gcHhcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBtb3VzZSBoYW5kbGVyLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY2xhc3MgTW91c2VIYW5kbGVyIGV4dGVuZHMgRE9NSGFuZGxlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBNb3VzZUhhbmRsZXIgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQbG90fSBwbG90IC0gVGhlIHBsb3QgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHBsb3QpIHtcclxuXHRcdHN1cGVyKHBsb3QpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRW5hYmxlcyB0aGUgaGFuZGxlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtNb3VzZUhhbmRsZXJ9IFRoZSBoYW5kbGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGVuYWJsZSgpIHtcclxuXHRcdHN1cGVyLmVuYWJsZSgpO1xyXG5cclxuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLnBsb3Q7XHJcblxyXG5cdFx0dGhpcy5tb3VzZWRvd24gPSAoZXZlbnQpID0+IHtcclxuXHRcdFx0cGxvdC5zZXREaXJ0eSgpO1xyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLk1PVVNFX0RPV04sIGNyZWF0ZUV2ZW50KHRoaXMsIHBsb3QsIGV2ZW50KSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMubW91c2V1cCA9IChldmVudCkgPT4ge1xyXG5cdFx0XHRwbG90LnNldERpcnR5KCk7XHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuTU9VU0VfVVAsIGNyZWF0ZUV2ZW50KHRoaXMsIHBsb3QsIGV2ZW50KSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMubW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB7XHJcblx0XHRcdHBsb3Quc2V0RGlydHkoKTtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5NT1VTRV9NT1ZFLCBjcmVhdGVFdmVudCh0aGlzLCBwbG90LCBldmVudCkpO1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLm1vdXNlb3ZlciA9IChldmVudCkgPT4ge1xyXG5cdFx0XHRwbG90LnNldERpcnR5KCk7XHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuTU9VU0VfT1ZFUiwgY3JlYXRlRXZlbnQodGhpcywgcGxvdCwgZXZlbnQpKTtcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5tb3VzZW91dCA9IChldmVudCkgPT4ge1xyXG5cdFx0XHRwbG90LnNldERpcnR5KCk7XHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuTU9VU0VfT1VULCBjcmVhdGVFdmVudCh0aGlzLCBwbG90LCBldmVudCkpO1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLndoZWVsID0gKGV2ZW50KSA9PiB7XHJcblx0XHRcdHBsb3Quc2V0RGlydHkoKTtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgY29udGFpbmVyID0gcGxvdC5nZXRDb250YWluZXIoKTtcclxuXHRcdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bik7XHJcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cCk7XHJcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZW1vdmUpO1xyXG5cdFx0Y29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMubW91c2VvdmVyKTtcclxuXHRcdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMubW91c2VvdXQpO1xyXG5cdFx0Y29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy53aGVlbCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEaXNhYmxlcyB0aGUgaGFuZGxlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtNb3VzZUhhbmRsZXJ9IFRoZSBoYW5kbGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGRpc2FibGUoKSB7XHJcblx0XHRzdXBlci5kaXNhYmxlKCk7XHJcblxyXG5cdFx0Y29uc3QgY29udGFpbmVyID0gdGhpcy5wbG90LmdldENvbnRhaW5lcigpO1xyXG5cdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duKTtcclxuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZXVwKTtcclxuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlbW92ZSk7XHJcblx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5tb3VzZW92ZXIpO1xyXG5cdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5tb3VzZW91dCk7XHJcblx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLndoZWVsKTtcclxuXHRcdHRoaXMubW91c2Vkb3duID0gbnVsbDtcclxuXHRcdHRoaXMubW91c2V1cCA9IG51bGw7XHJcblx0XHR0aGlzLm1vdXNlbW92ZSA9IG51bGw7XHJcblx0XHR0aGlzLm1vdXNlb3ZlciA9IG51bGw7XHJcblx0XHR0aGlzLm1vdXNlb3V0ID0gbnVsbDtcclxuXHRcdHRoaXMud2hlZWwgPSBudWxsO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZUhhbmRsZXI7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcclxuY29uc3QgUGFuQW5pbWF0aW9uID0gcmVxdWlyZSgnLi4vYW5pbWF0aW9uL1BhbkFuaW1hdGlvbicpO1xyXG5jb25zdCBFdmVudFR5cGUgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudFR5cGUnKTtcclxuY29uc3QgRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudCcpO1xyXG5jb25zdCBET01IYW5kbGVyID0gcmVxdWlyZSgnLi9ET01IYW5kbGVyJyk7XHJcblxyXG4vLyBDb25zdGFudHNcclxuXHJcbi8qKlxyXG4gKiBUaW1lIGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgYSBwYW4gcG9pbnQgZXhwaXJlcy5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBQQU5fRVhQSVJZX01TID0gNTA7XHJcblxyXG4vKipcclxuICogUGFuIGluZXJ0aWEgZW5hYmxlZC5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtib29sZWFufVxyXG4gKi9cclxuY29uc3QgUEFOX0lOVEVSVElBID0gdHJ1ZTtcclxuXHJcbi8qKlxyXG4gKiBQYW4gaW5lcnRpYSBlYXNpbmcuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgUEFOX0lOVEVSVElBX0VBU0lORyA9IDAuMjtcclxuXHJcbi8qKlxyXG4gKiBQYW4gaW5lcnRpYSBkZWNlbGVyYXRpb24uXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgUEFOX0lOVEVSVElBX0RFQ0VMRVJBVElPTiA9IDM0MDA7XHJcblxyXG4vKipcclxuICogUGFuIHRvIGFuaW1hdGlvbiBkdXJhdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge251bWJlcn1cclxuICovXHJcbmNvbnN0IFBBTl9UT19EVVJBVElPTiA9IDgwMDtcclxuXHJcbi8vIFByaXZhdGUgTWV0aG9kc1xyXG5cclxuY29uc3QgcGFuID0gZnVuY3Rpb24ocGxvdCwgZGVsdGEpIHtcclxuXHRpZiAocGxvdC5pc1pvb21pbmcoKSkge1xyXG5cdFx0Ly8gbm8gcGFubmluZyB3aGlsZSB6b29taW5nXHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdC8vIHVwZGF0ZSBjdXJyZW50IHZpZXdwb3J0XHJcblx0cGxvdC52aWV3cG9ydC54ICs9IGRlbHRhLng7XHJcblx0cGxvdC52aWV3cG9ydC55ICs9IGRlbHRhLnk7XHJcblx0Ly8gcmVxdWVzdCB0aWxlc1xyXG5cdHBsb3QucGFuUmVxdWVzdCgpO1xyXG5cdC8vIGVtaXQgcGFuXHJcblx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU4sIG5ldyBFdmVudChwbG90KSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcGFuIGhhbmRsZXIuXHJcbiAqL1xyXG5jbGFzcyBQYW5IYW5kbGVyIGV4dGVuZHMgRE9NSGFuZGxlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBQYW5IYW5kbGVyIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0by5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBhbmltYXRpb24uXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaW5lcnRpYSAtIFdoZXRoZXIgb3Igbm90IHBhbiBpbmVydGlhIGlzIGVuYWJsZWQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaW5lcnRpYUVhc2luZyAtIFRoZSBpbmVydGlhIGVhc2luZyBmYWN0b3IuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAtIFRoZSBpbmVydGlhIGRlY2VsZXJhdGlvbiBmYWN0b3IuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocGxvdCwgb3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzdXBlcihwbG90KTtcclxuXHRcdHRoaXMuaW5lcnRpYSA9IGRlZmF1bHRUbyhvcHRpb25zLmluZXJ0aWEsIFBBTl9JTlRFUlRJQSk7XHJcblx0XHR0aGlzLmluZXJ0aWFFYXNpbmcgPSBkZWZhdWx0VG8ob3B0aW9ucy5pbmVydGlhRWFzaW5nLCBQQU5fSU5URVJUSUFfRUFTSU5HKTtcclxuXHRcdHRoaXMuaW5lcnRpYURlY2VsZXJhdGlvbiA9IGRlZmF1bHRUbyhvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24sIFBBTl9JTlRFUlRJQV9ERUNFTEVSQVRJT04pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRW5hYmxlcyB0aGUgaGFuZGxlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQYW5IYW5kbGVyfSBUaGUgaGFuZGxlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRlbmFibGUoKSB7XHJcblx0XHRzdXBlci5lbmFibGUoKTtcclxuXHJcblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xyXG5cclxuXHRcdGxldCBkb3duID0gZmFsc2U7XHJcblx0XHRsZXQgbGFzdFBvcyA9IG51bGw7XHJcblx0XHRsZXQgbGFzdFRpbWUgPSBudWxsO1xyXG5cdFx0bGV0IHBvc2l0aW9ucyA9IFtdO1xyXG5cdFx0bGV0IHRpbWVzID0gW107XHJcblxyXG5cdFx0dGhpcy5tb3VzZWRvd24gPSAoZXZlbnQpID0+IHtcclxuXHRcdFx0Ly8gaWdub3JlIGlmIHJpZ2h0LWJ1dHRvblxyXG5cdFx0XHRpZiAoIXRoaXMuaXNMZWZ0QnV0dG9uKGV2ZW50KSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBmbGFnIGFzIGRvd25cclxuXHRcdFx0ZG93biA9IHRydWU7XHJcblx0XHRcdC8vIHNldCBwb3NpdGlvbiBhbmQgdGltZXN0YW1wXHJcblx0XHRcdGxhc3RQb3MgPSB0aGlzLm1vdXNlVG9WaWV3UHgoZXZlbnQpO1xyXG5cdFx0XHRsYXN0VGltZSA9IERhdGUubm93KCk7XHJcblx0XHRcdGlmICh0aGlzLmluZXJ0aWEpIHtcclxuXHRcdFx0XHQvLyBjbGVhciBleGlzdGluZyBwYW4gYW5pbWF0aW9uXHJcblx0XHRcdFx0cGxvdC5wYW5BbmltYXRpb24gPSBudWxsO1xyXG5cdFx0XHRcdC8vIHJlc2V0IHBvc2l0aW9uIGFuZCB0aW1lIGFycmF5c1xyXG5cdFx0XHRcdHBvc2l0aW9ucyA9IFtdO1xyXG5cdFx0XHRcdHRpbWVzID0gW107XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5tb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcclxuXHRcdFx0aWYgKGRvd24pIHtcclxuXHRcdFx0XHQvLyBnZXQgbGF0ZXN0IHBvc2l0aW9uIGFuZCB0aW1lc3RhbXBcclxuXHRcdFx0XHRsZXQgcG9zID0gdGhpcy5tb3VzZVRvVmlld1B4KGV2ZW50KTtcclxuXHRcdFx0XHRsZXQgdGltZSA9IERhdGUubm93KCk7XHJcblxyXG5cdFx0XHRcdGlmIChwb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHQvLyBlbWl0IHBhbiBzdGFydFxyXG5cdFx0XHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU5fU1RBUlQsIG5ldyBFdmVudChwbG90KSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5pbmVydGlhKSB7XHJcblx0XHRcdFx0XHQvLyBhZGQgdG8gcG9zaXRpb24gYW5kIHRpbWUgYXJyYXlzXHJcblx0XHRcdFx0XHRwb3NpdGlvbnMucHVzaChwb3MpO1xyXG5cdFx0XHRcdFx0dGltZXMucHVzaCh0aW1lKTtcclxuXHRcdFx0XHRcdC8vIHByZXZlbnQgYXJyYXkgZnJvbSBnZXR0aW5nIHRvbyBiaWdcclxuXHRcdFx0XHRcdGlmICh0aW1lIC0gdGltZXNbMF0gPiBQQU5fRVhQSVJZX01TKSB7XHJcblx0XHRcdFx0XHRcdHBvc2l0aW9ucy5zaGlmdCgpO1xyXG5cdFx0XHRcdFx0XHR0aW1lcy5zaGlmdCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbmFsIGRlbHRhXHJcblx0XHRcdFx0Y29uc3QgZGVsdGEgPSB7XHJcblx0XHRcdFx0XHR4OiBsYXN0UG9zLnggLSBwb3MueCxcclxuXHRcdFx0XHRcdHk6IGxhc3RQb3MueSAtIHBvcy55XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHQvLyBwYW4gdGhlIHBsb3RcclxuXHRcdFx0XHRwYW4ocGxvdCwgdGhpcy52aWV3UHhUb1Bsb3QoZGVsdGEpKTtcclxuXHRcdFx0XHQvLyB1cGRhdGUgbGFzdCBwb3NpdGlvbiBhbmQgdGltZVxyXG5cdFx0XHRcdGxhc3RUaW1lID0gdGltZTtcclxuXHRcdFx0XHRsYXN0UG9zID0gcG9zO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMubW91c2V1cCA9IChldmVudCkgPT4ge1xyXG5cclxuXHRcdFx0Ly8gZmxhZyBhcyB1cFxyXG5cdFx0XHRkb3duID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAocGxvdC5pc1pvb21pbmcoKSkge1xyXG5cdFx0XHRcdC8vIG5vIHBhbm5pbmcgd2hpbGUgem9vbWluZ1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaWdub3JlIGlmIHJpZ2h0LWJ1dHRvblxyXG5cdFx0XHRpZiAoIXRoaXMuaXNMZWZ0QnV0dG9uKGV2ZW50KSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaWdub3JlIGlmIG5vIGRyYWcgb2NjdXJyZWRcclxuXHRcdFx0aWYgKHBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghdGhpcy5pbmVydGlhKSB7XHJcblx0XHRcdFx0Ly8gZXhpdCBlYXJseSBpZiBubyBpbmVydGlhIG9yIG5vIG1vdmVtZW50XHJcblx0XHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU5fRU5ELCBuZXcgRXZlbnQocGxvdCkpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZ2V0IHRpbWVzdGFtcFxyXG5cdFx0XHRjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcclxuXHJcblx0XHRcdC8vIHN0cmlwIGFueSBwb3NpdGlvbnMgdGhhdCBhcmUgdG9vIG9sZFxyXG5cdFx0XHR3aGlsZSAodGltZSAtIHRpbWVzWzBdID4gUEFOX0VYUElSWV9NUykge1xyXG5cdFx0XHRcdHBvc2l0aW9ucy5zaGlmdCgpO1xyXG5cdFx0XHRcdHRpbWVzLnNoaWZ0KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aW1lcy5sZW5ndGggPCAyKSB7XHJcblx0XHRcdFx0Ly8gZXhpdCBlYXJseSBpZiBubyByZW1haW5pbmcgdmFsaWQgcG9zaXRpb25zXHJcblx0XHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU5fRU5ELCBuZXcgRXZlbnQocGxvdCkpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2hvcnRoYW5kXHJcblx0XHRcdGNvbnN0IGRlY2VsZXJhdGlvbiA9IHRoaXMuaW5lcnRpYURlY2VsZXJhdGlvbjtcclxuXHRcdFx0Y29uc3QgZWFzaW5nID0gdGhpcy5pbmVydGlhRWFzaW5nO1xyXG5cclxuXHRcdFx0Ly8gY2FsY3VsYXRlIGRpcmVjdGlvbiBmcm9tIGVhcmxpZXN0IHRvIGxhdGVzdFxyXG5cdFx0XHRjb25zdCBkaXJlY3Rpb24gPSB7XHJcblx0XHRcdFx0eDogbGFzdFBvcy54IC0gcG9zaXRpb25zWzBdLngsXHJcblx0XHRcdFx0eTogbGFzdFBvcy55IC0gcG9zaXRpb25zWzBdLnlcclxuXHRcdFx0fTtcclxuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSB0aW1lIGRpZmZlcmVuY2VcclxuXHRcdFx0Y29uc3QgZGlmZiA9ICgobGFzdFRpbWUgLSB0aW1lc1swXSkgfHwgMSkgLyAxMDAwOyAvLyBtcyB0byBzXHJcblx0XHRcdC8vIGNhbGN1bGF0ZSB2ZWxvY2l0eVxyXG5cdFx0XHRjb25zdCB2ZWxvY2l0eSA9IHtcclxuXHRcdFx0XHR4OiBkaXJlY3Rpb24ueCAqIChlYXNpbmcgLyBkaWZmKSxcclxuXHRcdFx0XHR5OiBkaXJlY3Rpb24ueSAqIChlYXNpbmcgLyBkaWZmKVxyXG5cdFx0XHR9O1xyXG5cdFx0XHQvLyBjYWxjdWxhdGUgc3BlZWRcclxuXHRcdFx0Y29uc3Qgc3BlZWQgPSBNYXRoLnNxcnQoXHJcblx0XHRcdFx0KHZlbG9jaXR5LnggKiB2ZWxvY2l0eS54KSArXHJcblx0XHRcdFx0KHZlbG9jaXR5LnkgKiB2ZWxvY2l0eS55KSk7XHJcblx0XHRcdC8vIGNhbGN1bGF0ZSBwYW5uaW5nIGR1cmF0aW9uXHJcblx0XHRcdGNvbnN0IGR1cmF0aW9uID0gc3BlZWQgLyAoZGVjZWxlcmF0aW9uICogZWFzaW5nKTtcclxuXHRcdFx0Ly8gY2FsY3VsYXRlIGluZXJ0aWEgZGVsdGFcclxuXHRcdFx0Y29uc3QgZGVsdGEgPSB7XHJcblx0XHRcdFx0eDogTWF0aC5yb3VuZCh2ZWxvY2l0eS54ICogKC1kdXJhdGlvbiAvIDIpKSxcclxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKHZlbG9jaXR5LnkgKiAoLWR1cmF0aW9uIC8gMikpXHJcblx0XHRcdH07XHJcblx0XHRcdC8vIHNldCBwYW4gYW5pbWF0aW9uXHJcblx0XHRcdHBsb3QucGFuQW5pbWF0aW9uID0gbmV3IFBhbkFuaW1hdGlvbih7XHJcblx0XHRcdFx0cGxvdDogcGxvdCxcclxuXHRcdFx0XHRzdGFydDogcGxvdC5nZXRWaWV3cG9ydFBvc2l0aW9uKCksXHJcblx0XHRcdFx0ZGVsdGE6IHRoaXMudmlld1B4VG9QbG90KGRlbHRhKSxcclxuXHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcclxuXHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24gKiAxMDAwIC8vIHMgdG8gbXNcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGNvbnRhaW5lciA9IHBsb3QuZ2V0Q29udGFpbmVyKCk7XHJcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd24pO1xyXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZW1vdmUpO1xyXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEaXNhYmxlcyB0aGUgaGFuZGxlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQYW5IYW5kbGVyfSBUaGUgaGFuZGxlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRkaXNhYmxlKCkge1xyXG5cdFx0c3VwZXIuZGlzYWJsZSgpO1xyXG5cclxuXHRcdGNvbnN0IGNvbnRhaW5lciA9IHRoaXMucGxvdC5nZXRDb250YWluZXIoKTtcclxuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bik7XHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlbW92ZSk7XHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZXVwKTtcclxuXHRcdHRoaXMubW91c2Vkb3duID0gbnVsbDtcclxuXHRcdHRoaXMubW91c2Vtb3ZlID0gbnVsbDtcclxuXHRcdHRoaXMubW91c2V1cCA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBQYW5zIHRvIHRoZSB0YXJnZXQgcGxvdCBjb29yZGluYXRlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBvcyAtIFRoZSB0YXJnZXQgcGxvdCBwb3NpdGlvbi5cclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGUgLSBXaGV0aGVyIG9yIG5vdCB0byBhbmltYXRlIHRoZSBwYW4uIERlZmF1bHRzIHRvIGB0cnVlYC5cclxuXHQgKi9cclxuXHRwYW5Ubyhwb3MsIGFuaW1hdGUgPSB0cnVlKSB7XHJcblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xyXG5cdFx0Y29uc3QgY2VudGVyID0gcGxvdC5nZXRWaWV3cG9ydENlbnRlcigpO1xyXG5cdFx0Y29uc3QgZGVsdGEgPSB7XHJcblx0XHRcdHg6IHBvcy54IC0gY2VudGVyLngsXHJcblx0XHRcdHk6IHBvcy55IC0gY2VudGVyLnlcclxuXHRcdH07XHJcblx0XHRpZiAoIWFuaW1hdGUpIHtcclxuXHRcdFx0Ly8gZG8gbm90IGFuaW1hdGVcclxuXHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU5fU1RBUlQsIG5ldyBFdmVudChwbG90KSk7XHJcblx0XHRcdHBhbihwbG90LCBkZWx0YSk7XHJcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuUEFOX0VORCwgbmV3IEV2ZW50KHBsb3QpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGFuaW1hdGUgcGFuXHJcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuUEFOX1NUQVJULCBuZXcgRXZlbnQocGxvdCkpO1xyXG5cdFx0XHRwbG90LnBhbkFuaW1hdGlvbiA9IG5ldyBQYW5BbmltYXRpb24oe1xyXG5cdFx0XHRcdHBsb3Q6IHBsb3QsXHJcblx0XHRcdFx0c3RhcnQ6IHBsb3QuZ2V0Vmlld3BvcnRQb3NpdGlvbigpLFxyXG5cdFx0XHRcdGRlbHRhOiBkZWx0YSxcclxuXHRcdFx0XHRlYXNpbmc6IHRoaXMuaW5lcnRpYUVhc2luZyxcclxuXHRcdFx0XHRkdXJhdGlvbjogUEFOX1RPX0RVUkFUSU9OXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYW5IYW5kbGVyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBjbGFtcCA9IHJlcXVpcmUoJ2xvZGFzaC9jbGFtcCcpO1xyXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XHJcbmNvbnN0IEJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlsL0Jyb3dzZXInKTtcclxuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnRUeXBlJyk7XHJcbmNvbnN0IEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnQnKTtcclxuY29uc3QgWm9vbUFuaW1hdGlvbiA9IHJlcXVpcmUoJy4uL2FuaW1hdGlvbi9ab29tQW5pbWF0aW9uJyk7XHJcbmNvbnN0IFZpZXdwb3J0ID0gcmVxdWlyZSgnLi4vVmlld3BvcnQnKTtcclxuY29uc3QgRE9NSGFuZGxlciA9IHJlcXVpcmUoJy4vRE9NSGFuZGxlcicpO1xyXG5cclxuLy8gQ29uc3RhbnRzXHJcblxyXG4vKipcclxuICogQW1vdW50IG9mIHNjcm9sbCBwaXhlbHMgcGVyIHpvb20gbGV2ZWwuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgWk9PTV9XSEVFTF9ERUxUQSA9IDMwMDtcclxuXHJcbi8qKlxyXG4gKiBMZW5ndGggb2Ygem9vbSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge251bWJlcn1cclxuICovXHJcbmNvbnN0IFpPT01fQU5JTUFUSU9OX01TID0gMjUwO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gY29uY3VycmVudCBkaXNjcmV0ZSB6b29tcyBpbiBhIHNpbmdsZSBiYXRjaC5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBNQVhfQ09OQ1VSUkVOVF9aT09NUyA9IDQ7XHJcblxyXG4vKipcclxuICogWm9vbSBkZWJvdW5jZSBkZWxheSBpbiBtaWxpc2Vjb25kcy5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBaT09NX0RFQk9VTkNFX01TID0gMTAwO1xyXG5cclxuLyoqXHJcbiAqIENvbnRpbnVvdXMgem9vbSBlbmFibGVkLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge2Jvb2xlYW59XHJcbiAqL1xyXG5jb25zdCBDT05USU5VT1VTX1pPT00gPSBmYWxzZTtcclxuXHJcbi8vIFByaXZhdGUgTWV0aG9kc1xyXG5cclxubGV0IGxhc3QgPSBEYXRlLm5vdygpO1xyXG5jb25zdCBza2lwSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uKGFuaW1hdGlvbiwgZGVsdGEpIHtcclxuXHQvLyBOT1RFOiBhdHRlbXB0IHRvIGRldGVybWluZSBpZiB0aGUgc2Nyb2xsIGRldmljZSBpcyBhIG1vdXNlIG9yIGFcclxuXHQvLyB0cmFja3BhZC4gTW91c2Ugc2Nyb2xsaW5nIGNyZWF0ZXMgbGFyZ2UgaW5mcmVxdWVudCBkZWx0YXMgd2hpbGVcclxuXHQvLyB0cmFja3BhZHMgY3JlYXRlIHRvbnMgb2YgdmVyeSBzbWFsbCBkZWx0YXMuIFdlIHdhbnQgdG8gaW50ZXJwb2xhdGVcclxuXHQvLyBiZXR3ZWVuIHdoZWVsIGV2ZW50cywgYnV0IG5vdCBiZXR3ZWVuIHRyYWNrcGFkIGV2ZW50cy5cclxuXHRjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG5cdGNvbnN0IHRkZWx0YSA9IG5vdyAtIGxhc3Q7XHJcblx0bGFzdCA9IG5vdztcclxuXHRpZiAoZGVsdGEgJSA0LjAwMDI0NDE0MDYyNSA9PT0gMCkge1xyXG5cdFx0Ly8gZGVmaW5pdGVseSBhIHdoZWVsLCBpbnRlcnBvbGF0ZVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRpZiAoTWF0aC5hYnMoZGVsdGEpIDwgNCkge1xyXG5cdFx0Ly8gZGVmaW5pdGVseSB0cmFjayBwYWQsIGRvIG5vdCBpbnRlcnBvbGF0ZVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLmR1cmF0aW9uICE9PSAwKSB7XHJcblx0XHQvLyBjdXJyZW50IGFuaW1hdGlvbiBoYXMgaW50ZXJwb2xhdGlvbiwgc2hvdWxkIHByb2JhYmx5IGludGVycG9sYXRlXHJcblx0XHQvLyB0aGUgbmV4dCBhbmltYXRpb24gdG9vLlxyXG5cdFx0Ly8gTk9URTogd2l0aG91dCB0aGlzLCByYXBpZCB3aGVlbCBzY3JvbGxpbmcgd2lsbCB0cmlnZ2VyIHRoZSBza2lwXHJcblx0XHQvLyBiZWxvd1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRpZiAodGRlbHRhIDwgNDApIHtcclxuXHRcdC8vIGV2ZW50cyBhcmUgY2xvc2UgZW5vdWdoIHRvZ2V0aGVyIHRoYXQgd2Ugc2hvdWxkIHByb2JhYmx5XHJcblx0XHQvLyBub3QgaW50ZXJwb2xhdGVcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5jb25zdCBjb21wdXRlWm9vbURlbHRhID0gZnVuY3Rpb24od2hlZWxEZWx0YSwgY29udGludW91c1pvb20sIGRlbHRhUGVyWm9vbSwgbWF4Wm9vbXMpIHtcclxuXHRsZXQgem9vbURlbHRhID0gd2hlZWxEZWx0YSAvIGRlbHRhUGVyWm9vbTtcclxuXHRpZiAoIWNvbnRpbnVvdXNab29tKSB7XHJcblx0XHQvLyBzbmFwIHZhbHVlIGlmIG5vdCBjb250aW51b3VzIHpvb21cclxuXHRcdGlmICh3aGVlbERlbHRhID4gMCkge1xyXG5cdFx0XHR6b29tRGVsdGEgPSBNYXRoLmNlaWwoem9vbURlbHRhKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHpvb21EZWx0YSA9IE1hdGguZmxvb3Ioem9vbURlbHRhKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gY2xhbXAgem9vbSBkZWx0YSB0byBtYXggY29uY3VycmVudCB6b29tc1xyXG5cdHJldHVybiBjbGFtcCh6b29tRGVsdGEsIC1tYXhab29tcywgbWF4Wm9vbXMpO1xyXG59O1xyXG5cclxuY29uc3QgY29tcHV0ZVRhcmdldFpvb20gPSBmdW5jdGlvbih6b29tRGVsdGEsIGN1cnJlbnRab29tLCBjdXJyZW50QW5pbWF0aW9uLCBtaW5ab29tLCBtYXhab29tKSB7XHJcblx0bGV0IHRhcmdldFpvb207XHJcblx0aWYgKGN1cnJlbnRBbmltYXRpb24pIHtcclxuXHRcdC8vIGFwcGVuZCB0byBleGlzdGluZyBhbmltYXRpb24gdGFyZ2V0XHJcblx0XHR0YXJnZXRab29tID0gY3VycmVudEFuaW1hdGlvbi50YXJnZXRab29tICsgem9vbURlbHRhO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0YXJnZXRab29tID0gY3VycmVudFpvb20gKyB6b29tRGVsdGE7XHJcblx0fVxyXG5cdC8vIGNsYW1wIHRoZSB0YXJnZXQgem9vbSB0byBtaW4gYW5kIG1heCB6b29tIGxldmVsIG9mIHBsb3RcclxuXHRyZXR1cm4gY2xhbXAodGFyZ2V0Wm9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XHJcbn07XHJcblxyXG5jb25zdCB6b29tID0gZnVuY3Rpb24ocGxvdCwgdGFyZ2V0UG9zLCB6b29tRGVsdGEsIGR1cmF0aW9uLCByZWxhdGl2ZSA9IHRydWUpIHtcclxuXHQvLyBjYWxjdWxhdGUgdGFyZ2V0IHpvb20gbGV2ZWxcclxuXHRjb25zdCB0YXJnZXRab29tID0gY29tcHV0ZVRhcmdldFpvb20oXHJcblx0XHR6b29tRGVsdGEsXHJcblx0XHRwbG90Lnpvb20sXHJcblx0XHRwbG90Lnpvb21BbmltYXRpb24sXHJcblx0XHRwbG90Lm1pblpvb20sXHJcblx0XHRwbG90Lm1heFpvb20pO1xyXG4gIC8vIHNldCB0YXJnZXQgdmlld3BvcnRcclxuXHRjb25zdCB0YXJnZXRWaWV3cG9ydCA9IHBsb3Qudmlld3BvcnQuem9vbVRvUG9zKFxyXG5cdFx0cGxvdC56b29tLFxyXG5cdFx0dGFyZ2V0Wm9vbSxcclxuXHRcdHRhcmdldFBvcyxcclxuXHRcdHJlbGF0aXZlKTtcclxuXHQvLyBnZXQgcHJldmlvdXMgdGFyZ2V0c1xyXG5cdGNvbnN0IHByZXZUYXJnZXRab29tID0gcGxvdC5nZXRUYXJnZXRab29tKCk7XHJcblx0Y29uc3QgcHJldlRhcmdldFZpZXdwb3J0ID0gcGxvdC5nZXRUYXJnZXRWaWV3cG9ydCgpO1xyXG5cdC8vIG9ubHkgcHJvY2VzcyB6b29tIGlmIGl0IGlzIHJlcXVpcmVkXHJcblx0aWYgKHRhcmdldFpvb20gIT09IHByZXZUYXJnZXRab29tIHx8XHJcblx0XHRcdHRhcmdldFZpZXdwb3J0LnggIT09IHByZXZUYXJnZXRWaWV3cG9ydC54IHx8XHJcblx0XHRcdHRhcmdldFZpZXdwb3J0LnkgIT09IHByZXZUYXJnZXRWaWV3cG9ydC55KSB7XHJcblx0XHQvLyBjbGVhciBwYW4gYW5pbWF0aW9uXHJcblx0XHRwbG90LnBhbkFuaW1hdGlvbiA9IG51bGw7XHJcblx0XHQvLyBpZiB0aGVyZSBpcyBhIGR1cmF0aW9uXHJcblx0XHRpZiAoZHVyYXRpb24gPiAwKSB7XHJcblx0XHRcdC8vIHNldCB6b29tIGFuaW1hdGlvblxyXG5cdFx0XHRwbG90Lnpvb21BbmltYXRpb24gPSBuZXcgWm9vbUFuaW1hdGlvbih7XHJcblx0XHRcdFx0cGxvdDogcGxvdCxcclxuXHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXHJcblx0XHRcdFx0cHJldlpvb206IHBsb3Quem9vbSxcclxuXHRcdFx0XHR0YXJnZXRab29tOiB0YXJnZXRab29tLFxyXG5cdFx0XHRcdHByZXZWaWV3cG9ydDogbmV3IFZpZXdwb3J0KFxyXG5cdFx0XHRcdFx0XHRwbG90LnZpZXdwb3J0LngsXHJcblx0XHRcdFx0XHRcdHBsb3Qudmlld3BvcnQueSxcclxuXHRcdFx0XHRcdFx0cGxvdC52aWV3cG9ydC53aWR0aCxcclxuXHRcdFx0XHRcdFx0cGxvdC52aWV3cG9ydC5oZWlnaHQpLFxyXG5cdFx0XHRcdHRhcmdldFZpZXdwb3J0OiB0YXJnZXRWaWV3cG9ydCxcclxuXHRcdFx0XHR0YXJnZXRQb3M6IHRhcmdldFBvc1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdC8vIGVtaXQgem9vbSBzdGFydFxyXG5cdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5aT09NX1NUQVJULCBuZXcgRXZlbnQocGxvdCkpO1xyXG5cdFx0Ly8gaWYgdGhlcmUgaXNuJ3QgYSBkdXJhdGlvblxyXG5cdFx0aWYgKGR1cmF0aW9uID09PSAwKSB7XHJcblx0XHRcdC8vIGltbWVkaWF0ZWx5IHVwZGF0ZSBwbG90XHJcblx0XHRcdHBsb3Quem9vbSA9IHRhcmdldFpvb207XHJcblx0XHRcdHBsb3Qudmlld3BvcnQgPSB0YXJnZXRWaWV3cG9ydDtcclxuXHRcdFx0Ly8gZW1pdCB6b29tIGVuZFxyXG5cdFx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLlpPT01fRU5ELCBuZXcgRXZlbnQocGxvdCkpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gcmVxdWVzdCB0aWxlc1xyXG5cdFx0cGxvdC56b29tUmVxdWVzdCgpO1xyXG5cdH1cclxufTtcclxuXHJcbmNvbnN0IHpvb21Gcm9tV2hlZWwgPSBmdW5jdGlvbihoYW5kbGVyLCBwbG90LCB0YXJnZXRQb3MsIHdoZWVsRGVsdGEsIGNvbnRpbnVvdXNab29tKSB7XHJcblx0Ly8gbm8gd2hlZWwgZGVsdGEsIGV4aXQgZWFybHlcclxuXHRpZiAod2hlZWxEZWx0YSA9PT0gMCkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHQvLyBjYWxjdWxhdGUgem9vbSBkZWx0YSBmcm9tIHdoZWVsIGRlbHRhXHJcblx0Y29uc3Qgem9vbURlbHRhID0gY29tcHV0ZVpvb21EZWx0YShcclxuXHRcdHdoZWVsRGVsdGEsXHJcblx0XHRjb250aW51b3VzWm9vbSxcclxuXHRcdGhhbmRsZXIuZGVsdGFQZXJab29tLFxyXG5cdFx0aGFuZGxlci5tYXhDb25jdXJyZW50Wm9vbXMpO1xyXG5cdC8vIGdldCBkdXJhdGlvblxyXG5cdGxldCBkdXJhdGlvbiA9IGhhbmRsZXIuem9vbUR1cmF0aW9uO1xyXG5cdGlmIChjb250aW51b3VzWm9vbSAmJiBza2lwSW50ZXJwb2xhdGlvbihwbG90Lnpvb21BbmltYXRpb24sIHdoZWVsRGVsdGEpKSB7XHJcblx0XHQvLyBza2lwIGFuaW1hdGlvbiBpbnRlcnBvbGF0aW9uXHJcblx0XHRkdXJhdGlvbiA9IDA7XHJcblx0fVxyXG5cdC8vIHByb2Nlc3MgdGhlIHpvb21cclxuXHR6b29tKHBsb3QsIHRhcmdldFBvcywgem9vbURlbHRhLCBkdXJhdGlvbik7XHJcbn07XHJcblxyXG5jb25zdCBnZXRXaGVlbERlbHRhID0gZnVuY3Rpb24ocGxvdCwgZXZlbnQpIHtcclxuXHRpZiAoZXZlbnQuZGVsdGFNb2RlID09PSAwKSB7XHJcblx0XHQvLyBwaXhlbHNcclxuXHRcdGlmIChCcm93c2VyLmZpcmVmb3gpIHtcclxuXHRcdFx0cmV0dXJuIC1ldmVudC5kZWx0YVkgLyBwbG90LnBpeGVsUmF0aW87XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLWV2ZW50LmRlbHRhWTtcclxuXHR9IGVsc2UgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSkge1xyXG5cdFx0Ly8gbGluZXNcclxuXHRcdHJldHVybiAtZXZlbnQuZGVsdGFZICogMjA7XHJcblx0fVxyXG5cdC8vIHBhZ2VzXHJcblx0cmV0dXJuIC1ldmVudC5kZWx0YVkgKiA2MDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB6b29tIGhhbmRsZXIuXHJcbiAqL1xyXG5jbGFzcyBab29tSGFuZGxlciBleHRlbmRzIERPTUhhbmRsZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgWm9vbUhhbmRsZXIgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQbG90fSBwbG90IC0gVGhlIHBsb3QgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBhcmFtZXRlcnMgb2YgdGhlIGFuaW1hdGlvbi5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jb250aW51b3VzWm9vbSAtIFdoZXRoZXIgb3Igbm90IGNvbnRpbnVvdXMgem9vbSBpcyBlbmFibGVkLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpvb21EdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgem9vbSBhbmltYXRpb24uXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4Q29uY3VycmVudFpvb21zIC0gVGhlIG1heGltdW0gY29uY3VycmVudCB6b29tcyBpbiBhIHNpbmdsZSBiYXRjaC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5kZWx0YVBlclpvb20gLSBUaGUgc2Nyb2xsIGRlbHRhIHJlcXVpcmVkIHBlciB6b29tIGxldmVsLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpvb21EZWJvdW5jZSAtIFRoZSBkZWJvdW5jZSBkdXJhdGlvbiBvZiB0aGUgem9vbSBpbiBtcy5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihwbG90LCBvcHRpb25zID0ge30pIHtcclxuXHRcdHN1cGVyKHBsb3QpO1xyXG5cdFx0dGhpcy5jb250aW51b3VzWm9vbSA9IGRlZmF1bHRUbyhvcHRpb25zLmNvbnRpbnVvdXNab29tLCBDT05USU5VT1VTX1pPT00pO1xyXG5cdFx0dGhpcy56b29tRHVyYXRpb24gPSBkZWZhdWx0VG8ob3B0aW9ucy56b29tRHVyYXRpb24sIFpPT01fQU5JTUFUSU9OX01TKTtcclxuXHRcdHRoaXMubWF4Q29uY3VycmVudFpvb21zID0gZGVmYXVsdFRvKG9wdGlvbnMubWF4Q29uY3VycmVudFpvb21zLCBNQVhfQ09OQ1VSUkVOVF9aT09NUyk7XHJcblx0XHR0aGlzLmRlbHRhUGVyWm9vbSA9IGRlZmF1bHRUbyhvcHRpb25zLmRlbHRhUGVyWm9vbSwgWk9PTV9XSEVFTF9ERUxUQSk7XHJcblx0XHR0aGlzLnpvb21EZWJvdW5jZSA9IGRlZmF1bHRUbyhvcHRpb25zLnpvb21EZWJvdW5jZSwgWk9PTV9ERUJPVU5DRV9NUyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFbmFibGVzIHRoZSBoYW5kbGVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1pvb21IYW5kbGVyfSBUaGUgaGFuZGxlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRlbmFibGUoKSB7XHJcblx0XHRzdXBlci5lbmFibGUoKTtcclxuXHJcblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xyXG5cclxuXHRcdGxldCB3aGVlbERlbHRhID0gMDtcclxuXHRcdGxldCB0aW1lb3V0ID0gbnVsbDtcclxuXHRcdGxldCBldnQgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZGJsY2xpY2sgPSAoZXZlbnQpID0+IHtcclxuXHRcdFx0Ly8gZ2V0IG1vdXNlIHBvc2l0aW9uXHJcblx0XHRcdGNvbnN0IHRhcmdldFBvcyA9IHRoaXMubW91c2VUb1Bsb3QoZXZlbnQpO1xyXG5cdFx0XHQvLyB6b29tIHRoZSBwbG90IGJ5IG9uZSBsZXZlbFxyXG5cdFx0XHR6b29tKHBsb3QsIHRhcmdldFBvcywgMSwgdGhpcy56b29tRHVyYXRpb24pO1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLndoZWVsID0gKGV2ZW50KSA9PiB7XHJcblx0XHRcdC8vIGdldCBub3JtYWxpemVkIGRlbHRhXHJcblx0XHRcdGNvbnN0IGRlbHRhID0gZ2V0V2hlZWxEZWx0YShwbG90LCBldmVudCk7XHJcblx0XHRcdGlmICghdGhpcy5jb250aW51b3VzWm9vbSAmJiBNYXRoLmFicyhkZWx0YSkgPCA0KSB7XHJcblx0XHRcdFx0Ly8gbWl0aWdhdGUgdGhlIGh5cGVyIHNlbnNpdGl2dHkgb2YgYSB0cmFja3BhZFxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBpbmNyZW1lbnQgd2hlZWwgZGVsdGFcclxuXHRcdFx0d2hlZWxEZWx0YSArPSBkZWx0YTtcclxuXHRcdFx0Ly8gY2hlY2sgem9vbSB0eXBlXHJcblx0XHRcdGlmICh0aGlzLmNvbnRpbnVvdXNab29tKSB7XHJcblx0XHRcdFx0Ly8gZ2V0IHRhcmdldCBmcm9tIG1vdXNlIHBvc2l0aW9uXHJcblx0XHRcdFx0Y29uc3QgdGFyZ2V0UG9zID0gdGhpcy5tb3VzZVRvUGxvdChldmVudCk7XHJcblx0XHRcdFx0Ly8gcHJvY2VzcyBjb250aW51b3VzIHpvb20gaW1tZWRpYXRlbHlcclxuXHRcdFx0XHR6b29tRnJvbVdoZWVsKHRoaXMsIHBsb3QsIHRhcmdldFBvcywgd2hlZWxEZWx0YSwgdHJ1ZSk7XHJcblx0XHRcdFx0Ly8gcmVzZXQgd2hlZWwgZGVsdGFcclxuXHRcdFx0XHR3aGVlbERlbHRhID0gMDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBzZXQgZXZlbnRcclxuXHRcdFx0XHRldnQgPSBldmVudDtcclxuXHRcdFx0XHQvLyBkZWJvdW5jZSBkaXNjcmV0ZSB6b29tXHJcblx0XHRcdFx0aWYgKCF0aW1lb3V0KSB7XHJcblx0XHRcdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdC8vIGdldCB0YXJnZXQgcG9zaXRpb24gZnJvbSBtb3VzZSBwb3NpdGlvblxyXG5cdFx0XHRcdFx0XHQvLyBOT1RFOiB0aGlzIGlzIGNhbGxlZCBpbnNpZGUgdGhlIGNsb3N1cmUgdG8gZW5zdXJlXHJcblx0XHRcdFx0XHRcdC8vIHRoYXQgd2UgdXNlIHRoZSBjdXJyZW50IHZpZXdwb3J0IG9mIHRoZSBwbG90IHRvXHJcblx0XHRcdFx0XHRcdC8vIGNvbnZlcnQgZnJvbSBtb3VzZSB0byBwbG90IHBpeGVsc1xyXG5cdFx0XHRcdFx0XHRjb25zdCB0YXJnZXRQb3MgPSB0aGlzLm1vdXNlVG9QbG90KGV2dCk7XHJcblx0XHRcdFx0XHRcdC8vIHByb2Nlc3Mgem9vbSBldmVudFxyXG5cdFx0XHRcdFx0XHR6b29tRnJvbVdoZWVsKHRoaXMsIHBsb3QsIHRhcmdldFBvcywgd2hlZWxEZWx0YSwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHQvLyByZXNldCB3aGVlbCBkZWx0YVxyXG5cdFx0XHRcdFx0XHR3aGVlbERlbHRhID0gMDtcclxuXHRcdFx0XHRcdFx0Ly8gY2xlYXIgdGltZW91dFxyXG5cdFx0XHRcdFx0XHR0aW1lb3V0ID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0Ly8gY2xlYXIgZXZlbnRcclxuXHRcdFx0XHRcdFx0ZXZ0ID0gbnVsbDtcclxuXHRcdFx0XHRcdH0sIHRoaXMuem9vbURlYm91bmNlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gcHJldmVudCBkZWZhdWx0IGJlaGF2aW9yIGFuZCBzdG9wIHByb3BhZ2F0aW9uYVxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgY29udGFpbmVyID0gcGxvdC5nZXRDb250YWluZXIoKTtcclxuXHRcdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuZGJsY2xpY2spO1xyXG5cdFx0Y29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy53aGVlbCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEaXNhYmxlcyB0aGUgaGFuZGxlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtab29tSGFuZGxlcn0gVGhlIGhhbmRsZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZGlzYWJsZSgpIHtcclxuXHRcdHN1cGVyLmRpc2FibGUoKTtcclxuXHJcblx0XHRjb25zdCBjb250YWluZXIgPSB0aGlzLnBsb3QuZ2V0Q29udGFpbmVyKCk7XHJcblx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLmRibGNsaWNrKTtcclxuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMud2hlZWwpO1xyXG5cdFx0dGhpcy5kYmxjbGljayA9IG51bGw7XHJcblx0XHR0aGlzLndoZWVsID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFpvb21zIGluIHRvIHRoZSB0YXJnZXQgem9vbSBsZXZlbC4gVGhpcyBpcyBib3VuZGVkIGJ5IHRoZSBwbG90IG9iamVjdHNcclxuXHQgKiBtaW5ab29tIGFuZCBtYXhab29tIGF0dHJpYnV0ZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSBUaGUgdGFyZ2V0IHpvb20gbGV2ZWwuXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBhbmltYXRlIC0gV2hldGhlciBvciBub3QgdG8gYW5pbWF0ZSB0aGUgem9vbS4gRGVmYXVsdHMgdG8gYHRydWVgLlxyXG5cdCAqL1xyXG5cdHpvb21UbyhsZXZlbCwgYW5pbWF0ZSA9IHRydWUpIHtcclxuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLnBsb3Q7XHJcblx0XHRjb25zdCB0YXJnZXRQb3MgPSB0aGlzLnBsb3QuZ2V0Vmlld3BvcnRDZW50ZXIoKTtcclxuXHRcdGNvbnN0IHpvb21EZWx0YSA9IGxldmVsIC0gcGxvdC56b29tO1xyXG5cdFx0aWYgKCFhbmltYXRlKSB7XHJcblx0XHRcdC8vIGRvIG5vdCBhbmltYXRlXHJcblx0XHRcdHpvb20ocGxvdCwgdGFyZ2V0UG9zLCB6b29tRGVsdGEsIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gYW5pbWF0ZVxyXG5cdFx0XHR6b29tKHBsb3QsIHRhcmdldFBvcywgem9vbURlbHRhLCB0aGlzLnpvb21EdXJhdGlvbik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBab29tcyB0byB0aGUgdGFyZ2V0IHpvb20gbGV2ZWwsIGFuZCBjZW50ZXJzIG9uIHRoZSB0YXJnZXQgcG9zaXRpb24uICBUaGUgem9vbSBpcyBib3VuZGVkIGJ5IHRoZSBwbG90IG9iamVjdHNcclxuXHQgKiBtaW5ab29tIGFuZCBtYXhab29tIGF0dHJpYnV0ZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSBUaGUgdGFyZ2V0IHpvb20gbGV2ZWwuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFBvcyAtIFRoZSB0YXJnZXQgY2VudGVyIHBvc2l0aW9uLlxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSAtIFdoZXRoZXIgb3Igbm90IHRvIGFuaW1hdGUgdGhlIHpvb20uIERlZmF1bHRzIHRvIGB0cnVlYC5cclxuXHQgKi9cclxuXHR6b29tVG9Qb3NpdGlvbihsZXZlbCwgdGFyZ2V0UG9zLCBhbmltYXRlID0gdHJ1ZSkge1xyXG5cdFx0Y29uc3QgcGxvdCA9IHRoaXMucGxvdDtcclxuXHRcdGNvbnN0IHpvb21EZWx0YSA9IGxldmVsIC0gcGxvdC56b29tO1xyXG5cdFx0Y29uc3QgZHVyYXRpb24gPSBhbmltYXRlID8gIHRoaXMuem9vbUR1cmF0aW9uIDogMDtcclxuXHRcdHpvb20ocGxvdCwgdGFyZ2V0UG9zLCB6b29tRGVsdGEsIGR1cmF0aW9uLCBmYWxzZSAvKiBjZW50ZXJlZCBvbiB0YXJnZXQgcG9zaXRpb24gKi8pO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBab29tSGFuZGxlcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcmVuZGVyZXIuXHJcbiAqL1xyXG5jbGFzcyBSZW5kZXJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBSZW5kZXJlciBvYmplY3QuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgdGFyZ2V0IGlzIGF0dGFjaGVkIHRvIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7dGFyZ2V0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIGF0dGFjaCB0aGUgcmVuZGVyZXIgdG8uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG5cdG9uQWRkKHRhcmdldCkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSB0YXJnZXQgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T3ZlcmxheX0gdGFyZ2V0IC0gVGhlIHRhcmdldCB0byByZW1vdmUgdGhlIHJlbmRlcmVyIGZyb20uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG5cdG9uUmVtb3ZlKHRhcmdldCkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBQaWNrIGEgcG9zaXRpb24gb2YgdGhlIGxheWVyIGZvciBhIGNvbGxpc2lvbiB3aXRoIGFueSByZW5kZXJlZCBvYmplY3RzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHBvcyAtIFRoZSBwbG90IHBvc2l0aW9uIHRvIHBpY2sgYXQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY29sbGlzaW9uLCBvciBudWxsLlxyXG5cdCAqL1xyXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcblx0cGljayhwb3MpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYXJzIGFueSBwZXJzaXN0ZWQgc3RhdGUgaW4gdGhlIHJlbmRlcmVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0Y2xlYXIoKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgcGVyIGZyYW1lLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIFRoZSBmcmFtZSB0aW1lc3RhbXAuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG5cdGRyYXcodGltZXN0YW1wKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vUmVuZGVyZXInKTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gb3ZlcmxheSByZW5kZXJlci5cclxuICovXHJcbmNsYXNzIE92ZXJsYXlSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IE92ZXJsYXlSZW5kZXJlciBvYmplY3QuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5vdmVybGF5ID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIG92ZXJsYXkgaXMgYXR0YWNoZWQgdG8gYSBwbG90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPdmVybGF5fSBvdmVybGF5IC0gVGhlIG92ZXJsYXkgdG8gYXR0YWNoIHRoZSByZW5kZXJlciB0by5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPdmVybGF5UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRvbkFkZChvdmVybGF5KSB7XHJcblx0XHRpZiAoIW92ZXJsYXkpIHtcclxuXHRcdFx0dGhyb3cgJ05vIG92ZXJsYXkgcHJvdmlkZWQgYXMgYXJndW1lbnQnO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyByZW1vdmVkIGZyb20gYSBwbG90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPdmVybGF5fSBvdmVybGF5IC0gVGhlIG92ZXJsYXkgdG8gcmVtb3ZlIHRoZSByZW5kZXJlciBmcm9tLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge092ZXJsYXlSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uUmVtb3ZlKG92ZXJsYXkpIHtcclxuXHRcdGlmICghb3ZlcmxheSkge1xyXG5cdFx0XHR0aHJvdyAnTm8gb3ZlcmxheSBwcm92aWRlZCBhcyBhcmd1bWVudCc7XHJcblx0XHR9XHJcblx0XHR0aGlzLm92ZXJsYXkgPSBudWxsO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXlSZW5kZXJlcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgU2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vd2ViZ2wvc2hhZGVyL1NoYWRlcicpO1xyXG5jb25zdCBFdmVudFR5cGUgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudFR5cGUnKTtcclxuY29uc3QgT3ZlcmxheVJlbmRlcmVyID0gcmVxdWlyZSgnLi9PdmVybGF5UmVuZGVyZXInKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuLyoqXHJcbiAqIFJlZnJlc2ggZXZlbnQgaGFuZGxlciBzeW1ib2wuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxyXG4gKi9cclxuY29uc3QgUkVGUkVTSCA9IFN5bWJvbCgpO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHdlYmdsIG92ZXJsYXkgcmVuZGVyZXIuXHJcbiAqL1xyXG5jbGFzcyBXZWJHTE92ZXJsYXlSZW5kZXJlciBleHRlbmRzIE92ZXJsYXlSZW5kZXJlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBXZWJHTE92ZXJsYXlSZW5kZXJlciBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvdmVybGF5IG9wdGlvbnMuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzdXBlcihvcHRpb25zKTtcclxuXHRcdHRoaXMuZ2wgPSBudWxsO1xyXG5cdFx0dGhpc1tSRUZSRVNIXSA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIGF0dGFjaGVkIHRvIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IG92ZXJsYXkgLSBUaGUgb3ZlcmxheSB0byBhdHRhY2ggdGhlIHJlbmRlcmVyIHRvLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1dlYkdMT3ZlcmxheVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25BZGQob3ZlcmxheSkge1xyXG5cdFx0c3VwZXIub25BZGQob3ZlcmxheSk7XHJcblx0XHR0aGlzLmdsID0gdGhpcy5vdmVybGF5LnBsb3QuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cdFx0Ly8gY3JlYXRlIGJ1ZmZlcnNcclxuXHRcdHRoaXMucmVmcmVzaEJ1ZmZlcnMoKTtcclxuXHRcdC8vIGNyZWF0ZSByZWZyZXNoIGhhbmRsZXJcclxuXHRcdHRoaXNbUkVGUkVTSF0gPSAoKSA9PiB7XHJcblx0XHRcdHRoaXMucmVmcmVzaEJ1ZmZlcnMoKTtcclxuXHRcdH07XHJcblx0XHQvLyBhdHRhY2ggcmVmcmVzaCBoYW5kbGVyXHJcblx0XHR0aGlzLm92ZXJsYXkub24oRXZlbnRUeXBlLlJFRlJFU0gsIHRoaXNbUkVGUkVTSF0pO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0xheWVyfSBvdmVybGF5IC0gVGhlIG92ZXJsYXkgdG8gcmVtb3ZlIHRoZSByZW5kZXJlciBmcm9tLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1dlYkdMT3ZlcmxheVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25SZW1vdmUob3ZlcmxheSkge1xyXG5cdFx0Ly8gcmVtb3ZlIHJlZnJlc2ggaGFuZGxlclxyXG5cdFx0dGhpcy5vdmVybGF5LnJlbW92ZUxpc3RlbmVyKEV2ZW50VHlwZS5SRUZSRVNILCB0aGlzW1JFRlJFU0hdKTtcclxuXHRcdC8vIGRlc3Ryb3kgcmVmcmVzaCBoYW5kbGVyXHJcblx0XHR0aGlzW1JFRlJFU0hdID0gbnVsbDtcclxuXHRcdHRoaXMuZ2wgPSBudWxsO1xyXG5cdFx0c3VwZXIub25SZW1vdmUob3ZlcmxheSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGFueSB1bmRlcmx5aW5nIGJ1ZmZlcnMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7V2ViR0xPdmVybGF5UmVuZGVyZXJ9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHJlZnJlc2hCdWZmZXJzKCkge1xyXG5cdFx0dGhyb3cgJ2ByZWZyZXNoQnVmZmVyc2AgbXVzdCBiZSBvdmVycmlkZGVuJztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlIGFuZCByZXR1cm4gYSBuZXcgU2hhZGVyIG9iamVjdCB1c2luZyB0aGUgcmVuZGVyZXJzIGludGVybmFsXHJcblx0ICogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSAtIFRoZSBzaGFkZXIgcGFyYW0gb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UuY29tbW9uIC0gQ29tbW9uIGdsc2wgdG8gYmUgc2hhcmVkIGJ5IGJvdGggdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UudmVydCAtIFRoZSB2ZXJ0ZXggc2hhZGVyIGdsc2wuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZS5mcmFnIC0gVGhlIGZyYWdtZW50IHNoYWRlciBnbHNsLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1NoYWRlcn0gVGhlIHNoYWRlciBvYmplY3QuXHJcblx0ICovXHJcblx0Y3JlYXRlU2hhZGVyKHNvdXJjZSkge1xyXG5cdFx0cmV0dXJuIG5ldyBTaGFkZXIodGhpcy5nbCwgc291cmNlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgdGhlIHZpZXdwb3J0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gVGhlIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIG1hdHJpeC5cclxuXHQgKi9cclxuXHRnZXRPcnRob01hdHJpeCgpIHtcclxuXHRcdHJldHVybiB0aGlzLm92ZXJsYXkucGxvdC5nZXRPcnRob01hdHJpeCgpO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJHTE92ZXJsYXlSZW5kZXJlcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xyXG5jb25zdCBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi8uLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QnVmZmVyJyk7XHJcbmNvbnN0IFdlYkdMT3ZlcmxheVJlbmRlcmVyID0gcmVxdWlyZSgnLi4vV2ViR0xPdmVybGF5UmVuZGVyZXInKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuLyoqXHJcbiAqIFNoYWRlciBHTFNMIHNvdXJjZS5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBTSEFERVJfR0xTTCA9IHtcclxuXHR2ZXJ0OlxyXG5cdFx0YFxyXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0YXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xyXG5cdFx0YXR0cmlidXRlIHZlYzIgYU5vcm1hbDtcclxuXHRcdHVuaWZvcm0gdmVjMiB1Vmlld09mZnNldDtcclxuXHRcdHVuaWZvcm0gZmxvYXQgdVNjYWxlO1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1TGluZVdpZHRoO1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1UGl4ZWxSYXRpbztcclxuXHRcdHVuaWZvcm0gZmxvYXQgdVBvaW50UmFkaXVzO1xyXG5cdFx0dW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xyXG5cdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHR2ZWMyIHdQb3NpdGlvbiA9IChhUG9zaXRpb24gKiB1U2NhbGUpIC0gdVZpZXdPZmZzZXQ7XHJcblx0XHRcdGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHdQb3NpdGlvbiwgMC4wLCAxLjApO1xyXG5cdFx0XHRnbF9Qb2ludFNpemUgPSB1UG9pbnRSYWRpdXMgKiAyLjAgKiB1UGl4ZWxSYXRpbztcclxuXHRcdH1cclxuXHRcdGAsXHJcblx0ZnJhZzpcclxuXHRcdGBcclxuXHRcdCNpZmRlZiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcclxuXHRcdFx0I2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcclxuXHRcdCNlbmRpZlxyXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0dW5pZm9ybSB2ZWM0IHVQb2ludENvbG9yO1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcclxuXHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0dmVjMiBjeHkgPSAyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wO1xyXG5cdFx0XHRmbG9hdCByYWRpdXMgPSBkb3QoY3h5LCBjeHkpO1xyXG5cdFx0XHRmbG9hdCBhbHBoYSA9IDEuMDtcclxuXHRcdFx0I2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xyXG5cdFx0XHRcdGZsb2F0IGRlbHRhID0gZndpZHRoKHJhZGl1cyk7XHJcblx0XHRcdFx0YWxwaGEgPSAxLjAgLSBzbW9vdGhzdGVwKDEuMCAtIGRlbHRhLCAxLjAgKyBkZWx0YSwgcmFkaXVzKTtcclxuXHRcdFx0I2Vsc2VcclxuXHRcdFx0XHRpZiAocmFkaXVzID4gMS4wKSB7XHJcblx0XHRcdFx0XHRkaXNjYXJkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0I2VuZGlmXHJcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQodVBvaW50Q29sb3IucmdiLCB1UG9pbnRDb2xvci5hICogYWxwaGEgKiB1T3BhY2l0eSk7XHJcblx0XHR9XHJcblx0XHRgXHJcbn07XHJcblxyXG4vLyBQcml2YXRlIE1ldGhvZHNcclxuXHJcbmNvbnN0IGJ1ZmZlclBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG5cdGNvbnN0IGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xyXG5cdGZvciAobGV0IGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xyXG5cdFx0YnVmZmVyW2kqMl0gPSBwb2ludC54O1xyXG5cdFx0YnVmZmVyW2kqMisxXSA9IHBvaW50Lnk7XHJcblx0fVxyXG5cdHJldHVybiBidWZmZXI7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVWZXJ0ZXhCdWZmZXIgPSBmdW5jdGlvbihnbCwgcG9pbnRzKSB7XHJcblx0Y29uc3QgZGF0YSA9IGJ1ZmZlclBvaW50cyhwb2ludHMpO1xyXG5cdHJldHVybiBuZXcgVmVydGV4QnVmZmVyKFxyXG5cdFx0Z2wsXHJcblx0XHRkYXRhLFxyXG5cdFx0e1xyXG5cdFx0XHQwOiB7XHJcblx0XHRcdFx0c2l6ZTogMixcclxuXHRcdFx0XHR0eXBlOiAnRkxPQVQnXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdG1vZGU6ICdQT0lOVFMnLFxyXG5cdFx0XHRjb3VudDogcG9pbnRzLmxlbmd0aFxyXG5cdFx0fSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgd2ViZ2wgcG9pbnQgb3ZlcmxheSByZW5kZXJlci5cclxuICovXHJcbmNsYXNzIFBvaW50T3ZlcmxheVJlbmRlcmVyIGV4dGVuZHMgV2ViR0xPdmVybGF5UmVuZGVyZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUG9pbnRPdmVybGF5UmVuZGVyZXIgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3ZlcmxheSBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMucG9pbnRDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgcG9pbnRzLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnBvaW50UmFkaXVzIC0gVGhlIHBpeGVsIHJhZGl1cyBvZiB0aGUgcG9pbnRzLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0c3VwZXIob3B0aW9ucyk7XHJcblx0XHR0aGlzLnBvaW50Q29sb3IgPSBkZWZhdWx0VG8ob3B0aW9ucy5wb2ludENvbG9yLCBbIDEuMCwgMC4wLCAxLjAsIDEuMCBdKTtcclxuXHRcdHRoaXMucG9pbnRSYWRpdXMgPSBkZWZhdWx0VG8ob3B0aW9ucy5wb2ludFJhZGl1cywgNCk7XHJcblx0XHR0aGlzLnNoYWRlciA9IG51bGw7XHJcblx0XHR0aGlzLmV4dCA9IG51bGw7XHJcblx0XHR0aGlzLnBvaW50cyA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIGF0dGFjaGVkIHRvIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IG92ZXJsYXkgLSBUaGUgb3ZlcmxheSB0byBhdHRhY2ggdGhlIHJlbmRlcmVyIHRvLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1BvaW50T3ZlcmxheVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25BZGQob3ZlcmxheSkge1xyXG5cdFx0c3VwZXIub25BZGQob3ZlcmxheSk7XHJcblx0XHR0aGlzLmV4dCA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnKTtcclxuXHRcdHRoaXMuc2hhZGVyID0gdGhpcy5jcmVhdGVTaGFkZXIoU0hBREVSX0dMU0wpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0xheWVyfSBvdmVybGF5IC0gVGhlIG92ZXJsYXkgdG8gcmVtb3ZlIHRoZSByZW5kZXJlciBmcm9tLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1BvaW50T3ZlcmxheVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25SZW1vdmUob3ZlcmxheSkge1xyXG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5leHQgPSBudWxsO1xyXG5cdFx0dGhpcy5wb2ludHMgPSBudWxsO1xyXG5cdFx0c3VwZXIub25SZW1vdmUob3ZlcmxheSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGFueSB1bmRlcmx5aW5nIGJ1ZmZlcnMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UG9pbnRPdmVybGF5UmVuZGVyZXJ9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHJlZnJlc2hCdWZmZXJzKCkge1xyXG5cdFx0Ly8gY2xpcCBwb2ludHMgdG8gb25seSB0aG9zZSB0aGF0IGFyZSBpbnNpZGUgdGhlIGNlbGxcclxuXHRcdGNvbnN0IGNsaXBwZWQgPSB0aGlzLm92ZXJsYXkuZ2V0Q2xpcHBlZEdlb21ldHJ5KCk7XHJcblx0XHQvLyBnZW5lcmF0ZSB0aGUgYnVmZmVyXHJcblx0XHRpZiAoY2xpcHBlZCAmJiBjbGlwcGVkLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0dGhpcy5wb2ludHMgPSBjcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5nbCwgY2xpcHBlZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnBvaW50cyA9IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgZHJhdyBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIHBlciBmcmFtZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2ludE92ZXJsYXlSZW5kZXJlcn0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZHJhdygpIHtcclxuXHRcdGlmICghdGhpcy5wb2ludHMpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Y29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXI7XHJcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLm92ZXJsYXkucGxvdDtcclxuXHRcdGNvbnN0IGNlbGwgPSBwbG90LmNlbGw7XHJcblx0XHRjb25zdCBwcm9qID0gdGhpcy5nZXRPcnRob01hdHJpeCgpO1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBwbG90Lnpvb20gLSBjZWxsLnpvb20pO1xyXG5cdFx0Y29uc3Qgb3BhY2l0eSA9IHRoaXMub3ZlcmxheS5vcGFjaXR5O1xyXG5cclxuXHRcdC8vIGdldCB2aWV3IG9mZnNldCBpbiBjZWxsIHNwYWNlXHJcblx0XHRjb25zdCBvZmZzZXQgPSBjZWxsLnByb2plY3QocGxvdC52aWV3cG9ydCwgcGxvdC56b29tKTtcclxuXHJcblx0XHQvLyBzZXQgYmxlbmRpbmcgZnVuY1xyXG5cdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuXHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuXHRcdC8vIGJpbmQgc2hhZGVyXHJcblx0XHRzaGFkZXIudXNlKCk7XHJcblxyXG5cdFx0Ly8gc2V0IGdsb2JhbCB1bmlmb3Jtc1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VQcm9qZWN0aW9uTWF0cml4JywgcHJvaik7XHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVZpZXdPZmZzZXQnLCBbIG9mZnNldC54LCBvZmZzZXQueSBdKTtcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1U2NhbGUnLCBzY2FsZSk7XHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVBvaW50Q29sb3InLCB0aGlzLnBvaW50Q29sb3IpO1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VQb2ludFJhZGl1cycsIHRoaXMucG9pbnRSYWRpdXMpO1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VQaXhlbFJhdGlvJywgcGxvdC5waXhlbFJhdGlvKTtcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIG9wYWNpdHkpO1xyXG5cclxuXHRcdC8vIGRyYXcgdGhlIHBvaW50c1xyXG5cdFx0cG9pbnRzLmJpbmQoKTtcclxuXHRcdHBvaW50cy5kcmF3KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50T3ZlcmxheVJlbmRlcmVyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBlYXJjdXQgPSByZXF1aXJlKCdlYXJjdXQnKTtcclxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xyXG5jb25zdCBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi8uLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QnVmZmVyJyk7XHJcbmNvbnN0IEluZGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vd2ViZ2wvdmVydGV4L0luZGV4QnVmZmVyJyk7XHJcbmNvbnN0IFdlYkdMT3ZlcmxheVJlbmRlcmVyID0gcmVxdWlyZSgnLi4vV2ViR0xPdmVybGF5UmVuZGVyZXInKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuLyoqXHJcbiAqIFNoYWRlciBHTFNMIHNvdXJjZS5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBTSEFERVJfR0xTTCA9IHtcclxuXHR2ZXJ0OlxyXG5cdFx0YFxyXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0YXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xyXG5cdFx0dW5pZm9ybSB2ZWMyIHVWaWV3T2Zmc2V0O1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1U2NhbGU7XHJcblx0XHR1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XHJcblx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdHZlYzIgd1Bvc2l0aW9uID0gKGFQb3NpdGlvbiAqIHVTY2FsZSkgLSB1Vmlld09mZnNldDtcclxuXHRcdFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQod1Bvc2l0aW9uLCAwLjAsIDEuMCk7XHJcblx0XHR9XHJcblx0XHRgLFxyXG5cdGZyYWc6XHJcblx0XHRgXHJcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHR1bmlmb3JtIHZlYzQgdVBvbHlnb25Db2xvcjtcclxuXHRcdHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7XHJcblx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQodVBvbHlnb25Db2xvci5yZ2IsIHVQb2x5Z29uQ29sb3IuYSAqIHVPcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdGBcclxufTtcclxuXHJcbi8vIFByaXZhdGUgTWV0aG9kc1xyXG5cclxuY29uc3QgZ2V0VmVydGV4QXJyYXkgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuXHRjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xyXG5cdGZvciAobGV0IGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZlcnRpY2VzW2kqMl0gPSBwb2ludHNbaV0ueDtcclxuXHRcdHZlcnRpY2VzW2kqMiArIDFdID0gcG9pbnRzW2ldLnk7XHJcblx0fVxyXG5cdHJldHVybiB2ZXJ0aWNlcztcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUJ1ZmZlcnMgPSBmdW5jdGlvbihvdmVybGF5LCBwb2ludHMpIHtcclxuXHRjb25zdCB2ZXJ0aWNlcyA9IGdldFZlcnRleEFycmF5KHBvaW50cyk7XHJcblx0Y29uc3QgaW5kaWNlcyA9IGVhcmN1dCh2ZXJ0aWNlcyk7XHJcblx0Y29uc3QgdmVydGV4QnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcihcclxuXHRcdG92ZXJsYXkuZ2wsXHJcblx0XHR2ZXJ0aWNlcyxcclxuXHRcdHtcclxuXHRcdFx0MDoge1xyXG5cdFx0XHRcdHNpemU6IDIsXHJcblx0XHRcdFx0dHlwZTogJ0ZMT0FUJ1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRjb25zdCBpczE2Qml0ID0gdmVydGljZXMubGVuZ3RoIDwgTWF0aC5wb3coMiwgMTYpO1xyXG5cdGNvbnN0IGluZGV4QnVmZmVyID0gbmV3IEluZGV4QnVmZmVyKFxyXG5cdFx0b3ZlcmxheS5nbCxcclxuXHRcdGlzMTZCaXQgPyBuZXcgVWludDE2QXJyYXkoaW5kaWNlcykgOiBuZXcgVWludDMyQXJyYXkoaW5kaWNlcyksXHJcblx0XHR7XHJcblx0XHRcdG1vZGU6ICdUUklBTkdMRVMnLFxyXG5cdFx0XHR0eXBlOiBpczE2Qml0ID8gJ1VOU0lHTkVEX1NIT1JUJyA6ICdVTlNJR05FRF9JTlQnLFxyXG5cdFx0XHRjb3VudDogaW5kaWNlcy5sZW5ndGhcclxuXHRcdH0pO1xyXG5cdHJldHVybiB7XHJcblx0XHR2ZXJ0ZXg6IHZlcnRleEJ1ZmZlcixcclxuXHRcdGluZGV4OiBpbmRleEJ1ZmZlclxyXG5cdH07XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgd2ViZ2wgcG9seWxpbmUgb3ZlcmxheSByZW5kZXJlci5cclxuICovXHJcbmNsYXNzIFBvbHlnb25PdmVybGF5UmVuZGVyZXIgZXh0ZW5kcyBXZWJHTE92ZXJsYXlSZW5kZXJlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBQb2x5Z29uT3ZlcmxheVJlbmRlcmVyIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG92ZXJsYXkgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnBvbHlnb25Db2xvciAtIFRoZSBjb2xvciBvZiB0aGUgbGluZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuXHRcdHN1cGVyKG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5wb2x5Z29uQ29sb3IgPSBkZWZhdWx0VG8ob3B0aW9ucy5wb2x5Z29uQ29sb3IsIFsgMS4wLCAwLjQsIDAuMSwgMC44IF0pO1xyXG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5wb2x5Z29ucyA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIGF0dGFjaGVkIHRvIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgb3ZlcmxheSB0by5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2x5Z29uT3ZlcmxheVJlbmRlcmVyfSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRvbkFkZChwbG90KSB7XHJcblx0XHRzdXBlci5vbkFkZChwbG90KTtcclxuXHRcdHRoaXMuc2hhZGVyID0gdGhpcy5jcmVhdGVTaGFkZXIoU0hBREVSX0dMU0wpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byByZW1vdmUgdGhlIG92ZXJsYXkgZnJvbS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2x5Z29uT3ZlcmxheVJlbmRlcmVyfSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRvblJlbW92ZShwbG90KSB7XHJcblx0XHRzdXBlci5vblJlbW92ZShwbG90KTtcclxuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgYW55IHVuZGVybHlpbmcgYnVmZmVycy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2x5Z29uT3ZlcmxheVJlbmRlcmVyfSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRyZWZyZXNoQnVmZmVycygpIHtcclxuXHRcdGNvbnN0IGNsaXBwZWQgPSB0aGlzLm92ZXJsYXkuZ2V0Q2xpcHBlZEdlb21ldHJ5KCk7XHJcblx0XHRpZiAoY2xpcHBlZCkge1xyXG5cdFx0XHR0aGlzLnBvbHlnb25zID0gY2xpcHBlZC5tYXAocG9pbnRzID0+IHtcclxuXHRcdFx0XHQvLyBnZW5lcmF0ZSB0aGUgYnVmZmVyXHJcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUJ1ZmZlcnModGhpcywgcG9pbnRzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnBvbHlnb25zID0gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgcGVyIGZyYW1lLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1BvbHlnb25PdmVybGF5UmVuZGVyZXJ9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGRyYXcoKSB7XHJcblx0XHRpZiAoIXRoaXMucG9seWdvbnMpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Y29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXI7XHJcblx0XHRjb25zdCBwb2x5Z29ucyA9IHRoaXMucG9seWdvbnM7XHJcblx0XHRjb25zdCBwbG90ID0gdGhpcy5vdmVybGF5LnBsb3Q7XHJcblx0XHRjb25zdCBjZWxsID0gcGxvdC5jZWxsO1xyXG5cdFx0Y29uc3QgcHJvaiA9IHRoaXMuZ2V0T3J0aG9NYXRyaXgoKTtcclxuXHRcdGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgcGxvdC56b29tIC0gY2VsbC56b29tKTtcclxuXHRcdGNvbnN0IG9wYWNpdHkgPSB0aGlzLm92ZXJsYXkub3BhY2l0eTtcclxuXHJcblx0XHQvLyBnZXQgdmlldyBvZmZzZXQgaW4gY2VsbCBzcGFjZVxyXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gY2VsbC5wcm9qZWN0KHBsb3Qudmlld3BvcnQsIHBsb3Quem9vbSk7XHJcblxyXG5cdFx0Ly8gc2V0IGJsZW5kaW5nIGZ1bmNcclxuXHRcdGdsLmVuYWJsZShnbC5CTEVORCk7XHJcblx0XHRnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcblx0XHQvLyBiaW5kIHNoYWRlclxyXG5cdFx0c2hhZGVyLnVzZSgpO1xyXG5cclxuXHRcdC8vIHNldCBnbG9iYWwgdW5pZm9ybXNcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHByb2opO1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VWaWV3T2Zmc2V0JywgWyBvZmZzZXQueCwgb2Zmc2V0LnkgXSk7XHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVNjYWxlJywgc2NhbGUpO1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VQb2x5Z29uQ29sb3InLCB0aGlzLnBvbHlnb25Db2xvcik7XHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndU9wYWNpdHknLCBvcGFjaXR5KTtcclxuXHJcblx0XHQvLyBmb3IgZWFjaCBwb2x5bGluZSBidWZmZXJcclxuXHRcdHBvbHlnb25zLmZvckVhY2goYnVmZmVyID0+IHtcclxuXHRcdFx0Ly8gZHJhdyB0aGUgcG9pbnRzXHJcblx0XHRcdGJ1ZmZlci52ZXJ0ZXguYmluZCgpO1xyXG5cdFx0XHRidWZmZXIuaW5kZXguZHJhdygpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb25PdmVybGF5UmVuZGVyZXI7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcclxuY29uc3QgVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vd2ViZ2wvdmVydGV4L1ZlcnRleEJ1ZmZlcicpO1xyXG5jb25zdCBXZWJHTE92ZXJsYXlSZW5kZXJlciA9IHJlcXVpcmUoJy4uL1dlYkdMT3ZlcmxheVJlbmRlcmVyJyk7XHJcblxyXG4vLyBDb25zdGFudHNcclxuXHJcbi8qKlxyXG4gKiBTaGFkZXIgR0xTTCBzb3VyY2UuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgU0hBREVSX0dMU0wgPSB7XHJcblx0dmVydDpcclxuXHRcdGBcclxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcclxuXHRcdGF0dHJpYnV0ZSB2ZWMyIGFOb3JtYWw7XHJcblx0XHR1bmlmb3JtIHZlYzIgdVZpZXdPZmZzZXQ7XHJcblx0XHR1bmlmb3JtIGZsb2F0IHVTY2FsZTtcclxuXHRcdHVuaWZvcm0gZmxvYXQgdUxpbmVXaWR0aDtcclxuXHRcdHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcclxuXHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0dmVjMiB3UG9zaXRpb24gPSAoYVBvc2l0aW9uICogdVNjYWxlKSAtIHVWaWV3T2Zmc2V0ICsgYU5vcm1hbCAqIHVMaW5lV2lkdGg7XHJcblx0XHRcdGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHdQb3NpdGlvbiwgMC4wLCAxLjApO1xyXG5cdFx0fVxyXG5cdFx0YCxcclxuXHRmcmFnOlxyXG5cdFx0YFxyXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0dW5pZm9ybSB2ZWM0IHVMaW5lQ29sb3I7XHJcblx0XHR1bmlmb3JtIGZsb2F0IHVPcGFjaXR5O1xyXG5cdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHVMaW5lQ29sb3IucmdiLCB1TGluZUNvbG9yLmEgKiB1T3BhY2l0eSk7XHJcblx0XHR9XHJcblx0XHRgXHJcbn07XHJcblxyXG4vLyBQcml2YXRlIE1ldGhvZHNcclxuXHJcbi8vIE5PVEU6IHNtb290aCAvIHJvdW5kIGxpbmVzIGltcGxlbWVudGVkIHVzaW5nIGNvZGUgbW9kaWZpZWQgZnJvbTpcclxuLy8gaHR0cDovL2xhYnMuaHlwZXJhbmRyb2lkLmNvbS9lZmZpY2llbnQtd2ViZ2wtc3Ryb2tpbmcgLiBJbnN0ZWFkIG9mIGJha2luZyBpblxyXG4vLyB0aGUgcG9zaXRpb25zIG9mIHRoZSBsaW5lcywgdGhpcyBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkIGdlbmVyYXRlcyB0aGVcclxuLy8gcG9zaXRpb25zIGFsb25nIHRoZSBsaW5lIGFuZCBzdG9yZXMgdGhlIHRhbmdlbnRzLCBhbGxvd2luZyB0aGUgdGhpY2tuZXNzIHRvXHJcbi8vIGJlIGFyYml0cmFyaWx5IHNjYWxlZCBvdXR3YXJkcyBpbmRlcGVuZGFudCBvZiBzY2FsZS4gSW4gb3JkZXIgdG8gcHJldmVudFxyXG4vLyBkZWdlbmVyYXRpb24gb2Ygbm9ybWFscyBkdWUgdG8gc2VsZi1pbnRlcnNlY3Rpb25zLCB0aGUgdHJpYW5nbGVzIGFyZVxyXG4vLyBnZW5lcmF0ZWQgdXBvbiB6b29tLlxyXG5cclxuY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAxO1xyXG5cclxuY29uc3Qgc2NhbGFyTXVsdCA9IGZ1bmN0aW9uKGEsIHMpIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogYS54ICogcyxcclxuXHRcdHk6IGEueSAqIHNcclxuXHR9O1xyXG59O1xyXG5cclxuY29uc3QgcGVycGVuZGljdWxhciA9IGZ1bmN0aW9uKGEpIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogLWEueSxcclxuXHRcdHk6IGEueFxyXG5cdH07XHJcbn07XHJcblxyXG5jb25zdCBpbnZlcnQgPSBmdW5jdGlvbihhKSB7XHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IC1hLngsXHJcblx0XHR5OiAtYS55XHJcblx0fTtcclxufTtcclxuXHJcbmNvbnN0IGxlbmd0aCA9IGZ1bmN0aW9uKGEpIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XHJcbn07XHJcblxyXG5jb25zdCBub3JtYWxpemUgPSBmdW5jdGlvbihhKSB7XHJcblx0Y29uc3QgbW9kID0gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IGEueCAvIG1vZCxcclxuXHRcdHk6IGEueSAvIG1vZFxyXG5cdH07XHJcbn07XHJcblxyXG5jb25zdCBhZGQgPSBmdW5jdGlvbihwMCwgcDEpIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogcDAueCArIHAxLngsXHJcblx0XHR5OiBwMC55ICsgcDEueVxyXG5cdH07XHJcbn07XHJcblxyXG5jb25zdCBzdWIgPSBmdW5jdGlvbihwMCwgcDEpIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogcDAueCAtIHAxLngsXHJcblx0XHR5OiBwMC55IC0gcDEueVxyXG5cdH07XHJcbn07XHJcblxyXG5jb25zdCBtaWRkbGUgPSBmdW5jdGlvbihwMCwgcDEpIHtcclxuXHRyZXR1cm4gc2NhbGFyTXVsdChhZGQocDAsIHAxKSwgMC41KTtcclxufTtcclxuXHJcbmNvbnN0IGVxdWFsID0gZnVuY3Rpb24ocDAsIHAxKSB7XHJcblx0cmV0dXJuIHAwLnggPT09IHAxLnggJiYgcDAueSA9PT0gcDEueTtcclxufTtcclxuXHJcbmNvbnN0IHNpZ25lZEFyZWEgPSBmdW5jdGlvbihwMCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIChwMS54IC0gcDAueCkgKiAocDIueSAtIHAwLnkpIC0gKHAyLnggLSBwMC54KSAqIChwMS55IC0gcDAueSk7XHJcbn07XHJcblxyXG5jb25zdCBnZXRTdHJva2VHZW9tZXRyeSA9IGZ1bmN0aW9uKHBvaW50cywgc3Ryb2tlV2lkdGgpIHtcclxuXHRpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHtcclxuXHRcdHRocm93ICdBIHZhbGlkIHBvbHlsaW5lIG11c3QgY29uc2lzdCBvZiBhdCBsZWFzdCAyIHBvaW50cyc7XHJcblx0fVxyXG5cclxuXHRjb25zdCBsaW5lV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XHJcblx0Y29uc3QgcG9zaXRpb25zID0gW107XHJcblx0Y29uc3Qgbm9ybWFscyA9IFtdO1xyXG5cdGNvbnN0IG1pZGRsZVBvaW50cyA9IFtdOyAvLyBtaWRkbGUgcG9pbnRzIHBlciBlYWNoIGxpbmUgc2VnbWVudFxyXG5cdGxldCBjbG9zZWQgPSBmYWxzZTtcclxuXHJcblx0aWYgKHBvaW50cy5sZW5ndGggPT09IDIpIHtcclxuXHJcblx0XHRjcmVhdGVUcmlhbmdsZXMoXHJcblx0XHRcdHBvaW50c1swXSxcclxuXHRcdFx0bWlkZGxlKHBvaW50c1swXSwgcG9pbnRzWzFdKSxcclxuXHRcdFx0cG9pbnRzWzFdLFxyXG5cdFx0XHRwb3NpdGlvbnMsXHJcblx0XHRcdG5vcm1hbHMsXHJcblx0XHRcdGxpbmVXaWR0aCk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0aWYgKGVxdWFsKHBvaW50c1swXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSkpIHtcclxuXHRcdFx0Y29uc3QgcDAgPSBtaWRkbGUocG9pbnRzLnNoaWZ0KCksIHBvaW50c1swXSk7XHJcblx0XHRcdHBvaW50cy51bnNoaWZ0KHAwKTtcclxuXHRcdFx0cG9pbnRzLnB1c2gocDApO1xyXG5cdFx0XHRjbG9zZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGk9MDsgaTxwb2ludHMubGVuZ3RoLTE7IGkrKykge1xyXG5cdFx0XHRpZiAoaSA9PT0gMCkge1xyXG5cdFx0XHRcdG1pZGRsZVBvaW50cy5wdXNoKHBvaW50c1swXSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDIpIHtcclxuXHRcdFx0XHRtaWRkbGVQb2ludHMucHVzaChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtaWRkbGVQb2ludHMucHVzaChtaWRkbGUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpPTE7IGk8bWlkZGxlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNyZWF0ZVRyaWFuZ2xlcyhcclxuXHRcdFx0XHRtaWRkbGVQb2ludHNbaSAtIDFdLFxyXG5cdFx0XHRcdHBvaW50c1tpXSxcclxuXHRcdFx0XHRtaWRkbGVQb2ludHNbaV0sXHJcblx0XHRcdFx0cG9zaXRpb25zLFxyXG5cdFx0XHRcdG5vcm1hbHMsXHJcblx0XHRcdFx0bGluZVdpZHRoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmICghY2xvc2VkKSB7XHJcblxyXG5cdFx0Ly8gc3RhcnQgY2FwXHJcblx0XHRsZXQgcDAgPSBwb2ludHNbMF07XHJcblx0XHRsZXQgcDEgPSBwb2ludHNbMV07XHJcblx0XHRsZXQgdCA9IHBlcnBlbmRpY3VsYXIoc3ViKHAxLCBwMCkpO1xyXG5cdFx0Y3JlYXRlUm91bmRDYXAoXHJcblx0XHRcdHAwLFxyXG5cdFx0XHRhZGQocDAsIHQpLFxyXG5cdFx0XHRzdWIocDAsIHQpLFxyXG5cdFx0XHRwMSxcclxuXHRcdFx0cG9zaXRpb25zLFxyXG5cdFx0XHRub3JtYWxzKTtcclxuXHJcblx0XHQvLyBlbmQgY2FwXHJcblx0XHRwMCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XHJcblx0XHRwMSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XHJcblx0XHR0ID0gcGVycGVuZGljdWxhcihzdWIocDEsIHAwKSk7XHJcblx0XHRjcmVhdGVSb3VuZENhcChcclxuXHRcdFx0cDAsXHJcblx0XHRcdGFkZChwMCwgdCksXHJcblx0XHRcdHN1YihwMCwgdCksXHJcblx0XHRcdHAxLFxyXG5cdFx0XHRwb3NpdGlvbnMsXHJcblx0XHRcdG5vcm1hbHMpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHBvc2l0aW9uczogcG9zaXRpb25zLFxyXG5cdFx0bm9ybWFsczogbm9ybWFsc1xyXG5cdH07XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVSb3VuZENhcCA9IGZ1bmN0aW9uKGNlbnRlciwgcDAsIHAxLCBuZXh0UG9pbnRJbkxpbmUsIHBvc2l0aW9ucywgbm9ybWFscykge1xyXG5cclxuXHRsZXQgYW5nbGUwID0gTWF0aC5hdGFuMigocDEueSAtIGNlbnRlci55KSwgKHAxLnggLSBjZW50ZXIueCkpO1xyXG5cdGxldCBhbmdsZTEgPSBNYXRoLmF0YW4yKChwMC55IC0gY2VudGVyLnkpLCAocDAueCAtIGNlbnRlci54KSk7XHJcblxyXG5cdGNvbnN0IG9yZ0FuZ2xlMCA9IGFuZ2xlMDtcclxuXHJcblx0aWYgKGFuZ2xlMSA+IGFuZ2xlMCkge1xyXG5cdFx0aWYgKGFuZ2xlMSAtIGFuZ2xlMCA+PSBNYXRoLlBJIC0gRVBTSUxPTikge1xyXG5cdFx0XHRhbmdsZTEgPSBhbmdsZTEgLSAoMiAqIE1hdGguUEkpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRpZiAoYW5nbGUwIC0gYW5nbGUxID49IE1hdGguUEkgLSBFUFNJTE9OKSB7XHJcblx0XHRcdGFuZ2xlMCA9IGFuZ2xlMCAtICgyICogTWF0aC5QSSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRsZXQgYW5nbGVEaWZmID0gYW5nbGUxIC0gYW5nbGUwO1xyXG5cclxuXHRpZiAoTWF0aC5hYnMoYW5nbGVEaWZmKSA+PSAoTWF0aC5QSSAtIEVQU0lMT04pICYmXHJcblx0XHRNYXRoLmFicyhhbmdsZURpZmYpIDw9IChNYXRoLlBJICsgRVBTSUxPTikpIHtcclxuXHRcdGNvbnN0IHIxID0gc3ViKGNlbnRlciwgbmV4dFBvaW50SW5MaW5lKTtcclxuXHRcdGlmIChyMS54ID09PSAwKSB7XHJcblx0XHRcdGlmIChyMS55ID4gMCkge1xyXG5cdFx0XHRcdGFuZ2xlRGlmZiA9IC1hbmdsZURpZmY7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAocjEueCA+PSAtRVBTSUxPTikge1xyXG5cdFx0XHRhbmdsZURpZmYgPSAtYW5nbGVEaWZmO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y29uc3Qgc2VnbWVudHNQZXJTZW1pID0gMTY7XHJcblx0Y29uc3QgbnNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKGFuZ2xlRGlmZiAvIE1hdGguUEkpICogc2VnbWVudHNQZXJTZW1pKTtcclxuXHJcblx0Y29uc3QgYW5nbGVJbmMgPSBhbmdsZURpZmYgLyBuc2VnbWVudHM7XHJcblx0Y29uc3QgbjAgPSB7XHJcblx0XHR4OiAwLFxyXG5cdFx0eTogMFxyXG5cdH07XHJcblxyXG5cdGZvciAobGV0IGk9MDsgaTxuc2VnbWVudHM7IGkrKykge1xyXG5cdFx0Y29uc3QgbjEgPSB7XHJcblx0XHRcdHg6IE1hdGguY29zKG9yZ0FuZ2xlMCArIGFuZ2xlSW5jICogaSksXHJcblx0XHRcdHk6IE1hdGguc2luKG9yZ0FuZ2xlMCArIGFuZ2xlSW5jICogaSlcclxuXHRcdH07XHJcblx0XHRjb25zdCBuMiA9IHtcclxuXHRcdFx0eDogTWF0aC5jb3Mob3JnQW5nbGUwICsgYW5nbGVJbmMgKiAoMSArIGkpKSxcclxuXHRcdFx0eTogTWF0aC5zaW4ob3JnQW5nbGUwICsgYW5nbGVJbmMgKiAoMSArIGkpKVxyXG5cdFx0fTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKGNlbnRlcik7XHJcblx0XHRwb3NpdGlvbnMucHVzaChjZW50ZXIpO1xyXG5cdFx0cG9zaXRpb25zLnB1c2goY2VudGVyKTtcclxuXHRcdG5vcm1hbHMucHVzaChuMCk7XHJcblx0XHRub3JtYWxzLnB1c2gobjEpO1xyXG5cdFx0bm9ybWFscy5wdXNoKG4yKTtcclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0aW9uKHAwLCBwMSwgcDIsIHAzKSB7XHJcblx0Y29uc3QgYTAgPSBwMS55IC0gcDAueTtcclxuXHRjb25zdCBiMCA9IHAwLnggLSBwMS54O1xyXG5cdGNvbnN0IGExID0gcDMueSAtIHAyLnk7XHJcblx0Y29uc3QgYjEgPSBwMi54IC0gcDMueDtcclxuXHRjb25zdCBkZXQgPSBhMCAqIGIxIC0gYTEgKiBiMDtcclxuXHRpZiAoZGV0ID4gLUVQU0lMT04gJiYgZGV0IDwgRVBTSUxPTikge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdGNvbnN0IGMwID0gYTAgKiBwMC54ICsgYjAgKiBwMC55O1xyXG5cdGNvbnN0IGMxID0gYTEgKiBwMi54ICsgYjEgKiBwMi55O1xyXG5cdGNvbnN0IHggPSAoYjEgKiBjMCAtIGIwICogYzEpIC8gZGV0O1xyXG5cdGNvbnN0IHkgPSAoYTAgKiBjMSAtIGExICogYzApIC8gZGV0O1xyXG5cdHJldHVybiB7XHJcblx0XHR4OiB4LFxyXG5cdFx0eTogeVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRyaWFuZ2xlcyhwMCwgcDEsIHAyLCBwb3NpdGlvbnMsIG5vcm1hbHMsIGxpbmVXaWR0aCkge1xyXG5cdGxldCB0MCA9IHN1YihwMSwgcDApO1xyXG5cdGxldCB0MiA9IHN1YihwMiwgcDEpO1xyXG5cclxuXHR0MCA9IHBlcnBlbmRpY3VsYXIodDApO1xyXG5cdHQyID0gcGVycGVuZGljdWxhcih0Mik7XHJcblxyXG5cdC8vIHRyaWFuZ2xlIGNvbXBvc2VkIGJ5IHRoZSAzIHBvaW50cyBpZiBjbG9ja3dpc2Ugb3IgY291bnRlci1jbG9ja3dpc2UuXHJcblx0Ly8gaWYgY291bnRlci1jbG9ja3dpc2UsIHdlIG11c3QgaW52ZXJ0IHRoZSBsaW5lIHRocmVzaG9sZCBwb2ludHMsIG90aGVyd2lzZVxyXG5cdC8vIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgY291bGQgYmUgZXJyb25lb3VzIGFuZCBsZWFkIHRvIG9kZCByZXN1bHRzLlxyXG5cdGlmIChzaWduZWRBcmVhKHAwLCBwMSwgcDIpID4gMCkge1xyXG5cdFx0dDAgPSBpbnZlcnQodDApO1xyXG5cdFx0dDIgPSBpbnZlcnQodDIpO1xyXG5cdH1cclxuXHJcblx0dDAgPSBub3JtYWxpemUodDApO1xyXG5cdHQyID0gbm9ybWFsaXplKHQyKTtcclxuXHR0MCA9IHNjYWxhck11bHQodDAsIGxpbmVXaWR0aCk7XHJcblx0dDIgPSBzY2FsYXJNdWx0KHQyLCBsaW5lV2lkdGgpO1xyXG5cclxuXHRjb25zdCBwaW50ZXJzZWN0ID0gbGluZUludGVyc2VjdGlvbihcclxuXHRcdGFkZCh0MCwgcDApLFxyXG5cdFx0YWRkKHQwLCBwMSksXHJcblx0XHRhZGQodDIsIHAyKSxcclxuXHRcdGFkZCh0MiwgcDEpKTtcclxuXHJcblx0bGV0IGFuY2hvciA9IG51bGw7XHJcblx0bGV0IGFuY2hvckxlbmd0aCA9IE51bWJlci5NQVhfVkFMVUU7XHJcblx0bGV0IGlhbiA9IG51bGw7XHJcblx0aWYgKHBpbnRlcnNlY3QpIHtcclxuXHRcdGFuY2hvciA9IHN1YihwaW50ZXJzZWN0LCBwMSk7XHJcblx0XHRhbmNob3JMZW5ndGggPSBsZW5ndGgoYW5jaG9yKTtcclxuXHRcdGlhbiA9IGludmVydChzY2FsYXJNdWx0KGFuY2hvciwgMS4wIC8gbGluZVdpZHRoKSk7XHJcblx0fVxyXG5cdGNvbnN0IHAwcDEgPSBzdWIocDAsIHAxKTtcclxuXHRjb25zdCBwMHAxTGVuZ3RoID0gbGVuZ3RoKHAwcDEpO1xyXG5cdGNvbnN0IHAxcDIgPSBzdWIocDEsIHAyKTtcclxuXHRjb25zdCBwMXAyTGVuZ3RoID0gbGVuZ3RoKHAxcDIpO1xyXG5cclxuXHRjb25zdCBuMCA9IG5vcm1hbGl6ZSh0MCk7XHJcblx0Y29uc3QgaW4wID0gaW52ZXJ0KG4wKTtcclxuXHRjb25zdCBuMiA9IG5vcm1hbGl6ZSh0Mik7XHJcblx0Y29uc3QgaW4yID0gaW52ZXJ0KG4yKTtcclxuXHJcblx0Ly8gdGhlIGNyb3NzIHBvaW50IGV4Y2VlZHMgYW55IG9mIHRoZSBzZWdtZW50cyBkaW1lbnNpb24uXHJcblx0Ly8gZG8gbm90IHVzZSBjcm9zcyBwb2ludCBhcyByZWZlcmVuY2UuXHJcblx0aWYgKGFuY2hvckxlbmd0aCA+IHAwcDFMZW5ndGggfHwgYW5jaG9yTGVuZ3RoID4gcDFwMkxlbmd0aCkge1xyXG5cclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAwKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAwKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHJcblx0XHRub3JtYWxzLnB1c2gobjApO1xyXG5cdFx0bm9ybWFscy5wdXNoKGluMCk7XHJcblx0XHRub3JtYWxzLnB1c2gobjApO1xyXG5cclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAwKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHJcblx0XHRub3JtYWxzLnB1c2goaW4wKTtcclxuXHRcdG5vcm1hbHMucHVzaChuMCk7XHJcblx0XHRub3JtYWxzLnB1c2goaW4wKTtcclxuXHJcblx0XHRjcmVhdGVSb3VuZENhcChcclxuXHRcdFx0cDEsXHJcblx0XHRcdGFkZChwMSwgdDApLFxyXG5cdFx0XHRhZGQocDEsIHQyKSxcclxuXHRcdFx0cDIsXHJcblx0XHRcdHBvc2l0aW9ucyxcclxuXHRcdFx0bm9ybWFscyk7XHJcblxyXG5cdFx0cG9zaXRpb25zLnB1c2gocDIpO1xyXG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xyXG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xyXG5cclxuXHRcdG5vcm1hbHMucHVzaChuMik7XHJcblx0XHRub3JtYWxzLnB1c2goaW4yKTtcclxuXHRcdG5vcm1hbHMucHVzaChuMik7XHJcblxyXG5cdFx0cG9zaXRpb25zLnB1c2gocDIpO1xyXG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xyXG5cdFx0cG9zaXRpb25zLnB1c2gocDIpO1xyXG5cclxuXHRcdG5vcm1hbHMucHVzaChuMik7XHJcblx0XHRub3JtYWxzLnB1c2goaW4yKTtcclxuXHRcdG5vcm1hbHMucHVzaChpbjIpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAwKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAwKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHJcblx0XHRub3JtYWxzLnB1c2gobjApO1xyXG5cdFx0bm9ybWFscy5wdXNoKGluMCk7XHJcblx0XHRub3JtYWxzLnB1c2goaWFuKTtcclxuXHJcblx0XHRwb3NpdGlvbnMucHVzaChwMCk7XHJcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XHJcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XHJcblxyXG5cdFx0bm9ybWFscy5wdXNoKG4wKTtcclxuXHRcdG5vcm1hbHMucHVzaChpYW4pO1xyXG5cdFx0bm9ybWFscy5wdXNoKG4wKTtcclxuXHJcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XHJcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XHJcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XHJcblxyXG5cdFx0bm9ybWFscy5wdXNoKG4wKTtcclxuXHRcdG5vcm1hbHMucHVzaCh7IHg6IDAsIHk6IDAgfSk7XHJcblx0XHRub3JtYWxzLnB1c2goaWFuKTtcclxuXHJcblx0XHRjcmVhdGVSb3VuZENhcChcclxuXHRcdFx0cDEsXHJcblx0XHRcdGFkZChwMSwgdDApLFxyXG5cdFx0XHRhZGQocDEsIHQyKSxcclxuXHRcdFx0c3ViKHAxLCBhbmNob3IpLFxyXG5cdFx0XHRwb3NpdGlvbnMsXHJcblx0XHRcdG5vcm1hbHMpO1xyXG5cclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHJcblx0XHRub3JtYWxzLnB1c2goeyB4OiAwLCB5OiAwIH0pO1xyXG5cdFx0bm9ybWFscy5wdXNoKG4yKTtcclxuXHRcdG5vcm1hbHMucHVzaChpYW4pO1xyXG5cclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAyKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHJcblx0XHRub3JtYWxzLnB1c2gobjIpO1xyXG5cdFx0bm9ybWFscy5wdXNoKGlhbik7XHJcblx0XHRub3JtYWxzLnB1c2gobjIpO1xyXG5cclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAyKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcclxuXHRcdHBvc2l0aW9ucy5wdXNoKHAyKTtcclxuXHJcblx0XHRub3JtYWxzLnB1c2gobjIpO1xyXG5cdFx0bm9ybWFscy5wdXNoKGlhbik7XHJcblx0XHRub3JtYWxzLnB1c2goaW4yKTtcclxuXHR9XHJcbn1cclxuXHJcbmNvbnN0IGJ1ZmZlclBvbHlsaW5lID0gZnVuY3Rpb24ocG9pbnRzLCBub3JtYWxzKSB7XHJcblx0Y29uc3QgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCk7XHJcblx0Zm9yIChsZXQgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0Y29uc3QgcG9pbnQgPSBwb2ludHNbaV07XHJcblx0XHRjb25zdCBub3JtYWwgPSBub3JtYWxzW2ldO1xyXG5cdFx0YnVmZmVyW2kqNF0gPSBwb2ludC54O1xyXG5cdFx0YnVmZmVyW2kqNCsxXSA9IHBvaW50Lnk7XHJcblx0XHRidWZmZXJbaSo0KzJdID0gbm9ybWFsLng7XHJcblx0XHRidWZmZXJbaSo0KzNdID0gbm9ybWFsLnk7XHJcblx0fVxyXG5cdHJldHVybiBidWZmZXI7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVWZXJ0ZXhCdWZmZXIgPSBmdW5jdGlvbihvdmVybGF5LCBwb2ludHMpIHtcclxuXHRjb25zdCBsaW5lV2lkdGggPSBvdmVybGF5LmxpbmVXaWR0aDtcclxuXHRjb25zdCBnZW9tZXRyeSA9IGdldFN0cm9rZUdlb21ldHJ5KHBvaW50cywgbGluZVdpZHRoKTtcclxuXHRjb25zdCBkYXRhID0gYnVmZmVyUG9seWxpbmUoZ2VvbWV0cnkucG9zaXRpb25zLCBnZW9tZXRyeS5ub3JtYWxzKTtcclxuXHRyZXR1cm4gbmV3IFZlcnRleEJ1ZmZlcihcclxuXHRcdG92ZXJsYXkuZ2wsXHJcblx0XHRkYXRhLFxyXG5cdFx0e1xyXG5cdFx0XHQwOiB7XHJcblx0XHRcdFx0c2l6ZTogMixcclxuXHRcdFx0XHR0eXBlOiAnRkxPQVQnLFxyXG5cdFx0XHRcdGJ5dGVPZmZzZXQ6IDBcclxuXHRcdFx0fSxcclxuXHRcdFx0MToge1xyXG5cdFx0XHRcdHNpemU6IDIsXHJcblx0XHRcdFx0dHlwZTogJ0ZMT0FUJyxcclxuXHRcdFx0XHRieXRlT2Zmc2V0OiAyICogNFxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRtb2RlOiAnVFJJQU5HTEVTJyxcclxuXHRcdFx0Y291bnQ6IGdlb21ldHJ5LnBvc2l0aW9ucy5sZW5ndGhcclxuXHRcdH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHdlYmdsIHBvbHlsaW5lIG92ZXJsYXkgcmVuZGVyZXIuXHJcbiAqL1xyXG5jbGFzcyBQb2x5bGluZU92ZXJsYXlSZW5kZXJlciBleHRlbmRzIFdlYkdMT3ZlcmxheVJlbmRlcmVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFBvbHlsaW5lT3ZlcmxheVJlbmRlcmVyIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG92ZXJsYXkgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmxpbmVDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgbGluZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5saW5lV2lkdGggLSBUaGUgcGl4ZWwgd2lkdGggb2YgdGhlIGxpbmUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzdXBlcihvcHRpb25zKTtcclxuXHRcdHRoaXMubGluZUNvbG9yID0gZGVmYXVsdFRvKG9wdGlvbnMubGluZUNvbG9yLCBbIDEuMCwgMC40LCAwLjEsIDAuOCBdKTtcclxuXHRcdHRoaXMubGluZVdpZHRoID0gZGVmYXVsdFRvKG9wdGlvbnMubGluZVdpZHRoLCAyKTtcclxuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcclxuXHRcdHRoaXMubGluZXMgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byBhdHRhY2ggdGhlIG92ZXJsYXkgdG8uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UG9seWxpbmVPdmVybGF5UmVuZGVyZXJ9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uQWRkKHBsb3QpIHtcclxuXHRcdHN1cGVyLm9uQWRkKHBsb3QpO1xyXG5cdFx0dGhpcy5zaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcihTSEFERVJfR0xTTCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIG92ZXJsYXkgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIHJlbW92ZSB0aGUgb3ZlcmxheSBmcm9tLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1BvbHlsaW5lT3ZlcmxheVJlbmRlcmVyfSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRvblJlbW92ZShwbG90KSB7XHJcblx0XHRzdXBlci5vblJlbW92ZShwbG90KTtcclxuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgYW55IHVuZGVybHlpbmcgYnVmZmVycy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtQb2x5bGluZU92ZXJsYXlSZW5kZXJlcn0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0cmVmcmVzaEJ1ZmZlcnMoKSB7XHJcblx0XHRjb25zdCBjbGlwcGVkID0gdGhpcy5vdmVybGF5LmdldENsaXBwZWRHZW9tZXRyeSgpO1xyXG5cdFx0aWYgKGNsaXBwZWQpIHtcclxuXHRcdFx0dGhpcy5saW5lcyA9IGNsaXBwZWQubWFwKHBvaW50cyA9PiB7XHJcblx0XHRcdFx0Ly8gZ2VuZXJhdGUgdGhlIGJ1ZmZlclxyXG5cdFx0XHRcdHJldHVybiBjcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcywgcG9pbnRzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmxpbmVzID0gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgcGVyIGZyYW1lLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1BvbHlsaW5lT3ZlcmxheVJlbmRlcmVyfSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRkcmF3KCkge1xyXG5cdFx0aWYgKCF0aGlzLmxpbmVzKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xyXG5cdFx0Y29uc3QgbGluZXMgPSB0aGlzLmxpbmVzO1xyXG5cdFx0Y29uc3QgcGxvdCA9IHRoaXMub3ZlcmxheS5wbG90O1xyXG5cdFx0Y29uc3QgY2VsbCA9IHBsb3QuY2VsbDtcclxuXHRcdGNvbnN0IHByb2ogPSB0aGlzLmdldE9ydGhvTWF0cml4KCk7XHJcblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHBsb3Quem9vbSAtIGNlbGwuem9vbSk7XHJcblx0XHRjb25zdCBvcGFjaXR5ID0gdGhpcy5vdmVybGF5Lm9wYWNpdHk7XHJcblxyXG5cdFx0Ly8gZ2V0IHZpZXcgb2Zmc2V0IGluIGNlbGwgc3BhY2VcclxuXHRcdGNvbnN0IG9mZnNldCA9IGNlbGwucHJvamVjdChwbG90LnZpZXdwb3J0LCBwbG90Lnpvb20pO1xyXG5cclxuXHRcdC8vIHNldCBibGVuZGluZyBmdW5jXHJcblx0XHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG5cdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG5cdFx0Ly8gYmluZCBzaGFkZXJcclxuXHRcdHNoYWRlci51c2UoKTtcclxuXHJcblx0XHQvLyBzZXQgZ2xvYmFsIHVuaWZvcm1zXHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCBwcm9qKTtcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1Vmlld09mZnNldCcsIFsgb2Zmc2V0LngsIG9mZnNldC55IF0pO1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VTY2FsZScsIHNjYWxlKTtcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1TGluZVdpZHRoJywgdGhpcy5saW5lV2lkdGggLyAyKTtcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1TGluZUNvbG9yJywgdGhpcy5saW5lQ29sb3IpO1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VPcGFjaXR5Jywgb3BhY2l0eSk7XHJcblxyXG5cdFx0Ly8gZm9yIGVhY2ggcG9seWxpbmUgYnVmZmVyXHJcblx0XHRsaW5lcy5mb3JFYWNoKGJ1ZmZlciA9PiB7XHJcblx0XHRcdC8vIGRyYXcgdGhlIHBvaW50c1xyXG5cdFx0XHRidWZmZXIuYmluZCgpO1xyXG5cdFx0XHRidWZmZXIuZHJhdygpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlsaW5lT3ZlcmxheVJlbmRlcmVyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBQcml2YXRlIE1ldGhvZHNcclxuXHJcbmNvbnN0IGdldFVWT2Zmc2V0ID0gZnVuY3Rpb24oYW5jZXN0b3IsIGRlc2NlbmRhbnQpIHtcclxuXHRjb25zdCBzY2FsZSA9IDEgLyBNYXRoLnBvdygyLCBkZXNjZW5kYW50LnogLSBhbmNlc3Rvci56KTtcclxuXHRyZXR1cm4gW1xyXG5cdFx0KGRlc2NlbmRhbnQueCAqIHNjYWxlKSAtIGFuY2VzdG9yLngsXHJcblx0XHQoZGVzY2VuZGFudC55ICogc2NhbGUpIC0gYW5jZXN0b3IueSxcclxuXHRcdHNjYWxlLFxyXG5cdFx0c2NhbGVcclxuXHRdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHRpbGUgcmVuZGVyYWJsZS5cclxuICovXHJcbmNsYXNzIFRpbGVSZW5kZXJhYmxlIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFRpbGVSZW5kZXJhYmxlIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSAtIFRoZSB0aWxlIGRhdGEgdG8gYmUgcmVuZGVyZWQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gVGhlIHNjYWxlIHRvIHJlbmRlciB0aGUgdGlsZSBhdC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGlsZU9mZnNldCAtIFRoZSB0aWxlIHBpeGVsIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdXZPZmZzZXQgLSBUaGUgdGV4dHVyZSBjb29yZGluYXRlIG9mZnNldCBkZXNjcmliaW5nIHRoZSBwb3J0aW9uIG9mIHRoZSB0aWxlIHRvIHJlbmRlci5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcih0aWxlLCBzY2FsZSwgdGlsZU9mZnNldCwgdXZPZmZzZXQpIHtcclxuXHRcdHRoaXMudGlsZSA9IHRpbGU7XHJcblx0XHR0aGlzLmhhc2ggPSB0aWxlLmNvb3JkLmhhc2g7XHJcblx0XHR0aGlzLnNjYWxlID0gc2NhbGU7XHJcblx0XHR0aGlzLnRpbGVPZmZzZXQgPSB0aWxlT2Zmc2V0O1xyXG5cdFx0dGhpcy51dk9mZnNldCA9IHV2T2Zmc2V0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGUgYSBUaWxlUmVuZGVyYWJsZSBvYmplY3QgZnJvbSBhIHNwZWNpZmljIHRpbGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1RpbGV9IHRpbGUgLSBUaGUgdGlsZSBkYXRhIHRvIGJlIHJlbmRlcmVkLlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBjb29yZCAtIFRoZSB1bm5vcm1hbGl6ZWQgdGlsZSBjb29yZGluYXRlIG9mIHRoZSB0aWxlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIFRoZSBzY2FsZSB0byByZW5kZXIgdGhlIHRpbGUgYXQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbGVTaXplIC0gVGhlIHNpemUgb2YgdGhlIHRpbGUgaW4gcGl4ZWxzLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3cG9ydE9mZnNldCAtIFRoZSBvZmZzZXQgb2YgdGhlIHZpZXdwb3J0IGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUaWxlUmVuZGVyYWJsZX0gVGhlIHJlbmRlcmFibGUgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBmcm9tVGlsZSh0aWxlLCBjb29yZCwgc2NhbGUsIHRpbGVTaXplLCB2aWV3cG9ydE9mZnNldCkge1xyXG5cdFx0Y29uc3Qgc2NhbGVkVGlsZVNpemUgPSBzY2FsZSAqIHRpbGVTaXplO1xyXG5cdFx0Y29uc3QgdGlsZU9mZnNldCA9IFtcclxuXHRcdFx0KGNvb3JkLnggKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC54LFxyXG5cdFx0XHQoY29vcmQueSAqIHNjYWxlZFRpbGVTaXplKSAtIHZpZXdwb3J0T2Zmc2V0LnlcclxuXHRcdF07XHJcblx0XHRyZXR1cm4gbmV3IFRpbGVSZW5kZXJhYmxlKFxyXG5cdFx0XHR0aWxlLFxyXG5cdFx0XHRzY2FsZSxcclxuXHRcdFx0dGlsZU9mZnNldCxcclxuXHRcdFx0WyAwLCAwLCAxLCAxIF0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGUgYSBUaWxlUmVuZGVyYWJsZSBvYmplY3QgZnJvbSBhbiBhbmNlc3RvciBvZiB0aGUgdGlsZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSAtIFRoZSB0aWxlIGRhdGEgdG8gYmUgcmVuZGVyZWQuXHJcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIHVubm9ybWFsaXplZCB0aWxlIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gVGhlIHNjYWxlIHRvIHJlbmRlciB0aGUgdGlsZSBhdC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlsZVNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgdGlsZSBpbiBwaXhlbHMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZpZXdwb3J0T2Zmc2V0IC0gVGhlIG9mZnNldCBvZiB0aGUgdmlld3BvcnQgaW4gcGl4ZWxzLlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSB3YW50ZWQgLSBUaGUgY29vcmRpbmF0ZSB0aGUgdGlsZSB3aWxsIHN1YnN0aXR1ZSBmb3IuXHJcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGRlc2NlbmRhbnQgLSBUaGUgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlIHN1YnN0aXR1dGVkIHRpbGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGlsZVJlbmRlcmFibGV9IFRoZSByZW5kZXJhYmxlIG9iamVjdC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZnJvbUFuY2VzdG9yKHRpbGUsIGNvb3JkLCBzY2FsZSwgdGlsZVNpemUsIHZpZXdwb3J0T2Zmc2V0LCB3YW50ZWQsIGRlc2NlbmRhbnQpIHtcclxuXHRcdGNvbnN0IHNjYWxlZFRpbGVTaXplID0gc2NhbGUgKiB0aWxlU2l6ZTtcclxuXHRcdGNvbnN0IHRpbGVPZmZzZXQgPSBbIDAsIDAgXTtcclxuXHRcdGlmIChkZXNjZW5kYW50ID09PSB3YW50ZWQpIHtcclxuXHRcdFx0Ly8gaWYgdGhlIFwid2FudGVkXCIgdGlsZSBpcyB0aGUgc2FtZSBhcyB0aGUgXCJkZXNjZW5kYW50XCIgb2YgdGhpc1xyXG5cdFx0XHQvLyBhbmNlc3RvciwgdGhlbiB0aGVyZSBpcyBubyBwb3NpdGlvbmFsIG9mZnNldFxyXG5cdFx0XHR0aWxlT2Zmc2V0WzBdID0gKGNvb3JkLnggKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC54O1xyXG5cdFx0XHR0aWxlT2Zmc2V0WzFdID0gKGNvb3JkLnkgKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC55O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gaWYgdGhlIFwid2FudGVkXCIgdGlsZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIFwiZGVzY2VuZGFudFwiLCB3ZSBuZWVkXHJcblx0XHRcdC8vIHRvIHBvc2l0aW9uIGFuZCBzY2FsZSB0aGlzIHRpbGUgcmVsYXRpdmUgdG8gdGhlIGRlc2NlbmRhbnRcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0U2NhbGUgPSAxIC8gTWF0aC5wb3coMiwgZGVzY2VuZGFudC56IC0gd2FudGVkLnopO1xyXG5cdFx0XHRjb25zdCBvZmZzZXRYID0gKGRlc2NlbmRhbnQueCAqIG9mZnNldFNjYWxlKSAtIHdhbnRlZC54O1xyXG5cdFx0XHRjb25zdCBvZmZzZXRZID0gKGRlc2NlbmRhbnQueSAqIG9mZnNldFNjYWxlKSAtIHdhbnRlZC55O1xyXG5cdFx0XHR0aWxlT2Zmc2V0WzBdID0gKChjb29yZC54ICsgb2Zmc2V0WCkgKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC54O1xyXG5cdFx0XHR0aWxlT2Zmc2V0WzFdID0gKChjb29yZC55ICsgb2Zmc2V0WSkgKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC55O1xyXG5cdFx0XHRzY2FsZSAqPSBvZmZzZXRTY2FsZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgVGlsZVJlbmRlcmFibGUoXHJcblx0XHRcdHRpbGUsXHJcblx0XHRcdHNjYWxlLFxyXG5cdFx0XHR0aWxlT2Zmc2V0LFxyXG5cdFx0XHRnZXRVVk9mZnNldCh0aWxlLmNvb3JkLCBkZXNjZW5kYW50KSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZSBhIFRpbGVSZW5kZXJhYmxlIG9iamVjdCBmcm9tIGEgZGVzY2VuZGFudCBvZiB0aGUgdGlsZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSAtIFRoZSB0aWxlIGRhdGEgdG8gYmUgcmVuZGVyZWQuXHJcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIHVubm9ybWFsaXplZCB0aWxlIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gVGhlIHNjYWxlIHRvIHJlbmRlciB0aGUgdGlsZSBhdC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlsZVNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgdGlsZSBpbiBwaXhlbHMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZpZXdwb3J0T2Zmc2V0IC0gVGhlIG9mZnNldCBvZiB0aGUgdmlld3BvcnQgaW4gcGl4ZWxzLlxyXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSB3YW50ZWQgLSBUaGUgY29vcmRpbmF0ZSB0aGUgdGlsZSB3aWxsIHN1YnN0aXR1ZSBmb3IuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGlsZVJlbmRlcmFibGV9IFRoZSByZW5kZXJhYmxlIG9iamVjdC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZnJvbURlc2NlbmRhbnQodGlsZSwgY29vcmQsIHNjYWxlLCB0aWxlU2l6ZSwgdmlld3BvcnRPZmZzZXQsIHdhbnRlZCkge1xyXG5cdFx0Y29uc3Qgc2NhbGVkVGlsZVNpemUgPSBzY2FsZSAqIHRpbGVTaXplO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0U2NhbGUgPSAxIC8gTWF0aC5wb3coMiwgdGlsZS5jb29yZC56IC0gd2FudGVkLnopO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0WCA9ICh0aWxlLmNvb3JkLnggKiBvZmZzZXRTY2FsZSkgLSB3YW50ZWQueDtcclxuXHRcdGNvbnN0IG9mZnNldFkgPSAodGlsZS5jb29yZC55ICogb2Zmc2V0U2NhbGUpIC0gd2FudGVkLnk7XHJcblx0XHRjb25zdCB0aWxlT2Zmc2V0ID0gW1xyXG5cdFx0XHQoKGNvb3JkLnggKyBvZmZzZXRYKSAqIHNjYWxlZFRpbGVTaXplKSAtIHZpZXdwb3J0T2Zmc2V0LngsXHJcblx0XHRcdCgoY29vcmQueSArIG9mZnNldFkpICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueVxyXG5cdFx0XTtcclxuXHRcdHJldHVybiBuZXcgVGlsZVJlbmRlcmFibGUoXHJcblx0XHRcdHRpbGUsXHJcblx0XHRcdHNjYWxlICogb2Zmc2V0U2NhbGUsXHJcblx0XHRcdHRpbGVPZmZzZXQsXHJcblx0XHRcdFsgMCwgMCwgMSwgMSBdKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlIGEgVGlsZVJlbmRlcmFibGUgb2JqZWN0IGZyb20gYW4gYW5jZXN0b3Igb2YgdGhlIHRpbGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1RpbGVQYXJ0aWFsfSBwYXJ0aWFsIC0gVGhlIHRpbGUgcGFydGlhbCB0byBiZSByZW5kZXJlZC5cclxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gY29vcmQgLSBUaGUgdW5ub3JtYWxpemVkIHRpbGUgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgLSBUaGUgc2NhbGUgdG8gcmVuZGVyIHRoZSB0aWxlIGF0LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0aWxlIGluIHBpeGVscy5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmlld3BvcnRPZmZzZXQgLSBUaGUgb2Zmc2V0IG9mIHRoZSB2aWV3cG9ydCBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGlsZVJlbmRlcmFibGV9IFRoZSByZW5kZXJhYmxlIG9iamVjdC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZnJvbUFuY2VzdG9yUGFydGlhbChwYXJ0aWFsLCBjb29yZCwgc2NhbGUsIHRpbGVTaXplLCB2aWV3cG9ydE9mZnNldCkge1xyXG5cdFx0Y29uc3QgdGlsZSA9IHBhcnRpYWwudGlsZTsgLy8gdGlsZSB3ZSBoYXZlXHJcblx0XHRjb25zdCB0YXJnZXQgPSBwYXJ0aWFsLnRhcmdldDsgLy8gdGlsZSB3ZSB3YW50ZWRcclxuXHRcdGNvbnN0IHJlbGF0aXZlID0gcGFydGlhbC5yZWxhdGl2ZTsgLy8gd2hlcmUgdG8gcG9zaXRpb24gdGhlIHRpbGUgcmVsYXRpdmUgdG9cclxuXHRcdGNvbnN0IHNjYWxlZFRpbGVTaXplID0gc2NhbGUgKiB0aWxlU2l6ZTtcclxuXHRcdGNvbnN0IHRpbGVPZmZzZXQgPSBbIDAsIDAgXTtcclxuXHRcdGlmIChyZWxhdGl2ZSA9PT0gcGFydGlhbC50YXJnZXQpIHtcclxuXHRcdFx0Ly8gaWYgdGhlIFwidGFyZ2V0XCIgdGlsZSBpcyB0aGUgc2FtZSBhcyB0aGUgXCJyZWxhdGl2ZVwiIG9mIHRoaXNcclxuXHRcdFx0Ly8gYW5jZXN0b3IsIHRoZW4gdGhlcmUgaXMgbm8gcG9zaXRpb25hbCBvZmZzZXRcclxuXHRcdFx0dGlsZU9mZnNldFswXSA9IChjb29yZC54ICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueDtcclxuXHRcdFx0dGlsZU9mZnNldFsxXSA9IChjb29yZC55ICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGlmIHRoZSBcInRhcmdldFwiIHRpbGUgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBcInJlbGF0aXZlXCIsIHdlIG5lZWRcclxuXHRcdFx0Ly8gdG8gcG9zaXRpb24gYW5kIHNjYWxlIHRoaXMgdGlsZSByZWxhdGl2ZSB0byB0aGUgcmVsYXRpdmVcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0U2NhbGUgPSAxIC8gTWF0aC5wb3coMiwgcmVsYXRpdmUueiAtIHRhcmdldC56KTtcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0WCA9IChyZWxhdGl2ZS54ICogb2Zmc2V0U2NhbGUpIC0gdGFyZ2V0Lng7XHJcblx0XHRcdGNvbnN0IG9mZnNldFkgPSAocmVsYXRpdmUueSAqIG9mZnNldFNjYWxlKSAtIHRhcmdldC55O1xyXG5cdFx0XHR0aWxlT2Zmc2V0WzBdID0gKChjb29yZC54ICsgb2Zmc2V0WCkgKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC54O1xyXG5cdFx0XHR0aWxlT2Zmc2V0WzFdID0gKChjb29yZC55ICsgb2Zmc2V0WSkgKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC55O1xyXG5cdFx0XHRzY2FsZSAqPSBvZmZzZXRTY2FsZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgVGlsZVJlbmRlcmFibGUoXHJcblx0XHRcdHRpbGUsXHJcblx0XHRcdHNjYWxlLFxyXG5cdFx0XHR0aWxlT2Zmc2V0LFxyXG5cdFx0XHRnZXRVVk9mZnNldCh0aWxlLmNvb3JkLCByZWxhdGl2ZSkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGUgYSBUaWxlUmVuZGVyYWJsZSBvYmplY3QgZnJvbSBhIGRlc2NlbmRhbnQgb2YgdGhlIHRpbGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1RpbGVQYXJ0aWFsfSBwYXJ0aWFsIC0gVGhlIHRpbGUgcGFydGlhbCB0byBiZSByZW5kZXJlZC5cclxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gY29vcmQgLSBUaGUgdW5ub3JtYWxpemVkIHRpbGUgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgLSBUaGUgc2NhbGUgdG8gcmVuZGVyIHRoZSB0aWxlIGF0LlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0aWxlIGluIHBpeGVscy5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmlld3BvcnRPZmZzZXQgLSBUaGUgb2Zmc2V0IG9mIHRoZSB2aWV3cG9ydCBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGlsZVJlbmRlcmFibGV9IFRoZSByZW5kZXJhYmxlIG9iamVjdC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZnJvbURlc2NlbmRhbnRQYXJ0aWFsKHBhcnRpYWwsIGNvb3JkLCBzY2FsZSwgdGlsZVNpemUsIHZpZXdwb3J0T2Zmc2V0KSB7XHJcblx0XHRjb25zdCB0aWxlID0gcGFydGlhbC50aWxlOyAvLyB0aWxlIHdlIGhhdmVcclxuXHRcdGNvbnN0IHRhcmdldCA9IHBhcnRpYWwudGFyZ2V0OyAvLyB0aWxlIHdlIHdhbnRlZFxyXG5cdFx0Y29uc3Qgc2NhbGVkVGlsZVNpemUgPSBzY2FsZSAqIHRpbGVTaXplO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0U2NhbGUgPSAxIC8gTWF0aC5wb3coMiwgdGlsZS5jb29yZC56IC0gdGFyZ2V0LnopO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0WCA9ICh0aWxlLmNvb3JkLnggKiBvZmZzZXRTY2FsZSkgLSB0YXJnZXQueDtcclxuXHRcdGNvbnN0IG9mZnNldFkgPSAodGlsZS5jb29yZC55ICogb2Zmc2V0U2NhbGUpIC0gdGFyZ2V0Lnk7XHJcblx0XHRjb25zdCB0aWxlT2Zmc2V0ID0gW1xyXG5cdFx0XHQoKGNvb3JkLnggKyBvZmZzZXRYKSAqIHNjYWxlZFRpbGVTaXplKSAtIHZpZXdwb3J0T2Zmc2V0LngsXHJcblx0XHRcdCgoY29vcmQueSArIG9mZnNldFkpICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueVxyXG5cdFx0XTtcclxuXHRcdHJldHVybiBuZXcgVGlsZVJlbmRlcmFibGUoXHJcblx0XHRcdHRpbGUsXHJcblx0XHRcdHNjYWxlICogb2Zmc2V0U2NhbGUsXHJcblx0XHRcdHRpbGVPZmZzZXQsXHJcblx0XHRcdFsgMCwgMCwgMSwgMSBdKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIHRoZSBgdXZPZmZzZXRgIGFuZCBgdGlsZU9mZnNldGAgcGFyYW1ldGVycyB0byB0aGUgY2FudmFzXHJcblx0ICogY29vcmRpbmF0ZSBzeXN0ZW0sIHdpdGggWzAsIDBdIGJlaW5nIHRoZSB0b3AtbGVmdCBjb3JuZXIuIFRoZSBjb252ZXJzaW9uXHJcblx0ICogaXMgZG9uZSBpbi1wbGFjZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3cG9ydCAtIFRoZSBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSB2aWV3cG9ydC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlsZVNpemUgLSBUaGUgc2l6ZSBvZiBlYWNoIHRpbGUgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RpbGVSZW5kZXJhYmxlfSBUaGUgcmVuZGVyYWJsZSBvYmplY3QuXHJcblx0ICovXHJcblx0dG9DYW52YXModmlld3BvcnQsIHRpbGVTaXplKSB7XHJcblx0XHQvLyBmbGlwIHkgY29tcG9uZW50IG9mIHV2IG9mZnNldFxyXG5cdFx0Y29uc3QgdXZPZmZzZXQgPSB0aGlzLnV2T2Zmc2V0O1xyXG5cdFx0dXZPZmZzZXRbMV0gPSAoMSAtIHV2T2Zmc2V0WzJdIC0gdXZPZmZzZXRbMV0pO1xyXG5cdFx0Ly8gZmxpcCB5IGNvbXBvbmVudCBvZiB0aWxlIG9mZnNldFxyXG5cdFx0Y29uc3QgdGlsZU9mZnNldCA9IHRoaXMudGlsZU9mZnNldDtcclxuXHRcdHRpbGVPZmZzZXRbMV0gPSB2aWV3cG9ydC5oZWlnaHQgLSB0aWxlT2Zmc2V0WzFdIC0gKHRpbGVTaXplICogdGhpcy5zY2FsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZVJlbmRlcmFibGU7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L0V2ZW50VHlwZScpO1xyXG5jb25zdCBSVHJlZVB5cmFtaWQgPSByZXF1aXJlKCcuLi8uLi9nZW9tZXRyeS9SVHJlZVB5cmFtaWQnKTtcclxuY29uc3QgUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9SZW5kZXJlcicpO1xyXG5jb25zdCBUaWxlUmVuZGVyYWJsZSA9IHJlcXVpcmUoJy4vVGlsZVJlbmRlcmFibGUnKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuLyoqXHJcbiAqIFRpbGUgaW5kZXggaGFuZGxlciBzeW1ib2wuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxyXG4gKi9cclxuY29uc3QgVElMRV9JTkRFWCA9IFN5bWJvbCgpO1xyXG5cclxuLyoqXHJcbiAqIFRpbGUgdW5pbmRleCBoYW5kbGVyIHN5bWJvbC5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtTeW1ib2x9XHJcbiAqL1xyXG5jb25zdCBUSUxFX1VOSU5ERVggPSBTeW1ib2woKTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB0aWxlIHJlbmRlcmVyLlxyXG4gKi9cclxuY2xhc3MgVGlsZVJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgVGlsZVJlbmRlcmVyIG9iamVjdC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHN1cGVyKCk7XHJcblx0XHR0aGlzW1RJTEVfSU5ERVhdID0gbmV3IE1hcCgpO1xyXG5cdFx0dGhpc1tUSUxFX1VOSU5ERVhdID0gbmV3IE1hcCgpO1xyXG5cdFx0dGhpcy5sYXllciA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBsYXllciBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciB0byBhdHRhY2ggdGhlIHJlbmRlcmVyIHRvLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RpbGVSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uQWRkKGxheWVyKSB7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHRocm93ICdObyBsYXllciBwcm92aWRlZCBhcyBhcmd1bWVudCc7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxheWVyID0gbGF5ZXI7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciB0byByZW1vdmUgdGhlIHJlbmRlcmVyIGZyb20uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGlsZVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25SZW1vdmUobGF5ZXIpIHtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0dGhyb3cgJ05vIGxheWVyIHByb3ZpZGVkIGFzIGFyZ3VtZW50JztcclxuXHRcdH1cclxuXHRcdHRoaXMubGF5ZXIgPSBudWxsO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGFuIHJ0cmVlIHB5cmFtaWQgb2JqZWN0LiBDcmVhdGVzIGFuZCBhdHRhY2hlcyB0aGUgbmVjZXNzYXJ5XHJcblx0ICogZXZlbnQgaGFuZGxlcnMgdG8gYWRkIGFuZCByZW1vdmUgZGF0YSBmcm9tIHRoZSBydHJlZSBhY2NvcmRpbmdseS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSByLXRyZWUgcHlyYW1pZC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5ub2RlQ2FwYWNpdHkgLSBUaGUgbm9kZSBjYXBhY2l0eSBvZiB0aGUgcnRyZWUuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5jcmVhdGVDb2xsaWRhYmxlcyAtIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgY29sbGlkYWJsZXMgZnJvbSBhIHRpbGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UlRyZWVQeXJhbWlkfSBUaGUgci10cmVlIHB5cmFtaWQgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGNyZWF0ZVJUcmVlUHlyYW1pZChvcHRpb25zID0ge30pIHtcclxuXHRcdGNvbnN0IGNyZWF0ZUNvbGxpZGFibGVzID0gb3B0aW9ucy5jcmVhdGVDb2xsaWRhYmxlcztcclxuXHRcdGlmICghY3JlYXRlQ29sbGlkYWJsZXMpIHtcclxuXHRcdFx0dGhyb3cgJ2BvcHRpb25zLmNyZWF0ZUNvbGxpZGFibGVzYCBhcmd1bWVudCBpcyBtaXNzaW5nJztcclxuXHRcdH1cclxuXHRcdC8vIGNyZWF0ZSBydHJlZSBweXJhbWlkXHJcblx0XHRjb25zdCBweXJhbWlkID0gbmV3IFJUcmVlUHlyYW1pZCh7XHJcblx0XHRcdG5vZGVDYXBhY2l0eTogb3B0aW9ucy5ub2RlQ2FwYWNpdHlcclxuXHRcdH0pO1xyXG5cdFx0Ly8gY3JlYXRlIGhhbmRsZXJzXHJcblx0XHRjb25zdCBpbmRleCA9IGV2ZW50ID0+IHtcclxuXHRcdFx0Y29uc3QgdGlsZSA9IGV2ZW50LnRpbGU7XHJcblx0XHRcdGNvbnN0IGNvb3JkID0gdGlsZS5jb29yZDtcclxuXHRcdFx0Y29uc3QgdGlsZVNpemUgPSB0aGlzLmxheWVyLnBsb3QudGlsZVNpemU7XHJcblx0XHRcdGNvbnN0IHhPZmZzZXQgPSBjb29yZC54ICogdGlsZVNpemU7XHJcblx0XHRcdGNvbnN0IHlPZmZzZXQgPSBjb29yZC55ICogdGlsZVNpemU7XHJcblx0XHRcdGNvbnN0IGNvbGxpZGFibGVzID0gY3JlYXRlQ29sbGlkYWJsZXModGlsZSwgeE9mZnNldCwgeU9mZnNldCk7XHJcblx0XHRcdHB5cmFtaWQuaW5zZXJ0KGNvb3JkLCBjb2xsaWRhYmxlcyk7XHJcblx0XHR9O1xyXG5cdFx0Y29uc3QgdW5pbmRleCA9IGV2ZW50ID0+IHtcclxuXHRcdFx0cHlyYW1pZC5yZW1vdmUoZXZlbnQudGlsZS5jb29yZCk7XHJcblx0XHR9O1xyXG5cdFx0Ly8gYXR0YWNoIGhhbmRsZXJzXHJcblx0XHR0aGlzLmxheWVyLm9uKEV2ZW50VHlwZS5USUxFX0FERCwgaW5kZXgpO1xyXG5cdFx0dGhpcy5sYXllci5vbihFdmVudFR5cGUuVElMRV9SRU1PVkUsIHVuaW5kZXgpO1xyXG5cdFx0Ly8gc3RvcmUgdGhlIGhhbmRsZXJzIHVuZGVyIHRoZSBhdGxhc1xyXG5cdFx0dGhpc1tUSUxFX0lOREVYXS5zZXQocHlyYW1pZCwgaW5kZXgpO1xyXG5cdFx0dGhpc1tUSUxFX1VOSU5ERVhdLnNldChweXJhbWlkLCB1bmluZGV4KTtcclxuXHRcdHJldHVybiBweXJhbWlkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVzdHJveXMgYSB2ZXJ0ZXggYXRsYXMgb2JqZWN0IGFuZCByZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyB1c2VkIHRvIGFkZFxyXG5cdCAqIGFuZCByZW1vdmUgZGF0YSBmcm9tIHRoZSBhdGxhcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UlRyZWVQeXJhbWlkfSBweXJhbWlkIC0gVGhlIHItdHJlZSBweXJhbWlkIG9iamVjdCB0byBkZXN0cm95LlxyXG5cdCAqL1xyXG5cdGRlc3Ryb3lSVHJlZVB5cmFtaWQocHlyYW1pZCkge1xyXG5cdFx0Ly8gZGV0YWNoIGhhbmRsZXJzXHJcblx0XHR0aGlzLmxheWVyLnJlbW92ZUxpc3RlbmVyKEV2ZW50VHlwZS5USUxFX0FERCwgdGhpc1tUSUxFX0lOREVYXS5nZXQocHlyYW1pZCkpO1xyXG5cdFx0dGhpcy5sYXllci5yZW1vdmVMaXN0ZW5lcihFdmVudFR5cGUuVElMRV9SRU1PVkUsIHRoaXNbVElMRV9VTklOREVYXS5nZXQocHlyYW1pZCkpO1xyXG5cdFx0Ly8gcmVtb3ZlIGhhbmRsZXJzXHJcblx0XHR0aGlzW1RJTEVfSU5ERVhdLmRlbGV0ZShweXJhbWlkKTtcclxuXHRcdHRoaXNbVElMRV9VTklOREVYXS5kZWxldGUocHlyYW1pZCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB0aWxlIHJlbmRlcmFibGVzIGZvciB0aGUgdW5kZXJseWluZyBsYXllci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIHRpbGUgcmVuZGVyYWJsZXMuXHJcblx0ICovXHJcblx0Z2V0UmVuZGVyYWJsZXMoKSB7XHJcblx0XHRjb25zdCBwbG90ID0gdGhpcy5sYXllci5wbG90O1xyXG5cdFx0Y29uc3QgcHlyYW1pZCA9IHRoaXMubGF5ZXIucHlyYW1pZDtcclxuXHRcdGNvbnN0IHRpbGVTaXplID0gcGxvdC50aWxlU2l6ZTtcclxuXHRcdGNvbnN0IHpvb20gPSBwbG90Lnpvb207XHJcblx0XHRjb25zdCB2aWV3cG9ydCA9IHBsb3QuZ2V0Vmlld3BvcnRQaXhlbE9mZnNldCgpO1xyXG5cdFx0Y29uc3QgY29vcmRzID0gcGxvdC5nZXRWaXNpYmxlQ29vcmRzKCk7XHJcblx0XHRjb25zdCByZW5kZXJhYmxlcyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaT0wOyBpPGNvb3Jkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjb25zdCBjb29yZCA9IGNvb3Jkc1tpXTtcclxuXHRcdFx0Y29uc3QgbmNvb3JkID0gY29vcmQubm9ybWFsaXplKCk7XHJcblx0XHRcdC8vIGNoZWNrIGlmIHdlIGhhdmUgdGhlIHRpbGVcclxuXHRcdFx0Y29uc3QgdGlsZSA9IHB5cmFtaWQuZ2V0KG5jb29yZCk7XHJcblx0XHRcdGlmICh0aWxlKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tIC0gY29vcmQueik7XHJcblx0XHRcdFx0Y29uc3QgcmVuZGVyYWJsZSA9IFRpbGVSZW5kZXJhYmxlLmZyb21UaWxlKFxyXG5cdFx0XHRcdFx0dGlsZSxcclxuXHRcdFx0XHRcdGNvb3JkLFxyXG5cdFx0XHRcdFx0c2NhbGUsXHJcblx0XHRcdFx0XHR0aWxlU2l6ZSxcclxuXHRcdFx0XHRcdHZpZXdwb3J0KTtcclxuXHRcdFx0XHRyZW5kZXJhYmxlcy5wdXNoKHJlbmRlcmFibGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVuZGVyYWJsZXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB0aWxlIHJlbmRlcmFibGVzIGZvciB0aGUgdW5kZXJseWluZyBsYXllciBhdCB0aGUgY2xvc2VzdFxyXG5cdCAqIGF2YWlsYWJsZSBsZXZlbC1vZi1kZXRhaWwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiB0aWxlIHJlbmRlcmFibGVzLlxyXG5cdCAqL1xyXG5cdGdldFJlbmRlcmFibGVzTE9EKCkge1xyXG5cdFx0Y29uc3QgcGxvdCA9IHRoaXMubGF5ZXIucGxvdDtcclxuXHRcdGNvbnN0IHB5cmFtaWQgPSB0aGlzLmxheWVyLnB5cmFtaWQ7XHJcblx0XHRjb25zdCB0aWxlU2l6ZSA9IHBsb3QudGlsZVNpemU7XHJcblx0XHRjb25zdCB6b29tID0gcGxvdC56b29tO1xyXG5cdFx0Y29uc3Qgdmlld3BvcnQgPSBwbG90LmdldFZpZXdwb3J0UGl4ZWxPZmZzZXQoKTtcclxuXHRcdGNvbnN0IGNvb3JkcyA9IHBsb3QuZ2V0VmlzaWJsZUNvb3JkcygpO1xyXG5cdFx0Y29uc3QgcmVuZGVyYWJsZXMgPSBbXTtcclxuXHRcdGZvciAobGV0IGk9MDsgaTxjb29yZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgY29vcmQgPSBjb29yZHNbaV07XHJcblx0XHRcdGNvbnN0IG5jb29yZCA9IGNvb3JkLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20gLSBjb29yZC56KTtcclxuXHRcdFx0Ly8gY2hlY2sgaWYgd2UgaGF2ZSBhbnkgdGlsZSBMT0QgYXZhaWxhYmxlXHJcblx0XHRcdGNvbnN0IHBhcnRpYWxzID0gcHlyYW1pZC5nZXRBdmFpbGFibGVMT0QobmNvb3JkKTtcclxuXHRcdFx0aWYgKHBhcnRpYWxzKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgaj0wOyBqPHBhcnRpYWxzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRjb25zdCBwYXJ0aWFsID0gcGFydGlhbHNbal07XHJcblx0XHRcdFx0XHRjb25zdCB0aWxlID0gcGFydGlhbC50aWxlO1xyXG5cdFx0XHRcdFx0bGV0IHJlbmRlcmFibGU7XHJcblx0XHRcdFx0XHRpZiAodGlsZS5jb29yZC56ID09PSBjb29yZC56KSB7XHJcblx0XHRcdFx0XHRcdC8vIGV4YWN0IHRpbGVcclxuXHRcdFx0XHRcdFx0cmVuZGVyYWJsZSA9IFRpbGVSZW5kZXJhYmxlLmZyb21UaWxlKFxyXG5cdFx0XHRcdFx0XHRcdHRpbGUsXHJcblx0XHRcdFx0XHRcdFx0Y29vcmQsXHJcblx0XHRcdFx0XHRcdFx0c2NhbGUsXHJcblx0XHRcdFx0XHRcdFx0dGlsZVNpemUsXHJcblx0XHRcdFx0XHRcdFx0dmlld3BvcnQpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aWxlLmNvb3JkLnogPCBjb29yZC56KSB7XHJcblx0XHRcdFx0XHRcdC8vIGFuY2VzdG9yIG9mIHRoZSB0aWxlXHJcblx0XHRcdFx0XHRcdHJlbmRlcmFibGUgPSBUaWxlUmVuZGVyYWJsZS5mcm9tQW5jZXN0b3JQYXJ0aWFsKFxyXG5cdFx0XHRcdFx0XHRcdHBhcnRpYWwsXHJcblx0XHRcdFx0XHRcdFx0Y29vcmQsXHJcblx0XHRcdFx0XHRcdFx0c2NhbGUsXHJcblx0XHRcdFx0XHRcdFx0dGlsZVNpemUsXHJcblx0XHRcdFx0XHRcdFx0dmlld3BvcnQpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Ly8gZGVzY2VuZGFudCBvZiB0aGUgdGlsZVxyXG5cdFx0XHRcdFx0XHRyZW5kZXJhYmxlID0gVGlsZVJlbmRlcmFibGUuZnJvbURlc2NlbmRhbnRQYXJ0aWFsKFxyXG5cdFx0XHRcdFx0XHRcdHBhcnRpYWwsXHJcblx0XHRcdFx0XHRcdFx0Y29vcmQsXHJcblx0XHRcdFx0XHRcdFx0c2NhbGUsXHJcblx0XHRcdFx0XHRcdFx0dGlsZVNpemUsXHJcblx0XHRcdFx0XHRcdFx0dmlld3BvcnQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmVuZGVyYWJsZXMucHVzaChyZW5kZXJhYmxlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZW5kZXJhYmxlcztcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGlsZVJlbmRlcmVyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XHJcbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L0V2ZW50VHlwZScpO1xyXG5jb25zdCBTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi93ZWJnbC9zaGFkZXIvU2hhZGVyJyk7XHJcbmNvbnN0IFRleHR1cmVBcnJheSA9IHJlcXVpcmUoJy4uLy4uL3dlYmdsL3RleHR1cmUvVGV4dHVyZUFycmF5Jyk7XHJcbmNvbnN0IFZlcnRleEF0bGFzID0gcmVxdWlyZSgnLi4vLi4vd2ViZ2wvdmVydGV4L1ZlcnRleEF0bGFzJyk7XHJcbmNvbnN0IFRpbGVSZW5kZXJlciA9IHJlcXVpcmUoJy4vVGlsZVJlbmRlcmVyJyk7XHJcblxyXG4vLyBDb25zdGFudHNcclxuXHJcbi8qKlxyXG4gKiBUaWxlIGFkZCBoYW5kbGVyIHN5bWJvbC5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtTeW1ib2x9XHJcbiAqL1xyXG5jb25zdCBUSUxFX0FERCA9IFN5bWJvbCgpO1xyXG5cclxuLyoqXHJcbiAqIFRpbGUgcmVtb3ZlIGhhbmRsZXIgc3ltYm9sLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge1N5bWJvbH1cclxuICovXHJcbmNvbnN0IFRJTEVfUkVNT1ZFID0gU3ltYm9sKCk7XHJcblxyXG4vLyBQcml2YXRlIE1ldGhvZHNcclxuXHJcbmNvbnN0IGFkZFRpbGVUb1RleHR1cmVBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCB0aWxlKSB7XHJcblx0YXJyYXkuc2V0KHRpbGUuY29vcmQuaGFzaCwgdGlsZS5kYXRhKTtcclxufTtcclxuXHJcbmNvbnN0IHJlbW92ZVRpbGVGcm9tVGV4dHVyZUFycmF5ID0gZnVuY3Rpb24oYXJyYXksIHRpbGUpIHtcclxuXHRhcnJheS5kZWxldGUodGlsZS5jb29yZC5oYXNoKTtcclxufTtcclxuXHJcbmNvbnN0IGFkZFRpbGVUb1ZlcnRleEF0bGFzID0gZnVuY3Rpb24oYXRsYXMsIHRpbGUpIHtcclxuXHRhdGxhcy5zZXQoXHJcblx0XHR0aWxlLmNvb3JkLmhhc2gsXHJcblx0XHR0aWxlLmRhdGEsXHJcblx0XHR0aWxlLmRhdGEubGVuZ3RoIC8gYXRsYXMuc3RyaWRlKTtcclxufTtcclxuXHJcbmNvbnN0IHJlbW92ZVRpbGVGcm9tVmVydGV4QXRsYXMgPSBmdW5jdGlvbihhdGxhcywgdGlsZSkge1xyXG5cdGF0bGFzLmRlbGV0ZSh0aWxlLmNvb3JkLmhhc2gpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHdlYmdsIHRpbGUgcmVuZGVyZXIuXHJcbiAqL1xyXG5jbGFzcyBXZWJHTFRpbGVSZW5kZXJlciBleHRlbmRzIFRpbGVSZW5kZXJlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBXZWJHTFRpbGVSZW5kZXJlciBvYmplY3QuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5nbCA9IG51bGw7XHJcblx0XHR0aGlzW1RJTEVfQUREXSA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXNbVElMRV9SRU1PVkVdID0gbmV3IE1hcCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYXR0YWNoZWQgdG8gYSBwbG90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYXR0YWNoIHRoZSByZW5kZXJlciB0by5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtXZWJHTFRpbGVSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uQWRkKGxheWVyKSB7XHJcblx0XHRzdXBlci5vbkFkZChsYXllcik7XHJcblx0XHR0aGlzLmdsID0gdGhpcy5sYXllci5wbG90LmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIHRvIHJlbW92ZSB0aGUgcmVuZGVyZXIgZnJvbS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtXZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25SZW1vdmUobGF5ZXIpIHtcclxuXHRcdHRoaXMuZ2wgPSBudWxsO1xyXG5cdFx0c3VwZXIub25SZW1vdmUobGF5ZXIpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSB2aWV3cG9ydC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IFRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXHJcblx0ICovXHJcblx0Z2V0T3J0aG9NYXRyaXgoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllci5wbG90LmdldE9ydGhvTWF0cml4KCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFNoYWRlciBvYmplY3QgdXNpbmcgdGhlIHJlbmRlcmVycyBpbnRlcm5hbFxyXG5cdCAqIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgLSBUaGUgc2hhZGVyIHBhcmFtIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlLmNvbW1vbiAtIENvbW1vbiBnbHNsIHRvIGJlIHNoYXJlZCBieSBib3RoIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlLnZlcnQgLSBUaGUgdmVydGV4IHNoYWRlciBnbHNsLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UuZnJhZyAtIFRoZSBmcmFnbWVudCBzaGFkZXIgZ2xzbC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtTaGFkZXJ9IFRoZSBzaGFkZXIgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGNyZWF0ZVNoYWRlcihzb3VyY2UpIHtcclxuXHRcdHJldHVybiBuZXcgU2hhZGVyKHRoaXMuZ2wsIHNvdXJjZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgdGV4dHVyZSBhcnJheSBvZiBhcHByb3ByaWF0ZSBzaXplIGZvciB0aGUgbGF5ZXIgcHlyYW1pZCB1c2luZ1xyXG5cdCAqIHRoZSBwcm92aWRlZCB0ZXh0dXJlIHNpemUuIENyZWF0ZXMgYW5kIGF0dGFjaGVzIHRoZSBuZWNlc3NhcnkgZXZlbnRcclxuXHQgKiBoYW5kbGVycyB0byBhZGQgYW5kIHJlbW92ZSBkYXRhIGZyb20gdGhlIGFycmF5IGFjY29yZGluZ2x5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHRleHR1cmUgYXJyYXkuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2h1bmtTaXplIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHRpbGUgdGV4dHVyZS5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mb3JtYXQgLSBUaGUgdGV4dHVyZSBwaXhlbCBmb3JtYXQuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHlwZSAtIFRoZSB0ZXh0dXJlIHBpeGVsIGNvbXBvbmVudCB0eXBlLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cclxuXHQgKiBAcGFyYW0ge2Jvb2x9IG9wdGlvbnMuaW52ZXJ0WSAtIFdoZXRoZXIgb3Igbm90IGludmVydC15IGlzIGVuYWJsZWQuXHJcblx0ICogQHBhcmFtIHtib29sfSBvcHRpb25zLnByZW11bHRpcGx5QWxwaGEgLSBXaGV0aGVyIG9yIG5vdCBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25BZGQgLSBUaGUgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiBhIHRpbGUgaXMgYWRkZWQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblJlbW92ZSAtIFRoZSBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RleHR1cmVBcnJheX0gVGhlIHRleHR1cmUgYXJyYXkgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGNyZWF0ZVRleHR1cmVBcnJheShvcHRpb25zID0ge30pIHtcclxuXHRcdC8vIGNyZWF0ZSB0ZXh0dXJlIGFycmF5XHJcblx0XHRjb25zdCBhcnJheSA9IG5ldyBUZXh0dXJlQXJyYXkoXHJcblx0XHRcdHRoaXMuZ2wsXHJcblx0XHRcdHtcclxuXHRcdFx0XHQvLyBzZXQgdGV4dHVyZSBwYXJhbXNcclxuXHRcdFx0XHRmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LFxyXG5cdFx0XHRcdHR5cGU6IG9wdGlvbnMudHlwZSxcclxuXHRcdFx0XHRmaWx0ZXI6IG9wdGlvbnMuZmlsdGVyLFxyXG5cdFx0XHRcdGludmVydFk6IG9wdGlvbnMuaW52ZXJ0WSxcclxuXHRcdFx0XHRwcmVtdWx0aXBseUFscGhhOiBvcHRpb25zLnByZW11bHRpcGx5QWxwaGFcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdC8vIHNldCBudW0gY2h1bmtzIHRvIGJlIGFibGUgdG8gZml0IHRoZSBjYXBhY2l0eSBvZiB0aGUgcHlyYW1pZFxyXG5cdFx0XHRcdG51bUNodW5rczogdGhpcy5sYXllci5weXJhbWlkLmdldENhcGFjaXR5KCksXHJcblx0XHRcdFx0Y2h1bmtTaXplOiBvcHRpb25zLmNodW5rU2l6ZVxyXG5cdFx0XHR9KTtcclxuXHRcdC8vIGNyZWF0ZSBoYW5kbGVyc1xyXG5cdFx0Y29uc3Qgb25BZGQgPSBkZWZhdWx0VG8ob3B0aW9ucy5vbkFkZCwgYWRkVGlsZVRvVGV4dHVyZUFycmF5KTtcclxuXHRcdGNvbnN0IG9uUmVtb3ZlID0gZGVmYXVsdFRvKG9wdGlvbnMub25SZW1vdmUsIHJlbW92ZVRpbGVGcm9tVGV4dHVyZUFycmF5KTtcclxuXHRcdGNvbnN0IGFkZCA9IGV2ZW50ID0+IHtcclxuXHRcdFx0b25BZGQoYXJyYXksIGV2ZW50LnRpbGUpO1xyXG5cdFx0fTtcclxuXHRcdGNvbnN0IHJlbW92ZSA9IGV2ZW50ID0+IHtcclxuXHRcdFx0b25SZW1vdmUoYXJyYXksIGV2ZW50LnRpbGUpO1xyXG5cdFx0fTtcclxuXHRcdC8vIGF0dGFjaCBoYW5kbGVyc1xyXG5cdFx0dGhpcy5sYXllci5vbihFdmVudFR5cGUuVElMRV9BREQsIGFkZCk7XHJcblx0XHR0aGlzLmxheWVyLm9uKEV2ZW50VHlwZS5USUxFX1JFTU9WRSwgcmVtb3ZlKTtcclxuXHRcdC8vIHN0b3JlIHRoZSBoYW5kbGVycyB1bmRlciB0aGUgYXJyYXlcclxuXHRcdHRoaXNbVElMRV9BRERdLnNldChhcnJheSwgYWRkKTtcclxuXHRcdHRoaXNbVElMRV9SRU1PVkVdLnNldChhcnJheSwgcmVtb3ZlKTtcclxuXHRcdHJldHVybiBhcnJheTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlc3Ryb3lzIGEgdGV4dHVyZSBhcnJheSBvYmplY3QgYW5kIHJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIHVzZWQgdG9cclxuXHQgKiBhZGQgYW5kIHJlbW92ZSBkYXRhIGZyb20gdGhlIGFycmF5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUZXh0dXJlQXJyYXl9IGFycmF5IC0gVGhlIHRleHR1cmUgYXJyYXkgdG8gZGVzdHJveS5cclxuXHQgKi9cclxuXHRkZXN0cm95VGV4dHVyZUFycmF5KGFycmF5KSB7XHJcblx0XHQvLyBkZXRhY2ggaGFuZGxlcnNcclxuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTGlzdGVuZXIoRXZlbnRUeXBlLlRJTEVfQURELCB0aGlzW1RJTEVfQUREXS5nZXQoYXJyYXkpKTtcclxuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTGlzdGVuZXIoRXZlbnRUeXBlLlRJTEVfUkVNT1ZFLCB0aGlzW1RJTEVfUkVNT1ZFXS5nZXQoYXJyYXkpKTtcclxuXHRcdC8vIHJlbW92ZSBoYW5kbGVyc1xyXG5cdFx0dGhpc1tUSUxFX0FERF0uZGVsZXRlKGFycmF5KTtcclxuXHRcdHRoaXNbVElMRV9SRU1PVkVdLmRlbGV0ZShhcnJheSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgdmVydGV4IGF0bGFzIG9mIGFwcHJvcHJpYXRlIHNpemUgZm9yIHRoZSBsYXllciBweXJhbWlkIHVzaW5nXHJcblx0ICogdGhlIHByb3ZpZGVkIGF0dHJpYnV0ZSBwb2ludGVycy4gQ3JlYXRlcyBhbmQgYXR0YWNoZXMgdGhlIG5lY2Vzc2FyeVxyXG5cdCAqIGV2ZW50IGhhbmRsZXJzIHRvIGFkZCBhbmQgcmVtb3ZlIGRhdGEgZnJvbSB0aGUgYXRsYXMgYWNjb3JkaW5nbHkuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgdmVydGV4IGF0bGFzLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmF0dHJpYnV0ZVBvaW50ZXJzIC0gVGhlIHZlcnRleCBhdHRyaWJ1dGUgcG9pbnRlcnMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2h1bmtTaXplIC0gVGhlIHNpemUgb2YgYSBzaW5nbGUgY2h1bmssIGluIHZlcnRpY2VzLlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25BZGQgLSBUaGUgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiBhIHRpbGUgaXMgYWRkZWQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblJlbW92ZSAtIFRoZSBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1ZlcnRleEF0bGFzfSBUaGUgdmVydGV4IGF0bGFzIG9iamVjdC5cclxuXHQgKi9cclxuXHRjcmVhdGVWZXJ0ZXhBdGxhcyhvcHRpb25zID0ge30pIHtcclxuXHRcdC8vIGNyZWF0ZSB2ZXJ0ZXggYXRsYXNcclxuXHRcdGNvbnN0IGF0bGFzID0gbmV3IFZlcnRleEF0bGFzKFxyXG5cdFx0XHR0aGlzLmdsLFxyXG5cdFx0XHRvcHRpb25zLmF0dHJpYnV0ZVBvaW50ZXJzLFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0Ly8gc2V0IG51bSBjaHVua3MgdG8gYmUgYWJsZSB0byBmaXQgdGhlIGNhcGFjaXR5IG9mIHRoZSBweXJhbWlkXHJcblx0XHRcdFx0bnVtQ2h1bmtzOiB0aGlzLmxheWVyLnB5cmFtaWQuZ2V0Q2FwYWNpdHkoKSxcclxuXHRcdFx0XHRjaHVua1NpemU6IG9wdGlvbnMuY2h1bmtTaXplXHJcblx0XHRcdH0pO1xyXG5cdFx0Ly8gY3JlYXRlIGhhbmRsZXJzXHJcblx0XHRjb25zdCBvbkFkZCA9IGRlZmF1bHRUbyhvcHRpb25zLm9uQWRkLCBhZGRUaWxlVG9WZXJ0ZXhBdGxhcyk7XHJcblx0XHRjb25zdCBvblJlbW92ZSA9IGRlZmF1bHRUbyhvcHRpb25zLm9uUmVtb3ZlLCByZW1vdmVUaWxlRnJvbVZlcnRleEF0bGFzKTtcclxuXHRcdGNvbnN0IGFkZCA9IGV2ZW50ID0+IHtcclxuXHRcdFx0b25BZGQoYXRsYXMsIGV2ZW50LnRpbGUpO1xyXG5cdFx0fTtcclxuXHRcdGNvbnN0IHJlbW92ZSA9IGV2ZW50ID0+IHtcclxuXHRcdFx0b25SZW1vdmUoYXRsYXMsIGV2ZW50LnRpbGUpO1xyXG5cdFx0fTtcclxuXHRcdC8vIGF0dGFjaCBoYW5kbGVyc1xyXG5cdFx0dGhpcy5sYXllci5vbihFdmVudFR5cGUuVElMRV9BREQsIGFkZCk7XHJcblx0XHR0aGlzLmxheWVyLm9uKEV2ZW50VHlwZS5USUxFX1JFTU9WRSwgcmVtb3ZlKTtcclxuXHRcdC8vIHN0b3JlIHRoZSBoYW5kbGVycyB1bmRlciB0aGUgYXRsYXNcclxuXHRcdHRoaXNbVElMRV9BRERdLnNldChhdGxhcywgYWRkKTtcclxuXHRcdHRoaXNbVElMRV9SRU1PVkVdLnNldChhdGxhcywgcmVtb3ZlKTtcclxuXHRcdHJldHVybiBhdGxhcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlc3Ryb3lzIGEgdmVydGV4IGF0bGFzIG9iamVjdCBhbmQgcmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgdXNlZCB0byBhZGRcclxuXHQgKiBhbmQgcmVtb3ZlIGRhdGEgZnJvbSB0aGUgYXRsYXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1ZlcnRleEF0bGFzfSBhdGxhcyAtIFRoZSB2ZXJ0ZXggYXRsYXMgdG8gZGVzdHJveS5cclxuXHQgKi9cclxuXHRkZXN0cm95VmVydGV4QXRsYXMoYXRsYXMpIHtcclxuXHRcdC8vIGRldGFjaCBoYW5kbGVyc1xyXG5cdFx0dGhpcy5sYXllci5yZW1vdmVMaXN0ZW5lcihFdmVudFR5cGUuVElMRV9BREQsIHRoaXNbVElMRV9BRERdLmdldChhdGxhcykpO1xyXG5cdFx0dGhpcy5sYXllci5yZW1vdmVMaXN0ZW5lcihFdmVudFR5cGUuVElMRV9SRU1PVkUsIHRoaXNbVElMRV9SRU1PVkVdLmdldChhdGxhcykpO1xyXG5cdFx0Ly8gcmVtb3ZlIGhhbmRsZXJzXHJcblx0XHR0aGlzW1RJTEVfQUREXS5kZWxldGUoYXRsYXMpO1xyXG5cdFx0dGhpc1tUSUxFX1JFTU9WRV0uZGVsZXRlKGF0bGFzKTtcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2ViR0xUaWxlUmVuZGVyZXI7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3dlYmdsL3ZlcnRleC9WZXJ0ZXhCdWZmZXInKTtcclxuY29uc3QgV2ViR0xUaWxlUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9XZWJHTFRpbGVSZW5kZXJlcicpO1xyXG5cclxuLy8gQ29uc3RhbnRzXHJcblxyXG4vKipcclxuICogU2hhZGVyIEdMU0wgc291cmNlLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge09iamVjdH1cclxuICovXHJcbmNvbnN0IFNIQURFUl9HTFNMID0ge1xyXG5cdHZlcnQ6XHJcblx0XHRgXHJcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XHJcblx0XHRhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xyXG5cdFx0dW5pZm9ybSB2ZWM0IHVUZXh0dXJlQ29vcmRPZmZzZXQ7XHJcblx0XHR1bmlmb3JtIHZlYzIgdVRpbGVPZmZzZXQ7XHJcblx0XHR1bmlmb3JtIGZsb2F0IHVTY2FsZTtcclxuXHRcdHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcclxuXHRcdHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG5cdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHR2VGV4dHVyZUNvb3JkID0gdmVjMihcclxuXHRcdFx0XHR1VGV4dHVyZUNvb3JkT2Zmc2V0LnggKyAoYVRleHR1cmVDb29yZC54ICogdVRleHR1cmVDb29yZE9mZnNldC56KSxcclxuXHRcdFx0XHR1VGV4dHVyZUNvb3JkT2Zmc2V0LnkgKyAoYVRleHR1cmVDb29yZC55ICogdVRleHR1cmVDb29yZE9mZnNldC53KSk7XHJcblx0XHRcdHZlYzIgd1Bvc2l0aW9uID0gKGFQb3NpdGlvbiAqIHVTY2FsZSkgKyB1VGlsZU9mZnNldDtcclxuXHRcdFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQod1Bvc2l0aW9uLCAwLjAsIDEuMCk7XHJcblx0XHR9XHJcblx0XHRgLFxyXG5cdGZyYWc6XHJcblx0XHRgXHJcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZVNhbXBsZXI7XHJcblx0XHR1bmlmb3JtIGZsb2F0IHVPcGFjaXR5O1xyXG5cdFx0dmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XHJcblx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgMS4wIC0gdlRleHR1cmVDb29yZC55KSk7XHJcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogdU9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0YFxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlUXVhZCA9IGZ1bmN0aW9uKGdsLCBtaW4sIG1heCkge1xyXG5cdGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSgyNCk7XHJcblx0Ly8gcG9zaXRpb25zXHJcblx0dmVydGljZXNbMF0gPSBtaW47XHJcblx0dmVydGljZXNbMV0gPSBtaW47XHJcblx0dmVydGljZXNbMl0gPSBtYXg7XHJcblx0dmVydGljZXNbM10gPSBtaW47XHJcblx0dmVydGljZXNbNF0gPSBtYXg7XHJcblx0dmVydGljZXNbNV0gPSBtYXg7XHJcblx0dmVydGljZXNbNl0gPSBtaW47XHJcblx0dmVydGljZXNbN10gPSBtaW47XHJcblx0dmVydGljZXNbOF0gPSBtYXg7XHJcblx0dmVydGljZXNbOV0gPSBtYXg7XHJcblx0dmVydGljZXNbMTBdID0gbWluO1xyXG5cdHZlcnRpY2VzWzExXSA9IG1heDtcclxuXHQvLyB1dnNcclxuXHR2ZXJ0aWNlc1sxMl0gPSAwO1xyXG5cdHZlcnRpY2VzWzEzXSA9IDA7XHJcblx0dmVydGljZXNbMTRdID0gMTtcclxuXHR2ZXJ0aWNlc1sxNV0gPSAwO1xyXG5cdHZlcnRpY2VzWzE2XSA9IDE7XHJcblx0dmVydGljZXNbMTddID0gMTtcclxuXHR2ZXJ0aWNlc1sxOF0gPSAwO1xyXG5cdHZlcnRpY2VzWzE5XSA9IDA7XHJcblx0dmVydGljZXNbMjBdID0gMTtcclxuXHR2ZXJ0aWNlc1syMV0gPSAxO1xyXG5cdHZlcnRpY2VzWzIyXSA9IDA7XHJcblx0dmVydGljZXNbMjNdID0gMTtcclxuXHQvLyBjcmVhdGUgcXVhZCBidWZmZXJcclxuXHRyZXR1cm4gbmV3IFZlcnRleEJ1ZmZlcihcclxuXHRcdGdsLFxyXG5cdFx0dmVydGljZXMsXHJcblx0XHR7XHJcblx0XHRcdDA6IHtcclxuXHRcdFx0XHRzaXplOiAyLFxyXG5cdFx0XHRcdHR5cGU6ICdGTE9BVCcsXHJcblx0XHRcdFx0Ynl0ZU9mZnNldDogMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHQxOiB7XHJcblx0XHRcdFx0c2l6ZTogMixcclxuXHRcdFx0XHR0eXBlOiAnRkxPQVQnLFxyXG5cdFx0XHRcdGJ5dGVPZmZzZXQ6IDIgKiA2ICogNFxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRjb3VudDogNixcclxuXHRcdH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHdlYmdsIGltYWdlIHRpbGUgcmVuZGVyZXIuXHJcbiAqL1xyXG5jbGFzcyBJbWFnZVRpbGVSZW5kZXJlciBleHRlbmRzIFdlYkdMVGlsZVJlbmRlcmVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IEltYWdlVGlsZVJlbmRlcmVyIG9iamVjdC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHN1cGVyKCk7XHJcblx0XHR0aGlzLnF1YWQgPSBudWxsO1xyXG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5hcnJheSA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBsYXllciBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciB0byBhdHRhY2ggdGhlIHJlbmRlcmVyIHRvLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0ltYWdlVGlsZVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0b25BZGQobGF5ZXIpIHtcclxuXHRcdHN1cGVyLm9uQWRkKGxheWVyKTtcclxuXHRcdHRoaXMucXVhZCA9IGNyZWF0ZVF1YWQodGhpcy5nbCwgMCwgbGF5ZXIucGxvdC50aWxlU2l6ZSk7XHJcblx0XHR0aGlzLnNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKFNIQURFUl9HTFNMKTtcclxuXHRcdHRoaXMuYXJyYXkgPSB0aGlzLmNyZWF0ZVRleHR1cmVBcnJheSh7XHJcblx0XHRcdGNodW5rU2l6ZTogbGF5ZXIucGxvdC50aWxlU2l6ZVxyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciB0byByZW1vdmUgdGhlIHJlbmRlcmVyIGZyb20uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7SW1hZ2VUaWxlUmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRvblJlbW92ZShsYXllcikge1xyXG5cdFx0dGhpcy5kZXN0cm95VGV4dHVyZUFycmF5KHRoaXMuYXJyYXkpO1xyXG5cdFx0dGhpcy5hcnJheSA9IG51bGw7XHJcblx0XHR0aGlzLnF1YWQgPSBudWxsO1xyXG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xyXG5cdFx0c3VwZXIub25SZW1vdmUobGF5ZXIpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgZHJhdyBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIHBlciBmcmFtZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtJbWFnZVRpbGVSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGRyYXcoKSB7XHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblx0XHRjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcclxuXHRcdGNvbnN0IGFycmF5ID0gdGhpcy5hcnJheTtcclxuXHRcdGNvbnN0IHF1YWQgPSB0aGlzLnF1YWQ7XHJcblx0XHRjb25zdCByZW5kZXJhYmxlcyA9IHRoaXMuZ2V0UmVuZGVyYWJsZXNMT0QoKTtcclxuXHRcdGNvbnN0IHByb2ogPSB0aGlzLmdldE9ydGhvTWF0cml4KCk7XHJcblxyXG5cdFx0Ly8gYmluZCBzaGFkZXJcclxuXHRcdHNoYWRlci51c2UoKTtcclxuXHRcdC8vIHNldCBnbG9iYWwgdW5pZm9ybXNcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHByb2opO1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VUZXh0dXJlU2FtcGxlcicsIDApO1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VPcGFjaXR5JywgdGhpcy5sYXllci5vcGFjaXR5KTtcclxuXHJcblx0XHQvLyBzZXQgYmxlbmRpbmcgZnVuY1xyXG5cdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuXHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuXHRcdC8vIGJpbmQgcXVhZFxyXG5cdFx0cXVhZC5iaW5kKCk7XHJcblxyXG5cdFx0Ly8gZm9yIGVhY2ggcmVuZGVyYWJsZVxyXG5cdFx0Zm9yIChsZXQgaT0wOyBpPHJlbmRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHJlbmRlcmFibGUgPSByZW5kZXJhYmxlc1tpXTtcclxuXHRcdFx0YXJyYXkuYmluZChyZW5kZXJhYmxlLmhhc2gsIDApO1xyXG5cdFx0XHQvLyBzZXQgdGlsZSB1bmlmb3Jtc1xyXG5cdFx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVRleHR1cmVDb29yZE9mZnNldCcsIHJlbmRlcmFibGUudXZPZmZzZXQpO1xyXG5cdFx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVNjYWxlJywgcmVuZGVyYWJsZS5zY2FsZSk7XHJcblx0XHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1VGlsZU9mZnNldCcsIHJlbmRlcmFibGUudGlsZU9mZnNldCk7XHJcblx0XHRcdC8vIGRyYXdcclxuXHRcdFx0cXVhZC5kcmF3KCk7XHJcblx0XHRcdC8vIG5vIG5lZWQgdG8gdW5iaW5kIHRleHR1cmVcclxuXHRcdH1cclxuXHJcblx0XHQvLyB1bmJpbmQgcXVhZFxyXG5cdFx0cXVhZC51bmJpbmQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVRpbGVSZW5kZXJlcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xyXG5jb25zdCBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi8uLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QnVmZmVyJyk7XHJcbmNvbnN0IFdlYkdMVGlsZVJlbmRlcmVyID0gcmVxdWlyZSgnLi4vV2ViR0xUaWxlUmVuZGVyZXInKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuLyoqXHJcbiAqIE51bXZlciBvZiB2ZXJ0aWNlcyBzdXBwb3J0ZWQgcGVyIGNodW5rLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge251bWJlcn1cclxuICovXHJcbmNvbnN0IENIVU5LX1NJWkUgPSAxMjggKiAxMjg7XHJcblxyXG4vKipcclxuICogSW5uZXIgcmFkaXVzIG9mIHN0YXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgU1RBUl9JTk5FUl9SQURJVVMgPSAwLjQ7XHJcblxyXG4vKipcclxuICogT3V0ZXIgcmFkaXVzIG9mIHN0YXIuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgU1RBUl9PVVRFUl9SQURJVVMgPSAxLjA7XHJcblxyXG4vKipcclxuICogbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgc3Rhci5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBTVEFSX05VTV9QT0lOVFMgPSA1O1xyXG5cclxuLyoqXHJcbiAqIFNoYWRlciBHTFNMIHNvdXJjZS5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBTSEFERVJfR0xTTCA9IHtcclxuXHR2ZXJ0OlxyXG5cdFx0YFxyXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0YXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xyXG5cdFx0YXR0cmlidXRlIHZlYzIgYU9mZnNldDtcclxuXHRcdGF0dHJpYnV0ZSBmbG9hdCBhUmFkaXVzO1xyXG5cdFx0dW5pZm9ybSB2ZWMyIHVUaWxlT2Zmc2V0O1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1U2NhbGU7XHJcblx0XHR1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XHJcblx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdHZlYzIgd1Bvc2l0aW9uID0gKGFQb3NpdGlvbiAqIGFSYWRpdXMpICsgKGFPZmZzZXQgKiB1U2NhbGUpICsgdVRpbGVPZmZzZXQ7XHJcblx0XHRcdGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHdQb3NpdGlvbiwgMC4wLCAxLjApO1xyXG5cdFx0fVxyXG5cdFx0YCxcclxuXHRmcmFnOlxyXG5cdFx0YFxyXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0dW5pZm9ybSB2ZWM0IHVDb2xvcjtcclxuXHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdUNvbG9yO1xyXG5cdFx0fVxyXG5cdFx0YFxyXG59O1xyXG5cclxuLy8gUHJpdmF0ZSBNZXRob2RzXHJcblxyXG5jb25zdCBjcmVhdGVTdGFyID0gZnVuY3Rpb24oZ2wpIHtcclxuXHRjb25zdCB0aGV0YSA9ICgyICogTWF0aC5QSSkgLyBTVEFSX05VTV9QT0lOVFM7XHJcblx0Y29uc3QgaHRoZXRhID0gdGhldGEgLyAyLjA7XHJcblx0Y29uc3QgcXRoZXRhID0gdGhldGEgLyA0LjA7XHJcblx0Y29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSgoU1RBUl9OVU1fUE9JTlRTICogMikgKiAyICsgNCk7XHJcblx0cG9zaXRpb25zWzBdID0gMDtcclxuXHRwb3NpdGlvbnNbMV0gPSAwO1xyXG5cdGZvciAobGV0IGk9MDsgaTxTVEFSX05VTV9QT0lOVFM7IGkrKykge1xyXG5cdFx0Y29uc3QgYW5nbGUgPSBpICogdGhldGE7XHJcblx0XHRsZXQgc3ggPSBNYXRoLmNvcyhhbmdsZSAtIHF0aGV0YSkgKiBTVEFSX0lOTkVSX1JBRElVUztcclxuXHRcdGxldCBzeSA9IE1hdGguc2luKGFuZ2xlIC0gcXRoZXRhKSAqIFNUQVJfSU5ORVJfUkFESVVTO1xyXG5cdFx0cG9zaXRpb25zW2kqNCsyXSA9IHN4O1xyXG5cdFx0cG9zaXRpb25zW2kqNCsxKzJdID0gc3k7XHJcblx0XHRzeCA9IE1hdGguY29zKGFuZ2xlICsgaHRoZXRhIC0gcXRoZXRhKSAqIFNUQVJfT1VURVJfUkFESVVTO1xyXG5cdFx0c3kgPSBNYXRoLnNpbihhbmdsZSArIGh0aGV0YSAtIHF0aGV0YSkgKiBTVEFSX09VVEVSX1JBRElVUztcclxuXHRcdHBvc2l0aW9uc1tpKjQrMisyXSA9IHN4O1xyXG5cdFx0cG9zaXRpb25zW2kqNCszKzJdID0gc3k7XHJcblx0fVxyXG5cdHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoLTJdID0gcG9zaXRpb25zWzJdO1xyXG5cdHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoLTFdID0gcG9zaXRpb25zWzNdO1xyXG5cdHJldHVybiBuZXcgVmVydGV4QnVmZmVyKFxyXG5cdFx0Z2wsXHJcblx0XHRwb3NpdGlvbnMsXHJcblx0XHR7XHJcblx0XHRcdDA6IHtcclxuXHRcdFx0XHRzaXplOiAyLFxyXG5cdFx0XHRcdHR5cGU6ICdGTE9BVCdcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0bW9kZTogJ1RSSUFOR0xFX0ZBTicsXHJcblx0XHRcdGNvdW50OiBwb3NpdGlvbnMubGVuZ3RoIC8gMlxyXG5cdFx0fSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgd2ViZ2wgaW5zdGFuY2VkIHNoYXBlIHRpbGUgcmVuZGVyZXIuXHJcbiAqL1xyXG5jbGFzcyBJbnN0YW5jZWRUaWxlUmVuZGVyZXIgZXh0ZW5kcyBXZWJHTFRpbGVSZW5kZXJlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBJbnN0YW5jZWRUaWxlUmVuZGVyZXIgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5jb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgcG9pbnRzLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMuY29sb3IgPSBkZWZhdWx0VG8ob3B0aW9ucy5jb2xvciwgWyAxLjAsIDAuNCwgMC4xLCAwLjggXSk7XHJcblx0XHR0aGlzLnNoYXBlID0gbnVsbDtcclxuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcclxuXHRcdHRoaXMuYXRsYXMgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYXR0YWNoZWQgdG8gYSBwbG90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYXR0YWNoIHRoZSByZW5kZXJlciB0by5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uQWRkKGxheWVyKSB7XHJcblx0XHRzdXBlci5vbkFkZChsYXllcik7XHJcblx0XHR0aGlzLnNoYXBlID0gY3JlYXRlU3Rhcih0aGlzLmdsKTtcclxuXHRcdHRoaXMuc2hhZGVyID0gdGhpcy5jcmVhdGVTaGFkZXIoU0hBREVSX0dMU0wpO1xyXG5cdFx0dGhpcy5hdGxhcyA9IHRoaXMuY3JlYXRlVmVydGV4QXRsYXMoe1xyXG5cdFx0XHRjaHVua1NpemU6IENIVU5LX1NJWkUsXHJcblx0XHRcdGF0dHJpYnV0ZVBvaW50ZXJzOiB7XHJcblx0XHRcdFx0Ly8gb2Zmc2V0XHJcblx0XHRcdFx0MToge1xyXG5cdFx0XHRcdFx0c2l6ZTogMixcclxuXHRcdFx0XHRcdHR5cGU6ICdGTE9BVCdcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdC8vIHJhZGl1c1xyXG5cdFx0XHRcdDI6IHtcclxuXHRcdFx0XHRcdHNpemU6IDEsXHJcblx0XHRcdFx0XHR0eXBlOiAnRkxPQVQnXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIHRvIHJlbW92ZSB0aGUgcmVuZGVyZXIgZnJvbS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uUmVtb3ZlKGxheWVyKSB7XHJcblx0XHR0aGlzLmRlc3Ryb3lWZXJ0ZXhBdGxhcyh0aGlzLmF0bGFzKTtcclxuXHRcdHRoaXMuYXRsYXMgPSBudWxsO1xyXG5cdFx0dGhpcy5zaGFwZSA9IG51bGw7XHJcblx0XHR0aGlzLnNoYWRlciA9IG51bGw7XHJcblx0XHRzdXBlci5vblJlbW92ZShsYXllcik7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgcGVyIGZyYW1lLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZHJhdygpIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xyXG5cdFx0Y29uc3QgYXRsYXMgPSB0aGlzLmF0bGFzO1xyXG5cdFx0Y29uc3Qgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG5cdFx0Y29uc3QgcmVuZGVyYWJsZXMgPSB0aGlzLmdldFJlbmRlcmFibGVzKCk7XHJcblx0XHRjb25zdCBwcm9qID0gdGhpcy5nZXRPcnRob01hdHJpeCgpO1xyXG5cclxuXHRcdC8vIHNldCBibGVuZGluZyBmdW5jXHJcblx0XHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG5cdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG5cdFx0Ly8gYmluZCBzaGFkZXJcclxuXHRcdHNoYWRlci51c2UoKTtcclxuXHJcblx0XHQvLyBzZXQgZ2xvYmFsIHVuaWZvcm1zXHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCBwcm9qKTtcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1Q29sb3InLCB0aGlzLmNvbG9yKTtcclxuXHJcblx0XHQvLyBiaW5kIHNoYXBlXHJcblx0XHRzaGFwZS5iaW5kKCk7XHJcblxyXG5cdFx0Ly8gYmluZHMgdGhlIGJ1ZmZlciB0byBpbnN0YW5jZVxyXG5cdFx0YXRsYXMuYmluZEluc3RhbmNlZCgpO1xyXG5cclxuXHRcdC8vIGZvciBlYWNoIHJlbmRlcmFibGVcclxuXHRcdGZvciAobGV0IGk9MDsgaTxyZW5kZXJhYmxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjb25zdCByZW5kZXJhYmxlID0gcmVuZGVyYWJsZXNbaV07XHJcblx0XHRcdC8vIHNldCB0aWxlIHVuaWZvcm1zXHJcblx0XHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1U2NhbGUnLCByZW5kZXJhYmxlLnNjYWxlKTtcclxuXHRcdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VUaWxlT2Zmc2V0JywgcmVuZGVyYWJsZS50aWxlT2Zmc2V0KTtcclxuXHRcdFx0Ly8gZHJhdyB0aGUgaW5zdGFuY2VzXHJcblx0XHRcdGF0bGFzLmRyYXdJbnN0YW5jZWQocmVuZGVyYWJsZS5oYXNoLCBzaGFwZS5tb2RlLCBzaGFwZS5jb3VudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdW5iaW5kXHJcblx0XHRhdGxhcy51bmJpbmRJbnN0YW5jZWQoKTtcclxuXHJcblx0XHQvLyB1bmJpbmQgcXVhZFxyXG5cdFx0c2hhcGUudW5iaW5kKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluc3RhbmNlZFRpbGVSZW5kZXJlcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xyXG5jb25zdCBDaXJjbGVDb2xsaWRhYmxlID0gcmVxdWlyZSgnLi4vLi4vLi4vZ2VvbWV0cnkvQ2lyY2xlQ29sbGlkYWJsZScpO1xyXG5jb25zdCBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi8uLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QnVmZmVyJyk7XHJcbmNvbnN0IFdlYkdMVGlsZVJlbmRlcmVyID0gcmVxdWlyZSgnLi4vV2ViR0xUaWxlUmVuZGVyZXInKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuLyoqXHJcbiAqIE51bXZlciBvZiB2ZXJ0aWNlcyBzdXBwb3J0ZWQgcGVyIGNodW5rLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge251bWJlcn1cclxuICovXHJcbmNvbnN0IENIVU5LX1NJWkUgPSAxMjggKiAxMjg7XHJcblxyXG4vKipcclxuICogSGlnaGxpZ2h0ZWQgcG9pbnQgcmFkaXVzIGluY3JlYXNlLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge251bWJlcn1cclxuICovXHJcbmNvbnN0IEhJR0hMSUdIVEVEX1JBRElVU19PRkZTRVQgPSAyO1xyXG5cclxuLyoqXHJcbiAqIFNlbGVjdGVkIHBvaW50IHJhZGl1cyBpbmNyZWFzZS5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBTRUxFQ1RFRF9SQURJVVNfT0ZGU0VUID0gNDtcclxuXHJcbi8qKlxyXG4gKiBSLVRyZWUgbm9kZSBjYXBhY2l0eS5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBOT0RFX0NBUEFDSVRZID0gMzI7XHJcblxyXG4vKipcclxuICogU2hhZGVyIEdMU0wgc291cmNlLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge09iamVjdH1cclxuICovXHJcbmNvbnN0IFNIQURFUl9HTFNMID0ge1xyXG5cdHZlcnQ6XHJcblx0XHRgXHJcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XHJcblx0XHRhdHRyaWJ1dGUgZmxvYXQgYVJhZGl1cztcclxuXHRcdHVuaWZvcm0gZmxvYXQgdVJhZGl1c09mZnNldDtcclxuXHRcdHVuaWZvcm0gdmVjMiB1VGlsZU9mZnNldDtcclxuXHRcdHVuaWZvcm0gZmxvYXQgdVNjYWxlO1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1UGl4ZWxSYXRpbztcclxuXHRcdHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcclxuXHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0dmVjMiB3UG9zaXRpb24gPSAoYVBvc2l0aW9uICogdVNjYWxlKSArIHVUaWxlT2Zmc2V0O1xyXG5cdFx0XHRnbF9Qb2ludFNpemUgPSAoYVJhZGl1cyArIHVSYWRpdXNPZmZzZXQpICogdVNjYWxlICogMi4wICogdVBpeGVsUmF0aW87XHJcblx0XHRcdGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHdQb3NpdGlvbiwgMC4wLCAxLjApO1xyXG5cdFx0fVxyXG5cdFx0YCxcclxuXHRmcmFnOlxyXG5cdFx0YFxyXG5cdFx0I2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xyXG5cdFx0XHQjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxyXG5cdFx0I2VuZGlmXHJcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHR1bmlmb3JtIHZlYzQgdUNvbG9yO1xyXG5cdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHR2ZWMyIGN4eSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XHJcblx0XHRcdGZsb2F0IHJhZGl1cyA9IGRvdChjeHksIGN4eSk7XHJcblx0XHRcdGZsb2F0IGFscGhhID0gMS4wO1xyXG5cdFx0XHQjaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXHJcblx0XHRcdFx0ZmxvYXQgZGVsdGEgPSBmd2lkdGgocmFkaXVzKTtcclxuXHRcdFx0XHRhbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoMS4wIC0gZGVsdGEsIDEuMCArIGRlbHRhLCByYWRpdXMpO1xyXG5cdFx0XHQjZWxzZVxyXG5cdFx0XHRcdGlmIChyYWRpdXMgPiAxLjApIHtcclxuXHRcdFx0XHRcdGRpc2NhcmQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHQjZW5kaWZcclxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IucmdiLCB1Q29sb3IuYSAqIGFscGhhKTtcclxuXHRcdH1cclxuXHRcdGBcclxufTtcclxuXHJcbi8vIFByaXZhdGUgTWV0aG9kc1xyXG5cclxuY29uc3QgY3JlYXRlUG9pbnQgPSBmdW5jdGlvbihnbCkge1xyXG5cdGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuXHR2ZXJ0aWNlc1swXSA9IDAuMDtcclxuXHR2ZXJ0aWNlc1sxXSA9IDAuMDtcclxuXHQvLyBjcmVhdGUgcXVhZCBidWZmZXJcclxuXHRyZXR1cm4gbmV3IFZlcnRleEJ1ZmZlcihcclxuXHRcdGdsLFxyXG5cdFx0dmVydGljZXMsXHJcblx0XHR7XHJcblx0XHRcdDA6IHtcclxuXHRcdFx0XHRzaXplOiAyLFxyXG5cdFx0XHRcdHR5cGU6ICdGTE9BVCdcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0bW9kZTogJ1BPSU5UUycsXHJcblx0XHRcdGNvdW50OiAxXHJcblx0XHR9KTtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUNvbGxpZGFibGVzID0gZnVuY3Rpb24odGlsZSwgeE9mZnNldCwgeU9mZnNldCkge1xyXG5cdGNvbnN0IGRhdGEgPSB0aWxlLmRhdGE7XHJcblx0Y29uc3QgY29sbGlkYWJsZXMgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcclxuXHRmb3IgKGxldCBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrPTMpIHtcclxuXHRcdC8vIGFkZCBjb2xsaWRhYmxlXHJcblx0XHRjb2xsaWRhYmxlc1tpLzNdID0gbmV3IENpcmNsZUNvbGxpZGFibGUoXHJcblx0XHRcdGRhdGFbaV0sIC8vIHhcclxuXHRcdFx0ZGF0YVtpKzFdLCAvLyB5XHJcblx0XHRcdGRhdGFbaSsyXSwgLy8gcmFkaXVzXHJcblx0XHRcdHhPZmZzZXQsXHJcblx0XHRcdHlPZmZzZXQsXHJcblx0XHRcdHRpbGUpO1xyXG5cdH1cclxuXHRyZXR1cm4gY29sbGlkYWJsZXM7XHJcbn07XHJcblxyXG5jb25zdCByZW5kZXJUaWxlcyA9IGZ1bmN0aW9uKGF0bGFzLCBzaGFkZXIsIHJlbmRlcmFibGVzLCBjb2xvcikge1xyXG5cdC8vIHNldCBnbG9iYWwgdW5pZm9ybXNcclxuXHRzaGFkZXIuc2V0VW5pZm9ybSgndUNvbG9yJywgY29sb3IpO1xyXG5cdHNoYWRlci5zZXRVbmlmb3JtKCd1UmFkaXVzT2Zmc2V0JywgMCk7XHJcblxyXG5cdC8vIGJpbmRzIHRoZSBidWZmZXIgdG8gaW5zdGFuY2VcclxuXHRhdGxhcy5iaW5kKCk7XHJcblxyXG5cdC8vIGZvciBlYWNoIHJlbmRlcmFibGVcclxuXHRmb3IgKGxldCBpPTA7IGk8cmVuZGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGNvbnN0IHJlbmRlcmFibGUgPSByZW5kZXJhYmxlc1tpXTtcclxuXHRcdC8vIHNldCB0aWxlIHVuaWZvcm1zXHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVNjYWxlJywgcmVuZGVyYWJsZS5zY2FsZSk7XHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVRpbGVPZmZzZXQnLCByZW5kZXJhYmxlLnRpbGVPZmZzZXQpO1xyXG5cdFx0Ly8gZHJhdyBwb2ludHNcclxuXHRcdGF0bGFzLmRyYXcocmVuZGVyYWJsZS5oYXNoLCAnUE9JTlRTJyk7XHJcblx0fVxyXG5cclxuXHQvLyB1bmJpbmRcclxuXHRhdGxhcy51bmJpbmQoKTtcclxufTtcclxuXHJcbmNvbnN0IHJlbmRlclBvaW50ID0gZnVuY3Rpb24ocG9pbnQsIHNoYWRlciwgcGxvdCwgdGFyZ2V0LCBjb2xvciwgcmFkaXVzKSB7XHJcblx0Ly8gZ2V0IHRpbGUgb2Zmc2V0XHJcblx0Y29uc3QgY29vcmQgPSB0YXJnZXQudGlsZS5jb29yZDtcclxuXHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHBsb3Quem9vbSAtIGNvb3JkLnopO1xyXG5cdGNvbnN0IHZpZXdwb3J0ID0gcGxvdC5nZXRWaWV3cG9ydFBpeGVsT2Zmc2V0KCk7XHJcblx0Y29uc3QgdGlsZU9mZnNldCA9IFtcclxuXHRcdCgoKGNvb3JkLnggKiBwbG90LnRpbGVTaXplKSArIHRhcmdldC54KSAqIHNjYWxlKSAtIHZpZXdwb3J0LngsXHJcblx0XHQoKChjb29yZC55ICogcGxvdC50aWxlU2l6ZSkgKyB0YXJnZXQueSkgKiBzY2FsZSkgLSB2aWV3cG9ydC55XHJcblx0XTtcclxuXHQvLyBzZXQgdW5pZm9ybXNcclxuXHRzaGFkZXIuc2V0VW5pZm9ybSgndVRpbGVPZmZzZXQnLCB0aWxlT2Zmc2V0KTtcclxuXHRzaGFkZXIuc2V0VW5pZm9ybSgndVNjYWxlJywgc2NhbGUpO1xyXG5cdHNoYWRlci5zZXRVbmlmb3JtKCd1Q29sb3InLCBjb2xvcik7XHJcblx0c2hhZGVyLnNldFVuaWZvcm0oJ3VSYWRpdXNPZmZzZXQnLCByYWRpdXMgKyB0YXJnZXQucmFkaXVzKTtcclxuXHQvLyBiaW5kcyB0aGUgYnVmZmVyIHRvIGluc3RhbmNlXHJcblx0cG9pbnQuYmluZCgpO1xyXG5cdC8vIGRyYXcgdGhlIHBvaW50c1xyXG5cdHBvaW50LmRyYXcoKTtcclxuXHQvLyB1bmJpbmRcclxuXHRwb2ludC51bmJpbmQoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB3ZWJnbCBpbnRlcmFjdGl2ZSBwb2ludCB0aWxlIHJlbmRlcmVyLlxyXG4gKi9cclxuY2xhc3MgSW50ZXJhY3RpdmVUaWxlUmVuZGVyZXIgZXh0ZW5kcyBXZWJHTFRpbGVSZW5kZXJlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBJbnRlcmFjdGl2ZVRpbGVSZW5kZXJlciBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBwb2ludHMuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5jb2xvciA9IGRlZmF1bHRUbyhvcHRpb25zLmNvbG9yLCBbIDEuMCwgMC40LCAwLjEsIDAuOCBdKTtcclxuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcclxuXHRcdHRoaXMucG9pbnQgPSBudWxsO1xyXG5cdFx0dGhpcy50cmVlID0gbnVsbDtcclxuXHRcdHRoaXMuYXRsYXMgPSBudWxsO1xyXG5cdFx0dGhpcy5leHQgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYXR0YWNoZWQgdG8gYSBwbG90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYXR0YWNoIHRoZSByZW5kZXJlciB0by5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uQWRkKGxheWVyKSB7XHJcblx0XHRzdXBlci5vbkFkZChsYXllcik7XHJcblx0XHQvLyBnZXQgdGhlIGV4dGVuc2lvbiBmb3Igc3RhbmRhcmQgZGVyaXZhdGl2ZXNcclxuXHRcdHRoaXMuZXh0ID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycpO1xyXG5cdFx0dGhpcy5wb2ludCA9IGNyZWF0ZVBvaW50KHRoaXMuZ2wpO1xyXG5cdFx0dGhpcy5zaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcihTSEFERVJfR0xTTCk7XHJcblx0XHR0aGlzLnRyZWUgPSB0aGlzLmNyZWF0ZVJUcmVlUHlyYW1pZCh7XHJcblx0XHRcdG5vZGVDYXBhY2l0eTogTk9ERV9DQVBBQ0lUWSxcclxuXHRcdFx0Y3JlYXRlQ29sbGlkYWJsZXM6IGNyZWF0ZUNvbGxpZGFibGVzXHJcblx0XHR9KTtcclxuXHRcdHRoaXMuYXRsYXMgPSB0aGlzLmNyZWF0ZVZlcnRleEF0bGFzKHtcclxuXHRcdFx0Y2h1bmtTaXplOiBDSFVOS19TSVpFLFxyXG5cdFx0XHRhdHRyaWJ1dGVQb2ludGVyczoge1xyXG5cdFx0XHRcdC8vIHBvc2l0aW9uXHJcblx0XHRcdFx0MDoge1xyXG5cdFx0XHRcdFx0c2l6ZTogMixcclxuXHRcdFx0XHRcdHR5cGU6ICdGTE9BVCdcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdC8vIHJhZGl1c1xyXG5cdFx0XHRcdDE6IHtcclxuXHRcdFx0XHRcdHNpemU6IDEsXHJcblx0XHRcdFx0XHR0eXBlOiAnRkxPQVQnXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIHRvIHJlbW92ZSB0aGUgcmVuZGVyZXIgZnJvbS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uUmVtb3ZlKGxheWVyKSB7XHJcblx0XHR0aGlzLmRlc3Ryb3lWZXJ0ZXhBdGxhcyh0aGlzLmF0bGFzKTtcclxuXHRcdHRoaXMuZGVzdHJveVJUcmVlUHlyYW1pZCh0aGlzLnRyZWUpO1xyXG5cdFx0dGhpcy5hdGxhcyA9IG51bGw7XHJcblx0XHR0aGlzLnNoYWRlciA9IG51bGw7XHJcblx0XHR0aGlzLnBvaW50ID0gbnVsbDtcclxuXHRcdHRoaXMudHJlZSA9IG51bGw7XHJcblx0XHR0aGlzLmV4dCA9IG51bGw7XHJcblx0XHRzdXBlci5vblJlbW92ZShsYXllcik7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBpY2sgYSBwb3NpdGlvbiBvZiB0aGUgcmVuZGVyZXIgZm9yIGEgY29sbGlzaW9uIHdpdGggYW55IHJlbmRlcmVkIG9iamVjdHMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9zIC0gVGhlIHBsb3QgcG9zaXRpb24gdG8gcGljayBhdC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjb2xsaXNpb24sIGlmIGFueS5cclxuXHQgKi9cclxuXHRwaWNrKHBvcykge1xyXG5cdFx0aWYgKHRoaXMubGF5ZXIucGxvdC5pc1pvb21pbmcoKSkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnRyZWUuc2VhcmNoUG9pbnQoXHJcblx0XHRcdHBvcy54LFxyXG5cdFx0XHRwb3MueSxcclxuXHRcdFx0dGhpcy5sYXllci5wbG90Lnpvb20sXHJcblx0XHRcdHRoaXMubGF5ZXIucGxvdC5nZXRQaXhlbEV4dGVudCgpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgcGVyIGZyYW1lLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZHJhdygpIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGNvbnN0IGxheWVyID0gdGhpcy5sYXllcjtcclxuXHRcdGNvbnN0IHBsb3QgPSBsYXllci5wbG90O1xyXG5cdFx0Y29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0T3J0aG9NYXRyaXgoKTtcclxuXHRcdGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xyXG5cclxuXHRcdC8vIGJpbmQgcmVuZGVyIHRhcmdldFxyXG5cdFx0cGxvdC5yZW5kZXJCdWZmZXIuYmluZCgpO1xyXG5cdFx0Ly8gY2xlYXIgcmVuZGVyIHRhcmdldFxyXG5cdFx0cGxvdC5yZW5kZXJCdWZmZXIuY2xlYXIoKTtcclxuXHJcblx0XHQvLyBzZXQgYmxlbmRpbmcgZnVuY1xyXG5cdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuXHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORSk7XHJcblxyXG5cdFx0Ly8gdXNlIHNoYWRlclxyXG5cdFx0c2hhZGVyLnVzZSgpO1xyXG5cclxuXHRcdC8vIHNldCB1bmlmb3Jtc1xyXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VQcm9qZWN0aW9uTWF0cml4JywgcHJvamVjdGlvbik7XHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVBpeGVsUmF0aW8nLCBwbG90LnBpeGVsUmF0aW8pO1xyXG5cclxuXHRcdC8vIHJlbmRlciB0aGUgdGlsZXNcclxuXHRcdHJlbmRlclRpbGVzKFxyXG5cdFx0XHR0aGlzLmF0bGFzLFxyXG5cdFx0XHRzaGFkZXIsXHJcblx0XHRcdHRoaXMuZ2V0UmVuZGVyYWJsZXMoKSxcclxuXHRcdFx0dGhpcy5jb2xvcik7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIHNlbGVjdGVkXHJcblx0XHRsYXllci5nZXRTZWxlY3RlZCgpLmZvckVhY2goc2VsZWN0ZWQgPT4ge1xyXG5cdFx0XHRyZW5kZXJQb2ludChcclxuXHRcdFx0XHR0aGlzLnBvaW50LFxyXG5cdFx0XHRcdHNoYWRlcixcclxuXHRcdFx0XHRwbG90LFxyXG5cdFx0XHRcdHNlbGVjdGVkLFxyXG5cdFx0XHRcdHRoaXMuY29sb3IsXHJcblx0XHRcdFx0U0VMRUNURURfUkFESVVTX09GRlNFVCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyByZW5kZXIgaGlnaGxpZ2h0ZWRcclxuXHRcdGNvbnN0IGhpZ2hsaWdodGVkID0gbGF5ZXIuZ2V0SGlnaGxpZ2h0ZWQoKTtcclxuXHRcdGlmIChoaWdobGlnaHRlZCAmJiAhbGF5ZXIuaXNTZWxlY3RlZChoaWdobGlnaHRlZCkpIHtcclxuXHRcdFx0cmVuZGVyUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5wb2ludCxcclxuXHRcdFx0XHRzaGFkZXIsXHJcblx0XHRcdFx0cGxvdCxcclxuXHRcdFx0XHRoaWdobGlnaHRlZCxcclxuXHRcdFx0XHR0aGlzLmNvbG9yLFxyXG5cdFx0XHRcdEhJR0hMSUdIVEVEX1JBRElVU19PRkZTRVQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVuYmluZCByZW5kZXIgdGFyZ2V0XHJcblx0XHRwbG90LnJlbmRlckJ1ZmZlci51bmJpbmQoKTtcclxuXHJcblx0XHQvLyByZW5kZXIgZnJhbWVidWZmZXIgdG8gdGhlIGJhY2tidWZmZXJcclxuXHRcdHBsb3QucmVuZGVyQnVmZmVyLmJsaXRUb1NjcmVlbih0aGlzLmxheWVyLm9wYWNpdHkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyYWN0aXZlVGlsZVJlbmRlcmVyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XHJcbmNvbnN0IFdlYkdMVGlsZVJlbmRlcmVyID0gcmVxdWlyZSgnLi4vV2ViR0xUaWxlUmVuZGVyZXInKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuLyoqXHJcbiAqIE51bXZlciBvZiB2ZXJ0aWNlcyBzdXBwb3J0ZWQgcGVyIGNodW5rLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge251bWJlcn1cclxuICovXHJcbmNvbnN0IENIVU5LX1NJWkUgPSAxMjggKiAxMjg7XHJcblxyXG4vKipcclxuICogU2hhZGVyIEdMU0wgc291cmNlLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge09iamVjdH1cclxuICovXHJcbmNvbnN0IFNIQURFUl9HTFNMID0ge1xyXG5cdHZlcnQ6XHJcblx0XHRgXHJcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHRhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XHJcblx0XHRhdHRyaWJ1dGUgZmxvYXQgYVJhZGl1cztcclxuXHRcdHVuaWZvcm0gdmVjMiB1VGlsZU9mZnNldDtcclxuXHRcdHVuaWZvcm0gZmxvYXQgdVNjYWxlO1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1UGl4ZWxSYXRpbztcclxuXHRcdHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcclxuXHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0dmVjMiB3UG9zaXRpb24gPSAoYVBvc2l0aW9uICogdVNjYWxlKSArIHVUaWxlT2Zmc2V0O1xyXG5cdFx0XHRnbF9Qb2ludFNpemUgPSBhUmFkaXVzICogMi4wICogdVBpeGVsUmF0aW87XHJcblx0XHRcdGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHdQb3NpdGlvbiwgMC4wLCAxLjApO1xyXG5cdFx0fVxyXG5cdFx0YCxcclxuXHRmcmFnOlxyXG5cdFx0YFxyXG5cdFx0I2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xyXG5cdFx0XHQjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxyXG5cdFx0I2VuZGlmXHJcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcblx0XHR1bmlmb3JtIHZlYzQgdUNvbG9yO1xyXG5cdFx0dm9pZCBtYWluKCkge1xyXG5cdFx0XHR2ZWMyIGN4eSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XHJcblx0XHRcdGZsb2F0IHJhZGl1cyA9IGRvdChjeHksIGN4eSk7XHJcblx0XHRcdGZsb2F0IGFscGhhID0gMS4wO1xyXG5cdFx0XHQjaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXHJcblx0XHRcdFx0ZmxvYXQgZGVsdGEgPSBmd2lkdGgocmFkaXVzKTtcclxuXHRcdFx0XHRhbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoMS4wIC0gZGVsdGEsIDEuMCArIGRlbHRhLCByYWRpdXMpO1xyXG5cdFx0XHQjZWxzZVxyXG5cdFx0XHRcdGlmIChyYWRpdXMgPiAxLjApIHtcclxuXHRcdFx0XHRcdGRpc2NhcmQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHQjZW5kaWZcclxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IucmdiLCB1Q29sb3IuYSAqIGFscGhhKTtcclxuXHRcdH1cclxuXHRcdGBcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB3ZWJnbCBwb2ludCB0aWxlIHJlbmRlcmVyLlxyXG4gKi9cclxuY2xhc3MgUG9pbnRUaWxlUmVuZGVyZXIgZXh0ZW5kcyBXZWJHTFRpbGVSZW5kZXJlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBQb2ludFRpbGVSZW5kZXJlciBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBwb2ludHMuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5jb2xvciA9IGRlZmF1bHRUbyhvcHRpb25zLmNvbG9yLCBbIDEuMCwgMC40LCAwLjEsIDAuOCBdKTtcclxuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcclxuXHRcdHRoaXMuYXRsYXMgPSBudWxsO1xyXG5cdFx0dGhpcy5leHQgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYXR0YWNoZWQgdG8gYSBwbG90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYXR0YWNoIHRoZSByZW5kZXJlciB0by5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdG9uQWRkKGxheWVyKSB7XHJcblx0XHRzdXBlci5vbkFkZChsYXllcik7XHJcblx0XHQvLyBnZXQgdGhlIGV4dGVuc2lvbiBmb3Igc3RhbmRhcmQgZGVyaXZhdGl2ZXNcclxuXHRcdHRoaXMuZXh0ID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycpO1xyXG5cdFx0dGhpcy5zaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcihTSEFERVJfR0xTTCk7XHJcblx0XHR0aGlzLmF0bGFzID0gdGhpcy5jcmVhdGVWZXJ0ZXhBdGxhcyh7XHJcblx0XHRcdGNodW5rU2l6ZTogQ0hVTktfU0laRSxcclxuXHRcdFx0YXR0cmlidXRlUG9pbnRlcnM6IHtcclxuXHRcdFx0XHQvLyBwb3NpdGlvblxyXG5cdFx0XHRcdDA6IHtcclxuXHRcdFx0XHRcdHNpemU6IDIsXHJcblx0XHRcdFx0XHR0eXBlOiAnRkxPQVQnXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHQvLyByYWRpdXNcclxuXHRcdFx0XHQxOiB7XHJcblx0XHRcdFx0XHRzaXplOiAxLFxyXG5cdFx0XHRcdFx0dHlwZTogJ0ZMT0FUJ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciB0byByZW1vdmUgdGhlIHJlbmRlcmVyIGZyb20uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRvblJlbW92ZShsYXllcikge1xyXG5cdFx0dGhpcy5kZXN0cm95VmVydGV4QXRsYXModGhpcy5hdGxhcyk7XHJcblx0XHR0aGlzLmF0bGFzID0gbnVsbDtcclxuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcclxuXHRcdHRoaXMuZXh0ID0gbnVsbDtcclxuXHRcdHN1cGVyLm9uUmVtb3ZlKGxheWVyKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGRyYXcgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBwZXIgZnJhbWUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRkcmF3KCkge1xyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Y29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXI7XHJcblx0XHRjb25zdCBhdGxhcyA9IHRoaXMuYXRsYXM7XHJcblx0XHRjb25zdCBwbG90ID0gdGhpcy5sYXllci5wbG90O1xyXG5cdFx0Y29uc3QgcmVuZGVyYWJsZXMgPSB0aGlzLmdldFJlbmRlcmFibGVzKCk7XHJcblx0XHRjb25zdCBwcm9qID0gdGhpcy5nZXRPcnRob01hdHJpeCgpO1xyXG5cclxuXHRcdC8vIGJpbmQgcmVuZGVyIHRhcmdldFxyXG5cdFx0cGxvdC5yZW5kZXJCdWZmZXIuYmluZCgpO1xyXG5cdFx0Ly8gY2xlYXIgcmVuZGVyIHRhcmdldFxyXG5cdFx0cGxvdC5yZW5kZXJCdWZmZXIuY2xlYXIoKTtcclxuXHJcblx0XHQvLyBzZXQgYmxlbmRpbmcgZnVuY1xyXG5cdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuXHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORSk7XHJcblxyXG5cdFx0Ly8gYmluZCBzaGFkZXJcclxuXHRcdHNoYWRlci51c2UoKTtcclxuXHJcblx0XHQvLyBzZXQgZ2xvYmFsIHVuaWZvcm1zXHJcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCBwcm9qKTtcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1Q29sb3InLCB0aGlzLmNvbG9yKTtcclxuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1UGl4ZWxSYXRpbycsIHBsb3QucGl4ZWxSYXRpbyk7XHJcblxyXG5cdFx0Ly8gYmluZHMgdGhlIHZlcnRleCBhdGxhc1xyXG5cdFx0YXRsYXMuYmluZCgpO1xyXG5cclxuXHRcdC8vIGZvciBlYWNoIHJlbmRlcmFibGVcclxuXHRcdGZvciAobGV0IGk9MDsgaTxyZW5kZXJhYmxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjb25zdCByZW5kZXJhYmxlID0gcmVuZGVyYWJsZXNbaV07XHJcblx0XHRcdC8vIHNldCB0aWxlIHVuaWZvcm1zXHJcblx0XHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1U2NhbGUnLCByZW5kZXJhYmxlLnNjYWxlKTtcclxuXHRcdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VUaWxlT2Zmc2V0JywgcmVuZGVyYWJsZS50aWxlT2Zmc2V0KTtcclxuXHRcdFx0Ly8gZHJhdyB0aGUgcG9pbnRzXHJcblx0XHRcdGF0bGFzLmRyYXcocmVuZGVyYWJsZS5oYXNoLCAnUE9JTlRTJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdW5iaW5kXHJcblx0XHRhdGxhcy51bmJpbmQoKTtcclxuXHJcblx0XHQvLyB1bmJpbmQgcmVuZGVyIHRhcmdldFxyXG5cdFx0cGxvdC5yZW5kZXJCdWZmZXIudW5iaW5kKCk7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIGZyYW1lYnVmZmVyIHRvIHRoZSBiYWNrYnVmZmVyXHJcblx0XHRwbG90LnJlbmRlckJ1ZmZlci5ibGl0VG9TY3JlZW4odGhpcy5sYXllci5vcGFjaXR5KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUaWxlUmVuZGVyZXI7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmFzYXRhc2F5Z2luL2lzLmpzL2Jsb2IvbWFzdGVyL2lzLmpzXHJcblxyXG5jb25zdCB1c2VyQWdlbnQgPSAobmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJycpLnRvTG93ZXJDYXNlKCk7XHJcbmNvbnN0IHZlbmRvciA9IChuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnZlbmRvciB8fCAnJykudG9Mb3dlckNhc2UoKTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0IGlmIHRoZSBicm93c2VyIGlzIGZpcmVmb3guXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgZmlyZWZveC5cclxuICovXHJcbmNvbnN0IGlzRmlyZWZveCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB1c2VyQWdlbnQubWF0Y2goLyg/OmZpcmVmb3h8Znhpb3MpXFwvKFxcZCspLyk7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdCBpZiB0aGUgYnJvd3NlciBpcyBjaHJvbWUuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgY2hyb21lLlxyXG4gKi9cclxuY29uc3QgaXNDaHJvbWUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gL2dvb2dsZSBpbmMvLnRlc3QodmVuZG9yKSA/IHVzZXJBZ2VudC5tYXRjaCgvKD86Y2hyb21lfGNyaW9zKVxcLyhcXGQrKS8pIDogbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0IGlmIHRoZSBicm93c2VyIGlzIGludGVybmV0IGV4cGxvcmVyLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIGludGVybmV0IGV4cGxvcmVyLlxyXG4gKi9cclxuY29uc3QgaXNJRSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB1c2VyQWdlbnQubWF0Y2goLyg/Om1zaWUgfHRyaWRlbnQuKz87IHJ2OikoXFxkKykvKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0IGlmIHRoZSBicm93c2VyIGlzIGVkZ2UuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgZWRnZS5cclxuICovXHJcbmNvbnN0IGlzRWRnZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB1c2VyQWdlbnQubWF0Y2goL2VkZ2VcXC8oXFxkKykvKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0IGlmIHRoZSBicm93c2VyIGlzIG9wZXJhLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIG9wZXJhLlxyXG4gKi9cclxuY29uc3QgaXNPcGVyYSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB1c2VyQWdlbnQubWF0Y2goLyg/Ol5vcGVyYS4rP3ZlcnNpb258b3ByKVxcLyhcXGQrKS8pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3QgaWYgdGhlIGJyb3dzZXIgaXMgc2FmYXJpLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIHNhZmFyaS5cclxuICovXHJcbmNvbnN0IGlzU2FmYXJpID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHVzZXJBZ2VudC5tYXRjaCgvdmVyc2lvblxcLyhcXGQrKS4rP3NhZmFyaS8pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJyb3dzZXIgZGV0ZWN0aW9uLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIGZpcmVmb3guXHJcblx0ICogQGNvbnN0YW50IHtib29sZWFufVxyXG5cdCAqL1xyXG5cdGZpcmVmb3g6ICEhaXNGaXJlZm94KCksXHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIGNocm9tZS5cclxuXHQgKiBAY29uc3RhbnQge2Jvb2xlYW59XHJcblx0ICovXHJcblx0Y2hyb21lOiAhIWlzQ2hyb21lKCksXHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIGllLlxyXG5cdCAqIEBjb25zdGFudCB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRpZTogISFpc0lFKCksXHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIGVkZ2UuXHJcblx0ICogQGNvbnN0YW50IHtib29sZWFufVxyXG5cdCAqL1xyXG5cdGVkZ2U6ICEhaXNFZGdlKCksXHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIG9wZXJhLlxyXG5cdCAqIEBjb25zdGFudCB7Ym9vbGVhbn1cclxuXHQgKi9cclxuXHRvcGVyYTogISFpc09wZXJhKCksXHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIGlzIHNhZmFyaS5cclxuXHQgKiBAY29uc3RhbnQge2Jvb2xlYW59XHJcblx0ICovXHJcblx0c2FmYXJpOiAhIWlzU2FmYXJpKClcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xyXG5jb25zdCBMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9MaW5rZWRMaXN0Jyk7XHJcblxyXG4vLyBDb25zdGFudHNcclxuXHJcbi8qKlxyXG4gKiBNYXggc2l6ZSBzeW1ib2wuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxyXG4gKi9cclxuY29uc3QgQ0FQQUNJVFkgPSBTeW1ib2woKTtcclxuXHJcbi8qKlxyXG4gKiBEaXNwb3NlIGZ1bmN0aW9uIHN5bWJvbC5cclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50IHtTeW1ib2x9XHJcbiAqL1xyXG5jb25zdCBPTl9SRU1PVkUgPSBTeW1ib2woKTtcclxuXHJcbi8qKlxyXG4gKiBDYWNoZSBzeW1ib2wuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxyXG4gKi9cclxuY29uc3QgQ0FDSEUgPSBTeW1ib2woKTtcclxuXHJcbi8qKlxyXG4gKiBMUlUgbGlua2VkIGxpc3Qgc3ltYm9sLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnQge1N5bWJvbH1cclxuICovXHJcbmNvbnN0IExSVV9MSVNUID0gU3ltYm9sKCk7XHJcblxyXG4vKipcclxuICogTFJVIGxlbmd0aCBzeW1ib2wuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxyXG4gKi9cclxuY29uc3QgTEVOR1RIID0gU3ltYm9sKCk7XHJcblxyXG4vLyBQcml2YXRlIE1ldGhvZHNcclxuXHJcbmNvbnN0IGRlbCA9IGZ1bmN0aW9uKHNlbGYsIG5vZGUpIHtcclxuXHRpZiAobm9kZSkge1xyXG5cdFx0Y29uc3QgaGl0ID0gbm9kZS52YWx1ZTtcclxuXHRcdGlmIChzZWxmW09OX1JFTU9WRV0pIHtcclxuXHRcdFx0c2VsZltPTl9SRU1PVkVdKGhpdC52YWx1ZSwgaGl0LmtleSk7XHJcblx0XHR9XHJcblx0XHRzZWxmW0xFTkdUSF0tLTtcclxuXHRcdHNlbGZbQ0FDSEVdLmRlbGV0ZShoaXQua2V5KTtcclxuXHRcdHNlbGZbTFJVX0xJU1RdLnJlbW92ZU5vZGUobm9kZSk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBMUlUgY2FjaGUuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jbGFzcyBMUlVDYWNoZSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBMUlVDYWNoZSBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jYXBhY2l0eSAtIFRoZSBjYXBhY2l0eSBvZiB0aGUgY2FjaGUuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblJlbW92ZSAtIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGEgdmFsdWUgaXMgZXZpY3RlZC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuXHRcdHRoaXNbQ0FQQUNJVFldID0gZGVmYXVsdFRvKE1hdGgubWF4KDEsIG9wdGlvbnMuY2FwYWNpdHkpLCAyNTYpO1xyXG5cdFx0dGhpc1tPTl9SRU1PVkVdID0gZGVmYXVsdFRvKG9wdGlvbnMub25SZW1vdmUsIG51bGwpO1xyXG5cdFx0dGhpcy5jbGVhcigpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY2FwYWNpdHkgb2YgdGhlIGNhY2hlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge251bWJlcn0gLSBUaGUgY2FwY2l0eSBvZiB0aGUgY2FjaGUuXHJcblx0ICovXHJcblx0Z2V0Q2FwYWNpdHkoKSB7XHJcblx0XHRyZXR1cm4gdGhpc1tDQVBBQ0lUWV07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNhY2hlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge251bWJlcn0gLSBUaGUgbGVuZ3RoIG9mIHRoZSBjYWNoZS5cclxuXHQgKi9cclxuXHRnZXRMZW5ndGgoKSB7XHJcblx0XHRyZXR1cm4gdGhpc1tMRU5HVEhdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSXRlcmF0ZXMgb3ZlciBhbmQgZXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGZvciBhbGwgdmFsdWVzLlxyXG5cdCAqIE5PVEU6IERvZXMgbm90IHVwZGF0ZSByZWNlbnRuZXNzIG9mIHRoZSBlbnRyaWVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlIGFuZCBrZXkuXHJcblx0ICovXHJcblx0Zm9yRWFjaChmbikge1xyXG5cdFx0Zm9yIChsZXQgbm9kZSA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IG5vZGUgIT09IG51bGw7KSB7XHJcblx0XHRcdGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcblx0XHRcdGZuKG5vZGUudmFsdWUudmFsdWUsIG5vZGUudmFsdWUua2V5KTtcclxuXHRcdFx0bm9kZSA9IG5leHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhcnMgYWxsIGVudHJpZXMgaW4gdGhlIGNhY2hlLlxyXG5cdCAqL1xyXG5cdGNsZWFyKCkge1xyXG5cdFx0aWYgKHRoaXNbT05fUkVNT1ZFXSAmJiB0aGlzW0xSVV9MSVNUXSkge1xyXG5cdFx0XHR0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB7XHJcblx0XHRcdFx0dGhpc1tPTl9SRU1PVkVdKGhpdC52YWx1ZSwgaGl0LmtleSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0dGhpc1tDQUNIRV0gPSBuZXcgTWFwKCk7XHJcblx0XHR0aGlzW0xSVV9MSVNUXSA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcblx0XHR0aGlzW0xFTkdUSF0gPSAwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgdmFsdWUgdW5kZXIgdGhlIHByb3ZpZGVkIGtleSwgcmVtb3ZpbmcgdGhlIHByZXZpb3VzIGVudHJ5IGlmIG9uZVxyXG5cdCAqIGV4aXN0cy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHN0cmluZy5cclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlLlxyXG5cdCAqL1xyXG5cdHNldChrZXksIHZhbHVlKSB7XHJcblx0XHRpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcclxuXHRcdFx0Ly8gaWYgd2UgYWxyZWFkeSBoYXZlIGFuIGVudHJ5XHJcblx0XHRcdGNvbnN0IG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KTtcclxuXHRcdFx0Y29uc3QgaXRlbSA9IG5vZGUudmFsdWU7XHJcblx0XHRcdC8vIGV4ZWN1dGUgb25SZW1vdmUgZm9yIG9sZCB2YWx1ZSBiZWZvcmUgZXZpY3RpbmdcclxuXHRcdFx0aWYgKHRoaXNbT05fUkVNT1ZFXSkge1xyXG5cdFx0XHRcdHRoaXNbT05fUkVNT1ZFXShpdGVtLnZhbHVlLCBrZXkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIHNldCB0aGUgbmV3IHZhbHVlXHJcblx0XHRcdGl0ZW0udmFsdWUgPSB2YWx1ZTtcclxuXHRcdFx0dGhpcy5nZXQoa2V5KTtcclxuXHRcdFx0Ly8gbm8gbmVlZCB0byB0cmltLCBzaW5jZSB0aGUgbGVuZ3RoIHJlbWFpbmVkIGNvbnN0YW50XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdC8vIGFkZCBuZXcgZW50cnlcclxuXHRcdGNvbnN0IGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlKTtcclxuXHRcdHRoaXNbTEVOR1RIXSsrO1xyXG5cdFx0dGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpO1xyXG5cdFx0dGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZCk7XHJcblx0XHQvLyB0cmltIGFueSBvbGQgZW50cnlcclxuXHRcdGlmICh0aGlzW0xFTkdUSF0gPiB0aGlzW0NBUEFDSVRZXSkge1xyXG5cdFx0XHQvLyBkZWxldGUgb2xkZXN0IGVudHJ5XHJcblx0XHRcdGRlbCh0aGlzLCB0aGlzW0xSVV9MSVNUXS50YWlsKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGVudHJ5IGlzIGluIHRoZSBMUlUgY2FjaGUgdW5kZXIgdGhlIHByb3ZpZGVkXHJcblx0ICoga2V5LlxyXG5cdCAqIE5PVEU6IERvZXMgbm90IHVwZGF0ZSByZWNlbnRuZXNzIG9mIHRoZSBlbnRyeS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHN0cmluZy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUga2V5IGV4aXN0cy5cclxuXHQgKi9cclxuXHRoYXMoa2V5KSB7XHJcblx0XHRpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgZW50cnkgaW4gdGhlIExSVSBjYWNoZSB1bmRlciB0aGUgcHJvdmlkZWQga2V5LlxyXG5cdCAqIE5PVEU6IFVwZGF0ZXMgdGhlIHJlY2VudG5lc3Mgb2YgdGhlIGVudHJ5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgc3RyaW5nLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBpbiB0aGUgY2FjaGUuXHJcblx0ICovXHJcblx0Z2V0KGtleSkge1xyXG5cdFx0Y29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpO1xyXG5cdFx0aWYgKG5vZGUpIHtcclxuXHRcdFx0Ly8gdXBkYXRlIHJlY2VudG5lc3NcclxuXHRcdFx0dGhpc1tMUlVfTElTVF0udW5zaGlmdE5vZGUobm9kZSk7XHJcblx0XHRcdHJldHVybiBub2RlLnZhbHVlLnZhbHVlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGVudHJ5IGluIHRoZSBMUlUgY2FjaGUgdW5kZXIgdGhlIHByb3ZpZGVkIGtleS5cclxuXHQgKiBOT1RFOiBEb2VzIG5vdCB1cGRhdGUgcmVjZW50bmVzcyBvZiB0aGUgZW50cnkuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBzdHJpbmcuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIGluIHRoZSBjYWNoZS5cclxuXHQgKi9cclxuXHRwZWVrKGtleSkge1xyXG5cdFx0Y29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpO1xyXG5cdFx0aWYgKG5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUudmFsdWUudmFsdWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyB0aGUgZW50cnkgaW4gdGhlIExSVSBjYWNoZSB1bmRlciB0aGUgcHJvdmlkZWQga2V5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgc3RyaW5nLlxyXG5cdCAqL1xyXG5cdGRlbGV0ZShrZXkpIHtcclxuXHRcdGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSk7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIExSVSBjYWNoZSBlbnRyeS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmNsYXNzIEVudHJ5IHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IEVudHJ5IG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgZW50cnkga2V5LlxyXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgZW50cnkgdmFsdWUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Ioa2V5LCB2YWx1ZSkge1xyXG5cdFx0dGhpcy5rZXkgPSBrZXk7XHJcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbGlua2VkIGxpc3QuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jbGFzcyBMaW5rZWRMaXN0IHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IExpbmtlZExpc3Qgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0dGhpcy50YWlsID0gbnVsbDtcclxuXHRcdHRoaXMuaGVhZCA9IG51bGw7XHJcblx0XHR0aGlzLmxlbmd0aCA9IDA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBQdXNoIGFuIGl0ZW0gdG8gdGhlIGVuZCBvZiB0aGUgbGlua2VkIGxpc3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgaXRlbSB0byBhZGQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgbGlzdC5cclxuXHQgKi9cclxuXHRwdXNoKGl0ZW0pIHtcclxuXHRcdHRoaXMudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHRoaXMudGFpbCwgbnVsbCwgdGhpcyk7XHJcblx0XHRpZiAoIXRoaXMuaGVhZCkge1xyXG5cdFx0XHR0aGlzLmhlYWQgPSB0aGlzLnRhaWw7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxlbmd0aCsrO1xyXG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUHVzaCBhbiBpdGVtIHRvIHRoZSBmcm9udCBvZiB0aGUgbGlua2VkIGxpc3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgaXRlbSB0byBhZGQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgbGlzdC5cclxuXHQgKi9cclxuXHR1bnNoaWZ0KGl0ZW0pIHtcclxuXHRcdHRoaXMuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHRoaXMuaGVhZCwgdGhpcyk7XHJcblx0XHRpZiAoIXRoaXMudGFpbCkge1xyXG5cdFx0XHR0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxlbmd0aCsrO1xyXG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGFuIGl0ZW0gZnJvbnQgdGhlIGVuZCBvZiB0aGUgbGlua2VkIGxpc3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Kn0gVGhlIHJlbW92ZWQgdmFsdWUuXHJcblx0ICovXHJcblx0cG9wKCkge1xyXG5cdFx0aWYgKCF0aGlzLnRhaWwpIHtcclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdGNvbnN0IHJlcyA9IHRoaXMudGFpbC52YWx1ZTtcclxuXHRcdHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2O1xyXG5cdFx0aWYgKHRoaXMudGFpbCkge1xyXG5cdFx0XHR0aGlzLnRhaWwubmV4dCA9IG51bGw7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmhlYWQgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5sZW5ndGgtLTtcclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBmcm9udCBvZiB0aGUgbGlua2VkIGxpc3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Kn0gVGhlIHJlbW92ZWQgdmFsdWUuXHJcblx0ICovXHJcblx0c2hpZnQoKSB7XHJcblx0XHRpZiAoIXRoaXMuaGVhZCkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgcmVzID0gdGhpcy5oZWFkLnZhbHVlO1xyXG5cdFx0dGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XHJcblx0XHRpZiAodGhpcy5oZWFkKSB7XHJcblx0XHRcdHRoaXMuaGVhZC5wcmV2ID0gbnVsbDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMudGFpbCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxlbmd0aC0tO1xyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbiBpdGVtIGF0IGEgcGFydGljdWxhciBpbmRleCBpbiB0aGUgbGlzdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZS5cclxuXHQgKi9cclxuXHRnZXQobikge1xyXG5cdFx0bGV0IGk7XHJcblx0XHRsZXQgbm9kZTtcclxuXHRcdGZvciAoaSA9IDAsIG5vZGUgPSB0aGlzLmhlYWQ7IG5vZGUgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xyXG5cdFx0XHQvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcclxuXHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcclxuXHRcdH1cclxuXHRcdGlmIChpID09PSBuICYmIG5vZGUgIT09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUudmFsdWU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJdGVyYXRlcyBvdmVyIGFuZCBleGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZm9yIGFsbCB2YWx1ZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUuXHJcblx0ICovXHJcblx0Zm9yRWFjaChmbikge1xyXG5cdFx0Zm9yIChsZXQgbm9kZSA9IHRoaXMuaGVhZCwgaSA9IDA7IG5vZGUgIT09IG51bGw7IGkrKykge1xyXG5cdFx0XHRmbihub2RlLnZhbHVlLCBpKTtcclxuXHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEl0ZXJhdGVzIG92ZXIgYW5kIGV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBmb3IgYWxsIHZhbHVlcyByZXR1cm5pbmdcclxuXHQgKiBhbiBhcnJheSBvZiBhbGwgbWFwcGVkIHZhbHVlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB0aWxlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgbWFwcGVkIHZhbHVlcy5cclxuXHQgKi9cclxuXHRtYXAoZm4pIHtcclxuXHRcdGNvbnN0IGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XHJcblx0XHRmb3IgKGxldCBpID0gMCwgbm9kZSA9IHRoaXMuaGVhZDsgbm9kZSAhPT0gbnVsbDsgaSsrKSB7XHJcblx0XHRcdGFycltpXSA9IGZuKG5vZGUudmFsdWUsIGkpO1xyXG5cdFx0XHRub2RlID0gbm9kZS5uZXh0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFycjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFB1c2ggYSBub2RlIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gYWRkLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIG5ldyBsZW5ndGggb2YgdGhlIGxpc3QuXHJcblx0ICovXHJcblx0cHVzaE5vZGUobm9kZSkge1xyXG5cdFx0aWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZiAobm9kZS5saXN0KSB7XHJcblx0XHRcdG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgdGFpbCA9IHRoaXMudGFpbDtcclxuXHRcdG5vZGUubGlzdCA9IHRoaXM7XHJcblx0XHRub2RlLnByZXYgPSB0YWlsO1xyXG5cdFx0aWYgKHRhaWwpIHtcclxuXHRcdFx0dGFpbC5uZXh0ID0gbm9kZTtcclxuXHRcdH1cclxuXHRcdHRoaXMudGFpbCA9IG5vZGU7XHJcblx0XHRpZiAoIXRoaXMuaGVhZCkge1xyXG5cdFx0XHR0aGlzLmhlYWQgPSBub2RlO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5sZW5ndGgrKztcclxuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFB1c2ggYSBub2RlIHRvIHRoZSBmcm9udCBvZiB0aGUgbGlua2VkIGxpc3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBhZGQuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgbGlzdC5cclxuXHQgKi9cclxuXHR1bnNoaWZ0Tm9kZShub2RlKSB7XHJcblx0XHRpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmIChub2RlLmxpc3QpIHtcclxuXHRcdFx0bm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSk7XHJcblx0XHR9XHJcblx0XHRjb25zdCBoZWFkID0gdGhpcy5oZWFkO1xyXG5cdFx0bm9kZS5saXN0ID0gdGhpcztcclxuXHRcdG5vZGUubmV4dCA9IGhlYWQ7XHJcblx0XHRpZiAoaGVhZCkge1xyXG5cdFx0XHRoZWFkLnByZXYgPSBub2RlO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5oZWFkID0gbm9kZTtcclxuXHRcdGlmICghdGhpcy50YWlsKSB7XHJcblx0XHRcdHRoaXMudGFpbCA9IG5vZGU7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxlbmd0aCsrO1xyXG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGEgbm9kZSBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIHJlbW92ZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBsaXN0LlxyXG5cdCAqL1xyXG5cdHJlbW92ZU5vZGUobm9kZSkge1xyXG5cdFx0aWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xyXG5cdFx0XHR0aHJvdyAnUmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0JztcclxuXHRcdH1cclxuXHRcdGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcblx0XHRjb25zdCBwcmV2ID0gbm9kZS5wcmV2O1xyXG5cdFx0aWYgKG5leHQpIHtcclxuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcclxuXHRcdH1cclxuXHRcdGlmIChwcmV2KSB7XHJcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XHJcblx0XHR9XHJcblx0XHRpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XHJcblx0XHRcdHRoaXMuaGVhZCA9IG5leHQ7XHJcblx0XHR9XHJcblx0XHRpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XHJcblx0XHRcdHRoaXMudGFpbCA9IHByZXY7XHJcblx0XHR9XHJcblx0XHRub2RlLmxpc3QubGVuZ3RoLS07XHJcblx0XHRub2RlLm5leHQgPSBudWxsO1xyXG5cdFx0bm9kZS5wcmV2ID0gbnVsbDtcclxuXHRcdG5vZGUubGlzdCA9IG51bGw7XHJcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbGlua2VkIGxpc3Qgbm9kZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmNsYXNzIE5vZGUge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgTm9kZSBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gcHJldiAtIFRoZSBwcmV2aW91cyBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbmV4dCAtIFRoZSBuZXh0IG5vZGUuXHJcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0fSBsaXN0IC0gVGhlIGxpbmtlZCBsaXN0LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XHJcblx0XHR0aGlzLmxpc3QgPSBsaXN0O1xyXG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdFx0aWYgKHByZXYpIHtcclxuXHRcdFx0cHJldi5uZXh0ID0gdGhpcztcclxuXHRcdFx0dGhpcy5wcmV2ID0gcHJldjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMucHJldiA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAobmV4dCkge1xyXG5cdFx0XHRuZXh0LnByZXYgPSB0aGlzO1xyXG5cdFx0XHR0aGlzLm5leHQgPSBuZXh0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5uZXh0ID0gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGlua2VkTGlzdDtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIElzc3VlcyBhIFhIUiBhbmQgbG9hZHMgYW4gQXJyYXlCdWZmZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIC0gVGhlIGNhbGxiYWNrLlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIGRvbmUpIHtcclxuXHRjb25zdCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHRyZXEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcclxuXHRyZXEucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuXHRyZXEub25sb2FkID0gKCkgPT4ge1xyXG5cdFx0Y29uc3QgYXJyYXlidWZmZXIgPSByZXEucmVzcG9uc2U7XHJcblx0XHRpZiAoYXJyYXlidWZmZXIpIHtcclxuXHRcdFx0ZG9uZShudWxsLCBhcnJheWJ1ZmZlcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBlcnIgPSBgVW5hYmxlIHRvIGxvYWQgQXJyYXlCdWZmZXIgZnJvbSBVUkw6IFxcYCR7ZXZlbnQucGF0aFswXS5jdXJyZW50U3JjfVxcYGA7XHJcblx0XHRcdGRvbmUoZXJyLCBudWxsKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdHJlcS5vbmVycm9yID0gKGV2ZW50KSA9PiB7XHJcblx0XHRjb25zdCBlcnIgPSBgVW5hYmxlIHRvIGxvYWQgQXJyYXlCdWZmZXIgZnJvbSBVUkw6IFxcYCR7ZXZlbnQucGF0aFswXS5jdXJyZW50U3JjfVxcYGA7XHJcblx0XHRkb25lKGVyciwgbnVsbCk7XHJcblx0fTtcclxuXHRyZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcclxuXHRyZXEuc2VuZChudWxsKTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIElzc3VlcyBhIFhIUiBhbmQgbG9hZHMgYW4gSW1hZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIC0gVGhlIGNhbGxiYWNrLlxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIGRvbmUpIHtcclxuXHRjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cdGltYWdlLm9ubG9hZCA9ICgpID0+IHtcclxuXHRcdGRvbmUobnVsbCwgaW1hZ2UpO1xyXG5cdH07XHJcblx0aW1hZ2Uub25lcnJvciA9IChldmVudCkgPT4ge1xyXG5cdFx0Y29uc3QgZXJyID0gYFVuYWJsZSB0byBsb2FkIGltYWdlIGZyb20gVVJMOiBcXGAke2V2ZW50LnBhdGhbMF0uY3VycmVudFNyY31cXGBgO1xyXG5cdFx0ZG9uZShlcnIsIG51bGwpO1xyXG5cdH07XHJcblx0aW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuXHRpbWFnZS5zcmMgPSB1cmw7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IFRleHR1cmUgPSByZXF1aXJlKCcuL3RleHR1cmUvVGV4dHVyZScpO1xyXG5jb25zdCBTaGFkZXIgPSByZXF1aXJlKCcuL3NoYWRlci9TaGFkZXInKTtcclxuY29uc3QgVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi92ZXJ0ZXgvVmVydGV4QnVmZmVyJyk7XHJcblxyXG4vLyBDb25zdGFudHNcclxuXHJcbi8qKlxyXG4gKiBTaGFkZXIgR0xTTCBzb3VyY2UuXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdGFudCB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgU0hBREVSX0dMU0wgPSB7XHJcblx0dmVydDpcclxuXHRcdGBcclxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcclxuXHRcdGF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcclxuXHRcdGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XHJcblx0XHR2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcclxuXHRcdHZvaWQgbWFpbih2b2lkKSB7XHJcblx0XHRcdHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xyXG5cdFx0XHRnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xyXG5cdFx0fVxyXG5cdFx0YCxcclxuXHRmcmFnOlxyXG5cdFx0YFxyXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG5cdFx0dW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcclxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlU2FtcGxlcjtcclxuXHRcdHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG5cdFx0dm9pZCBtYWluKHZvaWQpIHtcclxuXHRcdFx0dmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xyXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgY29sb3IuYSAqIHVPcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdGBcclxufTtcclxuXHJcbi8vIFByaXZhdGUgTWV0aG9kc1xyXG5cclxuY29uc3QgY3JlYXRlUXVhZCA9IGZ1bmN0aW9uKGdsLCBtaW4sIG1heCkge1xyXG5cdGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSgyNCk7XHJcblx0Ly8gcG9zaXRpb25zXHJcblx0dmVydGljZXNbMF0gPSBtaW47XHJcblx0dmVydGljZXNbMV0gPSBtaW47XHJcblx0dmVydGljZXNbMl0gPSBtYXg7XHJcblx0dmVydGljZXNbM10gPSBtaW47XHJcblx0dmVydGljZXNbNF0gPSBtYXg7XHJcblx0dmVydGljZXNbNV0gPSBtYXg7XHJcblx0dmVydGljZXNbNl0gPSBtaW47XHJcblx0dmVydGljZXNbN10gPSBtaW47XHJcblx0dmVydGljZXNbOF0gPSBtYXg7XHJcblx0dmVydGljZXNbOV0gPSBtYXg7XHJcblx0dmVydGljZXNbMTBdID0gbWluO1xyXG5cdHZlcnRpY2VzWzExXSA9IG1heDtcclxuXHQvLyB1dnNcclxuXHR2ZXJ0aWNlc1sxMl0gPSAwO1xyXG5cdHZlcnRpY2VzWzEzXSA9IDA7XHJcblx0dmVydGljZXNbMTRdID0gMTtcclxuXHR2ZXJ0aWNlc1sxNV0gPSAwO1xyXG5cdHZlcnRpY2VzWzE2XSA9IDE7XHJcblx0dmVydGljZXNbMTddID0gMTtcclxuXHR2ZXJ0aWNlc1sxOF0gPSAwO1xyXG5cdHZlcnRpY2VzWzE5XSA9IDA7XHJcblx0dmVydGljZXNbMjBdID0gMTtcclxuXHR2ZXJ0aWNlc1syMV0gPSAxO1xyXG5cdHZlcnRpY2VzWzIyXSA9IDA7XHJcblx0dmVydGljZXNbMjNdID0gMTtcclxuXHQvLyBjcmVhdGUgcXVhZCBidWZmZXJcclxuXHRyZXR1cm4gbmV3IFZlcnRleEJ1ZmZlcihcclxuXHRcdGdsLFxyXG5cdFx0dmVydGljZXMsXHJcblx0XHR7XHJcblx0XHRcdDA6IHtcclxuXHRcdFx0XHRzaXplOiAyLFxyXG5cdFx0XHRcdHR5cGU6ICdGTE9BVCcsXHJcblx0XHRcdFx0Ynl0ZU9mZnNldDogMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHQxOiB7XHJcblx0XHRcdFx0c2l6ZTogMixcclxuXHRcdFx0XHR0eXBlOiAnRkxPQVQnLFxyXG5cdFx0XHRcdGJ5dGVPZmZzZXQ6IDIgKiA2ICogNFxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRjb3VudDogNixcclxuXHRcdH0pO1xyXG59O1xyXG5cclxuY29uc3Qgc2V0Q29sb3JUYXJnZXQgPSBmdW5jdGlvbihnbCwgZnJhbWVidWZmZXIsIGF0dGFjaG1lbnQsIGluZGV4KSB7XHJcblx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XHJcblx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXHJcblx0XHRnbC5GUkFNRUJVRkZFUixcclxuXHRcdGdsW2BDT0xPUl9BVFRBQ0hNRU5UJHtpbmRleH1gXSxcclxuXHRcdGdsLlRFWFRVUkVfMkQsXHJcblx0XHRhdHRhY2htZW50LnRleHR1cmUsXHJcblx0XHQwKTtcclxuXHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG59O1xyXG5cclxuY29uc3QgcmVuZGVyVG9TY3JlZW4gPSBmdW5jdGlvbihnbCwgdGV4dHVyZSwgc2hhZGVyLCBxdWFkLCBvcGFjaXR5KSB7XHJcblx0Ly8gYmluZCBzaGFkZXJcclxuXHRzaGFkZXIudXNlKCk7XHJcblx0Ly8gc2V0IGJsZW5kaW5nIGZ1bmNcclxuXHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG5cdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cdC8vIHNldCB1bmlmb3Jtc1xyXG5cdHNoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIG9wYWNpdHkpO1xyXG5cdC8vIHNldCB0ZXh0dXJlIHNhbXBsZXIgdW5pdFxyXG5cdHNoYWRlci5zZXRVbmlmb3JtKCd1VGV4dHVyZVNhbXBsZXInLCAwKTtcclxuXHQvLyBiaW5kIHRleHR1cmVcclxuXHR0ZXh0dXJlLmJpbmQoMCk7XHJcblx0Ly8gZHJhdyBxdWFkXHJcblx0cXVhZC5iaW5kKCk7XHJcblx0cXVhZC5kcmF3KCk7XHJcblx0cXVhZC51bmJpbmQoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB3ZWJnbCByZW5kZXJidWZmZXIuXHJcbiAqL1xyXG5jbGFzcyBSZW5kZXJCdWZmZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBSZW5kZXJCdWZmZXIgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSByZW5kZXJidWZmZXIuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlcmJ1ZmZlci5cclxuXHQgKi9cclxuXHQgY29uc3RydWN0b3IoZ2wsIHdpZHRoLCBoZWlnaHQpIHtcclxuXHRcdHRoaXMuZ2wgPSBnbDtcclxuXHRcdHRoaXMuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG5cdFx0dGhpcy5zaGFkZXIgPSBuZXcgU2hhZGVyKGdsLCBTSEFERVJfR0xTTCk7XHJcblx0XHR0aGlzLnF1YWQgPSBjcmVhdGVRdWFkKGdsLCAtMSwgMSk7XHJcblx0XHR0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZShnbCwgbnVsbCwge1xyXG5cdFx0XHR3aWR0aDogd2lkdGgsXHJcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxyXG5cdFx0XHRmaWx0ZXI6ICdORUFSRVNUJyxcclxuXHRcdFx0aW52ZXJ0WTogZmFsc2UsXHJcblx0XHRcdHByZW11bHRpcGx5QWxwaGE6IGZhbHNlXHJcblx0XHR9KTtcclxuXHRcdHNldENvbG9yVGFyZ2V0KFxyXG5cdFx0XHR0aGlzLmdsLFxyXG5cdFx0XHR0aGlzLmZyYW1lYnVmZmVyLFxyXG5cdFx0XHR0aGlzLnRleHR1cmUsXHJcblx0XHRcdDApO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQmluZHMgdGhlIHJlbmRlcmJ1ZmZlciBmb3Igd3JpdGluZy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJCdWZmZXJ9IFRoZSByZW5kZXJidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0YmluZCgpIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuYmluZHMgdGhlIHJlbmRlcmJ1ZmZlciBmb3Igd3JpdGluZy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJCdWZmZXJ9IFRoZSByZW5kZXJidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0dW5iaW5kKCkge1xyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYXJzIHRoZSByZW5kZXJidWZmZXIgYnVmZmVyIGNvbG9yIGJpdHMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UmVuZGVyQnVmZmVyfSBUaGUgcmVuZGVyYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGNsZWFyKCkge1xyXG5cdFx0dGhpcy5nbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xyXG5cdFx0dGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBCbGl0cyB0aGUgcmVuZGVyYnVmZmVyIHRleHR1cmUgdG8gdGhlIHNjcmVlbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IC0gVGhlIG9wYWNpdHkgdG8gYmxpdCBhdC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJCdWZmZXJ9IFRoZSByZW5kZXJidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0YmxpdFRvU2NyZWVuKG9wYWNpdHkpIHtcclxuXHRcdHJlbmRlclRvU2NyZWVuKFxyXG5cdFx0XHR0aGlzLmdsLFxyXG5cdFx0XHR0aGlzLnRleHR1cmUsXHJcblx0XHRcdHRoaXMuc2hhZGVyLFxyXG5cdFx0XHR0aGlzLnF1YWQsXHJcblx0XHRcdG9wYWNpdHkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXNpemVzIHRoZSByZW5kZXJidWZmZXIgdG8gdGhlIHByb3ZpZGVkIGhlaWdodCBhbmQgd2lkdGguXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSByZW5kZXJidWZmZXIuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSByZW5kZXJidWZmZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7UmVuZGVyQnVmZmVyfSBUaGUgcmVuZGVyYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcblx0XHR0aGlzLnRleHR1cmUucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlckJ1ZmZlcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgbWFwID0gcmVxdWlyZSgnbG9kYXNoL21hcCcpO1xyXG5jb25zdCBwYXJzZVNoYWRlciA9IHJlcXVpcmUoJy4vcGFyc2VTaGFkZXInKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuY29uc3QgVU5JRk9STV9GVU5DVElPTlMgPSB7XHJcblx0J2Jvb2wnOiAndW5pZm9ybTFpJyxcclxuXHQnYm9vbFtdJzogJ3VuaWZvcm0xaXYnLFxyXG5cdCdmbG9hdCc6ICd1bmlmb3JtMWYnLFxyXG5cdCdmbG9hdFtdJzogJ3VuaWZvcm0xZnYnLFxyXG5cdCdpbnQnOiAndW5pZm9ybTFpJyxcclxuXHQnaW50W10nOiAndW5pZm9ybTFpdicsXHJcblx0J3VpbnQnOiAndW5pZm9ybTFpJyxcclxuXHQndWludFtdJzogJ3VuaWZvcm0xaXYnLFxyXG5cdCd2ZWMyJzogJ3VuaWZvcm0yZnYnLFxyXG5cdCd2ZWMyW10nOiAndW5pZm9ybTJmdicsXHJcblx0J2l2ZWMyJzogJ3VuaWZvcm0yaXYnLFxyXG5cdCdpdmVjMltdJzogJ3VuaWZvcm0yaXYnLFxyXG5cdCd2ZWMzJzogJ3VuaWZvcm0zZnYnLFxyXG5cdCd2ZWMzW10nOiAndW5pZm9ybTNmdicsXHJcblx0J2l2ZWMzJzogJ3VuaWZvcm0zaXYnLFxyXG5cdCdpdmVjM1tdJzogJ3VuaWZvcm0zaXYnLFxyXG5cdCd2ZWM0JzogJ3VuaWZvcm00ZnYnLFxyXG5cdCd2ZWM0W10nOiAndW5pZm9ybTRmdicsXHJcblx0J2l2ZWM0JzogJ3VuaWZvcm00aXYnLFxyXG5cdCdpdmVjNFtdJzogJ3VuaWZvcm00aXYnLFxyXG5cdCdtYXQyJzogJ3VuaWZvcm1NYXRyaXgyZnYnLFxyXG5cdCdtYXQyW10nOiAndW5pZm9ybU1hdHJpeDJmdicsXHJcblx0J21hdDMnOiAndW5pZm9ybU1hdHJpeDNmdicsXHJcblx0J21hdDNbXSc6ICd1bmlmb3JtTWF0cml4M2Z2JyxcclxuXHQnbWF0NCc6ICd1bmlmb3JtTWF0cml4NGZ2JyxcclxuXHQnbWF0NFtdJzogJ3VuaWZvcm1NYXRyaXg0ZnYnLFxyXG5cdCdzYW1wbGVyMkQnOiAndW5pZm9ybTFpJyxcclxuXHQnc2FtcGxlckN1YmUnOiAndW5pZm9ybTFpJ1xyXG59O1xyXG5cclxuLy8gUHJpdmF0ZSBNZXRob2RzXHJcblxyXG5jb25zdCBzZXRBdHRyaWJ1dGVzQW5kVW5pZm9ybXMgPSBmdW5jdGlvbihzaGFkZXIsIHZlcnRTb3VyY2UsIGZyYWdTb3VyY2UpIHtcclxuXHQvLyBwYXJzZSBzaGFkZXIgZGVsY2FyYXRpb25zXHJcblx0Y29uc3QgZGVjbGFyYXRpb25zID0gcGFyc2VTaGFkZXIoXHJcblx0XHRbIHZlcnRTb3VyY2UsIGZyYWdTb3VyY2UgXSxcclxuXHRcdFsgJ3VuaWZvcm0nLCAnYXR0cmlidXRlJyBdKTtcclxuXHQvLyBmb3IgZWFjaCBkZWNsYXJhdGlvbiBpbiB0aGUgc2hhZGVyXHJcblx0ZGVjbGFyYXRpb25zLmZvckVhY2goZGVjbGFyYXRpb24gPT4ge1xyXG5cdFx0Ly8gY2hlY2sgaWYgaXRzIGFuIGF0dHJpYnV0ZSBvciB1bmlmb3JtXHJcblx0XHRpZiAoZGVjbGFyYXRpb24ucXVhbGlmaWVyID09PSAnYXR0cmlidXRlJykge1xyXG5cdFx0XHQvLyBpZiBhdHRyaWJ1dGUsIHN0b3JlIHR5cGUgYW5kIGluZGV4XHJcblx0XHRcdHNoYWRlci5hdHRyaWJ1dGVzLnNldChkZWNsYXJhdGlvbi5uYW1lLCB7XHJcblx0XHRcdFx0dHlwZTogZGVjbGFyYXRpb24udHlwZSxcclxuXHRcdFx0XHRpbmRleDogc2hhZGVyLmF0dHJpYnV0ZXMuc2l6ZVxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7IC8vIGlmIChkZWNsYXJhdGlvbi5xdWFsaWZpZXIgPT09ICd1bmlmb3JtJykge1xyXG5cdFx0XHQvLyBpZiB1bmlmb3JtLCBzdG9yZSB0eXBlIGFuZCBidWZmZXIgZnVuY3Rpb24gbmFtZVxyXG5cdFx0XHRjb25zdCB0eXBlID0gZGVjbGFyYXRpb24udHlwZSArIChkZWNsYXJhdGlvbi5jb3VudCA+IDEgPyAnW10nIDogJycpO1xyXG5cdFx0XHRzaGFkZXIudW5pZm9ybXMuc2V0KGRlY2xhcmF0aW9uLm5hbWUsIHtcclxuXHRcdFx0XHR0eXBlOiBkZWNsYXJhdGlvbi50eXBlLFxyXG5cdFx0XHRcdGZ1bmM6IFVOSUZPUk1fRlVOQ1RJT05TW3R5cGVdXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59O1xyXG5cclxuY29uc3QgZm9ybWF0TGluZSA9IGZ1bmN0aW9uKHN0ciwgbnVtKSB7XHJcblx0c3RyID0gc3RyLnRvU3RyaW5nKCk7XHJcblx0Y29uc3QgZGlmZiA9IG51bSAtIHN0ci5sZW5ndGg7XHJcblx0c3RyICs9ICc6JztcclxuXHRmb3IgKGxldCBpPTA7IGk8ZGlmZjsgaSsrKSB7XHJcblx0XHRzdHIgKz0gJyAnO1xyXG5cdH1cclxuXHRyZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuY29uc3QgY29tcGlsZVNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTb3VyY2UsIHR5cGUpIHtcclxuXHRjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2xbdHlwZV0pO1xyXG5cdGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XHJcblx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG5cdGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcblx0XHRjb25zdCBzcGxpdCA9IHNoYWRlclNvdXJjZS5zcGxpdCgnXFxuJyk7XHJcblx0XHRjb25zdCBtYXhEaWdpdHMgPSAoc3BsaXQubGVuZ3RoKS50b1N0cmluZygpLmxlbmd0aCArIDE7XHJcblx0XHRjb25zdCBzcmNCeUxpbmVzID0gc3BsaXQubWFwKChsaW5lLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRyZXR1cm4gYCR7Zm9ybWF0TGluZShpbmRleCsxLCBtYXhEaWdpdHMpfSAke2xpbmV9YDtcclxuXHRcdH0pLmpvaW4oJ1xcbicpO1xyXG5cdFx0Y29uc3Qgc2hhZGVyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xyXG5cdFx0dGhyb3cgYEFuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgc2hhZGVyOlxcblxcbiR7c2hhZGVyTG9nLnNsaWNlKDAsIHNoYWRlckxvZy5sZW5ndGgtMSl9XFxuJHtzcmNCeUxpbmVzfWA7XHJcblx0fVxyXG5cdHJldHVybiBzaGFkZXI7XHJcbn07XHJcblxyXG5jb25zdCBiaW5kQXR0cmlidXRlTG9jYXRpb25zID0gZnVuY3Rpb24oc2hhZGVyKSB7XHJcblx0Y29uc3QgZ2wgPSBzaGFkZXIuZ2w7XHJcblx0c2hhZGVyLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cmlidXRlLCBuYW1lKSA9PiB7XHJcblx0XHQvLyBiaW5kIHRoZSBhdHRyaWJ1dGUgbG9jYXRpb25cclxuXHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbihzaGFkZXIucHJvZ3JhbSwgYXR0cmlidXRlLmluZGV4LCBuYW1lKTtcclxuXHR9KTtcclxufTtcclxuXHJcbmNvbnN0IGdldFVuaWZvcm1Mb2NhdGlvbnMgPSBmdW5jdGlvbihzaGFkZXIpIHtcclxuXHRjb25zdCBnbCA9IHNoYWRlci5nbDtcclxuXHRjb25zdCB1bmlmb3JtcyA9IHNoYWRlci51bmlmb3JtcztcclxuXHR1bmlmb3Jtcy5mb3JFYWNoKCh1bmlmb3JtLCBuYW1lKSA9PiB7XHJcblx0XHQvLyBnZXQgdGhlIHVuaWZvcm0gbG9jYXRpb25cclxuXHRcdGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlci5wcm9ncmFtLCBuYW1lKTtcclxuXHRcdC8vIGNoZWNrIGlmIG51bGwsIHBhcnNlIG1heSBkZXRlY3QgdW5pZm9ybSB0aGF0IGlzIGNvbXBpbGVkIG91dCBkdWUgdG9cclxuXHRcdC8vIG5vdCBiZWluZyB1c2VkLCBvciBkdWUgdG8gYSBwcmVwcm9jZXNzb3IgZXZhbHVhdGlvbi5cclxuXHRcdGlmIChsb2NhdGlvbiA9PT0gbnVsbCkge1xyXG5cdFx0XHR1bmlmb3Jtcy5kZWxldGUobmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR1bmlmb3JtLmxvY2F0aW9uID0gbG9jYXRpb247XHJcblx0XHR9XHJcblx0fSk7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVEZWZpbmVzID0gZnVuY3Rpb24oZGVmaW5lcykge1xyXG5cdHJldHVybiBtYXAoZGVmaW5lcywgKHZhbHVlLCBuYW1lKSA9PiB7XHJcblx0XHRyZXR1cm4gYCNkZWZpbmUgJHtuYW1lfSAke3ZhbHVlfWA7XHJcblx0fSkuam9pbignXFxuJyk7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVQcm9ncmFtID0gZnVuY3Rpb24oc2hhZGVyLCBzb3VyY2VzKSB7XHJcblx0Ly8gQ3JlYXRlcyB0aGUgc2hhZGVyIHByb2dyYW0gb2JqZWN0IGZyb20gc291cmNlIHN0cmluZ3MuIFRoaXMgaW5jbHVkZXM6XHJcblx0Ly9cdDEpIENvbXBpbGluZyBhbmQgbGlua2luZyB0aGUgc2hhZGVyIHByb2dyYW0uXHJcblx0Ly9cdDIpIFBhcnNpbmcgc2hhZGVyIHNvdXJjZSBmb3IgYXR0cmlidXRlIGFuZCB1bmlmb3JtIGluZm9ybWF0aW9uLlxyXG5cdC8vXHQzKSBCaW5kaW5nIGF0dHJpYnV0ZSBsb2NhdGlvbnMsIGJ5IG9yZGVyIG9mIGRlbGNhcmF0aW9uLlxyXG5cdC8vXHQ0KSBRdWVyeWluZyBhbmQgc3RvcmluZyB1bmlmb3JtIGxvY2F0aW9uLlxyXG5cdGNvbnN0IGdsID0gc2hhZGVyLmdsO1xyXG5cdGNvbnN0IGRlZmluZXMgPSBjcmVhdGVEZWZpbmVzKHNvdXJjZXMuZGVmaW5lKTtcclxuXHRjb25zdCBjb21tb24gPSBkZWZpbmVzICsgKHNvdXJjZXMuY29tbW9uIHx8ICcnKTtcclxuXHRjb25zdCB2ZXJ0ID0gY29tbW9uICsgc291cmNlcy52ZXJ0O1xyXG5cdGNvbnN0IGZyYWcgPSBjb21tb24gKyBzb3VyY2VzLmZyYWc7XHJcblx0Ly8gY29tcGlsZSBzaGFkZXJzXHJcblx0Y29uc3QgdmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgdmVydCwgJ1ZFUlRFWF9TSEFERVInKTtcclxuXHRjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGZyYWcsICdGUkFHTUVOVF9TSEFERVInKTtcclxuXHQvLyBwYXJzZSBzb3VyY2UgZm9yIGF0dHJpYnV0ZSBhbmQgdW5pZm9ybXNcclxuXHRzZXRBdHRyaWJ1dGVzQW5kVW5pZm9ybXMoc2hhZGVyLCB2ZXJ0LCBmcmFnKTtcclxuXHQvLyBjcmVhdGUgdGhlIHNoYWRlciBwcm9ncmFtXHJcblx0c2hhZGVyLnByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcblx0Ly8gYXR0YWNoIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyc1xyXG5cdGdsLmF0dGFjaFNoYWRlcihzaGFkZXIucHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcclxuXHRnbC5hdHRhY2hTaGFkZXIoc2hhZGVyLnByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuXHQvLyBiaW5kIHZlcnRleCBhdHRyaWJ1dGUgbG9jYXRpb25zIEJFRk9SRSBsaW5raW5nXHJcblx0YmluZEF0dHJpYnV0ZUxvY2F0aW9ucyhzaGFkZXIpO1xyXG5cdC8vIGxpbmsgc2hhZGVyXHJcblx0Z2wubGlua1Byb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xyXG5cdC8vIElmIGNyZWF0aW5nIHRoZSBzaGFkZXIgcHJvZ3JhbSBmYWlsZWQsIGFsZXJ0XHJcblx0aWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlci5wcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcclxuXHRcdHRocm93IGBBbiBlcnJvciBvY2N1cmVkIGxpbmtpbmcgdGhlIHNoYWRlcjpcXG4ke2dsLmdldFByb2dyYW1JbmZvTG9nKHNoYWRlci5wcm9ncmFtKX1gO1xyXG5cdH1cclxuXHQvLyBnZXQgc2hhZGVyIHVuaWZvcm0gbG9jYXRpb25zXHJcblx0Z2V0VW5pZm9ybUxvY2F0aW9ucyhzaGFkZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHNoYWRlciBwcm9ncmFtLlxyXG4gKi9cclxuY2xhc3MgU2hhZGVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgU2hhZGVyIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBXZWJHTCBjb250ZXh0LlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgc2hhZGVyIHBhcmFtcyBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jb21tb24gLSBDb21tb24gZ2xzbCB0byBiZSBzaGFyZWQgYnkgYm90aCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy52ZXJ0IC0gVGhlIHZlcnRleCBzaGFkZXIgZ2xzbC5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZyYWcgLSBUaGUgZnJhZ21lbnQgc2hhZGVyIGdsc2wuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5kZWZpbmUgLSBBbnkgI2RlZmluZSBkaXJlY3RpdmVzIHRvIGluY2x1ZGUgaW4gdGhlIGdsc2wuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZ2wsIHBhcmFtcyA9IHt9KSB7XHJcblx0XHQvLyBjaGVjayBzb3VyY2UgYXJndW1lbnRzXHJcblx0XHRpZiAoIXBhcmFtcy52ZXJ0KSB7XHJcblx0XHRcdHRocm93ICdWZXJ0ZXggc2hhZGVyIGFyZ3VtZW50IGB2ZXJ0YCBoYXMgbm90IGJlZW4gcHJvdmlkZWQnO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFwYXJhbXMuZnJhZykge1xyXG5cdFx0XHR0aHJvdyAnRnJhZ21lbnQgc2hhZGVyIGFyZ3VtZW50IGBmcmFnYCBoYXMgbm90IGJlZW4gcHJvdmlkZWQnO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5nbCA9IGdsO1xyXG5cdFx0dGhpcy5wcm9ncmFtID0gbnVsbDtcclxuXHRcdHRoaXMuYXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXMudW5pZm9ybXMgPSBuZXcgTWFwKCk7XHJcblx0XHQvLyBjcmVhdGUgdGhlIHNoYWRlciBwcm9ncmFtXHJcblx0XHRjcmVhdGVQcm9ncmFtKHRoaXMsIHBhcmFtcyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBCaW5kcyB0aGUgc2hhZGVyIHByb2dyYW0gZm9yIHVzZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtTaGFkZXJ9IFRoZSBzaGFkZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0dXNlKCkge1xyXG5cdFx0Ly8gdXNlIHRoZSBzaGFkZXJcclxuXHRcdHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBCdWZmZXIgYSB1bmlmb3JtIHZhbHVlIGJ5IG5hbWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSB1bmlmb3JtIG5hbWUgaW4gdGhlIHNoYWRlciBzb3VyY2UuXHJcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB1bmlmb3JtIHZhbHVlIHRvIGJ1ZmZlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtTaGFkZXJ9IFRoZSBzaGFkZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0c2V0VW5pZm9ybShuYW1lLCB2YWx1ZSkge1xyXG5cdFx0Y29uc3QgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXMuZ2V0KG5hbWUpO1xyXG5cdFx0Ly8gZW5zdXJlIHRoYXQgdGhlIHVuaWZvcm0gcGFyYW1zIGV4aXN0cyBmb3IgdGhlIG5hbWVcclxuXHRcdGlmICghdW5pZm9ybSkge1xyXG5cdFx0XHR0aHJvdyBgTm8gdW5pZm9ybSBmb3VuZCB1bmRlciBuYW1lIFxcYCR7bmFtZX1cXGBgO1xyXG5cdFx0fVxyXG5cdFx0Ly8gY2hlY2sgdmFsdWVcclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XHJcblx0XHRcdC8vIGVuc3VyZSB0aGF0IHRoZSB1bmlmb3JtIGFyZ3VtZW50IGlzIGRlZmluZWRcclxuXHRcdFx0dGhyb3cgYFZhbHVlIHBhc3NlZCBmb3IgdW5pZm9ybSBcXGAke25hbWV9XFxgIGlzIHVuZGVmaW5lZCBvciBudWxsYDtcclxuXHRcdH1cclxuXHRcdC8vIHNldCB0aGUgdW5pZm9ybVxyXG5cdFx0Ly8gTk9URTogY2hlY2tpbmcgdHlwZSBieSBzdHJpbmcgY29tcGFyaXNvbiBpcyBmYXN0ZXIgdGhhbiB3cmFwcGluZ1xyXG5cdFx0Ly8gdGhlIGZ1bmN0aW9ucy5cclxuXHRcdGlmICh1bmlmb3JtLnR5cGUgPT09ICdtYXQyJyB8fCB1bmlmb3JtLnR5cGUgPT09ICdtYXQzJyB8fCB1bmlmb3JtLnR5cGUgPT09ICdtYXQ0Jykge1xyXG5cdFx0XHR0aGlzLmdsW3VuaWZvcm0uZnVuY10odW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuZ2xbdW5pZm9ybS5mdW5jXSh1bmlmb3JtLmxvY2F0aW9uLCB2YWx1ZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBwcmVwcm9jZXNzID0gcmVxdWlyZSgnLi9wcmVwcm9jZXNzJyk7XHJcblxyXG4vLyBDb25zdGFudHNcclxuXHJcbmNvbnN0IENPTU1FTlRTX1JFR0VYUCA9IC8oXFwvXFwqKFtcXHNcXFNdKj8pXFwqXFwvKXwoXFwvXFwvKC4qKSQpL2dtO1xyXG5jb25zdCBFTkRMSU5FX1JFR0VYUCA9IC8oXFxyXFxufFxcbnxcXHIpL2dtO1xyXG5jb25zdCBXSElURVNQQUNFX1JFR0VYUCA9IC9cXHN7Mix9L2c7XHJcbmNvbnN0IEJSQUNLRVRfV0hJVEVTUEFDRV9SRUdFWFAgPSAvKFxccyopKFxcWykoXFxzKikoXFxkKykoXFxzKikoXFxdKShcXHMqKS9nO1xyXG5jb25zdCBOQU1FX0NPVU5UX1JFR0VYUCA9IC8oW2EtekEtWl9dW2EtekEtWjAtOV9dKikoPzpcXFsoXFxkKylcXF0pPy87XHJcbmNvbnN0IFBSRUNJU0lPTl9SRUdFWCA9IC9cXGJwcmVjaXNpb25cXHMrXFx3K1xccytcXHcrOy9nO1xyXG5jb25zdCBJTkxJTkVfUFJFQ0lTSU9OX1JFR0VYID0gL1xcYihoaWdocHxtZWRpdW1wfGxvd3ApXFxzKy9nO1xyXG5cclxuLy8gUHJpdmF0ZSBNZXRob2RzXHJcblxyXG5jb25zdCBzdHJpcENvbW1lbnRzID0gZnVuY3Rpb24oc3RyKSB7XHJcblx0Ly8gcmVnZXggc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW9hZ3JpdXMvc3RyaXBjb21tZW50c1xyXG5cdHJldHVybiBzdHIucmVwbGFjZShDT01NRU5UU19SRUdFWFAsICcnKTtcclxufTtcclxuXHJcbmNvbnN0IHN0cmlwUHJlY2lzaW9uID0gZnVuY3Rpb24oc3RyKSB7XHJcblx0cmV0dXJuIHN0clxyXG5cdFx0LnJlcGxhY2UoUFJFQ0lTSU9OX1JFR0VYLCAnJykgLy8gcmVtb3ZlIGdsb2JhbCBwcmVjaXNpb24gZGVjbGFyYXRpb25zXHJcblx0XHQucmVwbGFjZShJTkxJTkVfUFJFQ0lTSU9OX1JFR0VYLCAnJyk7IC8vIHJlbW92ZSBpbmxpbmUgcHJlY2lzaW9uIGRlY2xhcmF0aW9uc1xyXG59O1xyXG5cclxuY29uc3Qgbm9ybWFsaXplV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKHN0cikge1xyXG5cdHJldHVybiBzdHJcclxuXHRcdC5yZXBsYWNlKEVORExJTkVfUkVHRVhQLCAnICcpIC8vIG5vcm1hbGl6ZSBsaW5lIGVuZGluZ3NcclxuXHRcdC5yZXBsYWNlKFdISVRFU1BBQ0VfUkVHRVhQLCAnICcpIC8vIG5vcm1hbGl6ZSB3aGl0ZXNwYWNlIHRvIHNpbmdsZSAnICdcclxuXHRcdC5yZXBsYWNlKEJSQUNLRVRfV0hJVEVTUEFDRV9SRUdFWFAsICckMiQ0JDYnKTsgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgaW4gYnJhY2tldHNcclxufTtcclxuXHJcbmNvbnN0IHBhcnNlTmFtZUFuZENvdW50ID0gZnVuY3Rpb24ocXVhbGlmaWVyLCB0eXBlLCBlbnRyeSkge1xyXG5cdC8vIGRldGVybWluZSBuYW1lIGFuZCBzaXplIG9mIHZhcmlhYmxlXHJcblx0Y29uc3QgbWF0Y2hlcyA9IGVudHJ5Lm1hdGNoKE5BTUVfQ09VTlRfUkVHRVhQKTtcclxuXHRjb25zdCBuYW1lID0gbWF0Y2hlc1sxXTtcclxuXHRjb25zdCBjb3VudCA9IChtYXRjaGVzWzJdID09PSB1bmRlZmluZWQpID8gMSA6IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKTtcclxuXHRyZXR1cm4ge1xyXG5cdFx0cXVhbGlmaWVyOiBxdWFsaWZpZXIsXHJcblx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0bmFtZTogbmFtZSxcclxuXHRcdGNvdW50OiBjb3VudFxyXG5cdH07XHJcbn07XHJcblxyXG5jb25zdCBwYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKHN0YXRlbWVudCkge1xyXG5cdC8vIHNwbGl0IHN0YXRlbWVudCBvbiBjb21tYXNcclxuXHQvL1xyXG5cdC8vIFsndW5pZm9ybSBtYXQ0IEFbMTBdJywgJ0InLCAnQ1syXSddXHJcblx0Ly9cclxuXHRjb25zdCBzcGxpdCA9IHN0YXRlbWVudC5zcGxpdCgnLCcpLm1hcChlbGVtID0+IHtcclxuXHRcdHJldHVybiBlbGVtLnRyaW0oKTtcclxuXHR9KTtcclxuXHJcblx0Ly8gc3BsaXQgZGVjbGFyYXRpb24gaGVhZGVyIGZyb20gc3RhdGVtZW50XHJcblx0Ly9cclxuXHQvLyBbJ3VuaWZvcm0nLCAnbWF0NCcsICdBWzEwXSddXHJcblx0Ly9cclxuXHRjb25zdCBoZWFkZXIgPSBzcGxpdC5zaGlmdCgpLnNwbGl0KCcgJyk7XHJcblxyXG5cdC8vIHF1YWxpZmllciBpcyBhbHdheXMgZmlyc3QgZWxlbWVudFxyXG5cdC8vXHJcblx0Ly8gJ3VuaWZvcm0nXHJcblx0Ly9cclxuXHRjb25zdCBxdWFsaWZpZXIgPSBoZWFkZXIuc2hpZnQoKTtcclxuXHJcblx0Ly8gdHlwZSB3aWxsIGJlIHRoZSBzZWNvbmQgZWxlbWVudFxyXG5cdC8vXHJcblx0Ly8gJ21hdDQnXHJcblx0Ly9cclxuXHRjb25zdCB0eXBlID0gaGVhZGVyLnNoaWZ0KCk7XHJcblxyXG5cdC8vIGxhc3QgcGFydCBvZiBoZWFkZXIgd2lsbCBiZSB0aGUgZmlyc3QsIGFuZCBwb3NzaWJsZSBvbmx5IHZhcmlhYmxlIG5hbWVcclxuXHQvL1xyXG5cdC8vIFsnQVsxMF0nLCAnQicsICdDWzJdJ11cclxuXHQvL1xyXG5cdGNvbnN0IG5hbWVzID0gaGVhZGVyLmNvbmNhdChzcGxpdCk7XHJcblxyXG5cdC8vIGlmIHRoZXJlIGFyZSBvdGhlciBuYW1lcyBhZnRlciBhICcsJyBhZGQgdGhlbSBhcyB3ZWxsXHJcblx0cmV0dXJuIG5hbWVzLm1hcChuYW1lID0+IHtcclxuXHRcdHJldHVybiBwYXJzZU5hbWVBbmRDb3VudChxdWFsaWZpZXIsIHR5cGUsIG5hbWUpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuY29uc3QgcGFyc2VTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UsIGtleXdvcmRzKSB7XHJcblx0Ly8gc3BsaXRzIHRoZSBzb3VyY2Ugc3RyaW5nIGJ5IHNlbWktY29sb25zIGFuZCBjb25zdHJ1Y3RzIGFuIGFycmF5IG9mXHJcblx0Ly8gZGVjbGFyYXRpb24gb2JqZWN0cyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcXVhbGlmaWVyIGtleXdvcmRzLlxyXG5cclxuXHQvLyBnZXQgaW5kaXZpZHVhbCBzdGF0ZW1lbnRzIChhbnkgc2VxdWVuY2UgZW5kaW5nIGluIDspXHJcblx0Y29uc3Qgc3RhdGVtZW50cyA9IHNvdXJjZS5zcGxpdCgnOycpO1xyXG5cdC8vIGJ1aWxkIHJlZ2V4IGZvciBwYXJzaW5nIHN0YXRlbWVudHMgd2l0aCB0YXJnZXR0ZWQga2V5d29yZHNcclxuXHRjb25zdCBrZXl3b3JkU3RyID0ga2V5d29yZHMuam9pbignfCcpO1xyXG5cdGNvbnN0IGtleXdvcmRSZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFxiKCcgKyBrZXl3b3JkU3RyICsgJylcXFxcYi4qJyk7XHJcblx0Ly8gcGFyc2UgYW5kIHN0b3JlIGdsb2JhbCBwcmVjaXNpb24gc3RhdGVtZW50cyBhbmQgYW55IGRlY2xhcmF0aW9uc1xyXG5cdGxldCBtYXRjaGVkID0gW107XHJcblx0Ly8gZm9yIGVhY2ggc3RhdGVtZW50XHJcblx0c3RhdGVtZW50cy5mb3JFYWNoKHN0YXRlbWVudCA9PiB7XHJcblx0XHQvLyBjaGVjayBmb3Iga2V5d29yZHNcclxuXHRcdC8vXHJcblx0XHQvLyBbJ3VuaWZvcm0gZmxvYXQgdVRpbWUnXVxyXG5cdFx0Ly9cclxuXHRcdGNvbnN0IGttYXRjaCA9IHN0YXRlbWVudC5tYXRjaChrZXl3b3JkUmVnZXgpO1xyXG5cdFx0aWYgKGttYXRjaCkge1xyXG5cdFx0XHQvLyBwYXJzZSBzdGF0ZW1lbnQgYW5kIGFkZCB0byBhcnJheVxyXG5cdFx0XHRtYXRjaGVkID0gbWF0Y2hlZC5jb25jYXQocGFyc2VTdGF0ZW1lbnQoa21hdGNoWzBdKSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0cmV0dXJuIG1hdGNoZWQ7XHJcbn07XHJcblxyXG5jb25zdCBmaWx0ZXJEdXBsaWNhdGVzQnlOYW1lID0gZnVuY3Rpb24oZGVjbGFyYXRpb25zKSB7XHJcblx0Ly8gaW4gY2FzZXMgd2hlcmUgdGhlIHNhbWUgZGVjbGFyYXRpb25zIGFyZSBwcmVzZW50IGluIG11bHRpcGxlXHJcblx0Ly8gc291cmNlcywgdGhpcyBmdW5jdGlvbiB3aWxsIHJlbW92ZSBkdXBsaWNhdGVzIGZyb20gdGhlIHJlc3VsdHNcclxuXHRjb25zdCBzZWVuID0ge307XHJcblx0cmV0dXJuIGRlY2xhcmF0aW9ucy5maWx0ZXIoZGVjbGFyYXRpb24gPT4ge1xyXG5cdFx0aWYgKHNlZW5bZGVjbGFyYXRpb24ubmFtZV0pIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0c2VlbltkZWNsYXJhdGlvbi5uYW1lXSA9IHRydWU7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIHByb3ZpZGVkIEdMU0wgc291cmNlLCBhbmQgcmV0dXJucyBhbGwgZGVjbGFyYXRpb24gc3RhdGVtZW50cyB0aGF0XHJcbiAqIGNvbnRhaW4gdGhlIHByb3ZpZGVkIHF1YWxpZmllciB0eXBlcy4gVGhpcyBjYW4gYmUgdXNlZCB0byBleHRyYWN0IHRoZVxyXG4gKiBhdHRyaWJ1dGVzIGFuZCB1bmlmb3JtIG5hbWVzIC8gdHlwZXMgZnJvbSBhIHNoYWRlci5cclxuICogTk9URTogVGhpcyBpcyBydW4gb25seSBBRlRFUiBjb21waWxhdGlvbiBzdWNjZWVkLCBzbyBpdCBhc3N1bWVzIFZBTElEIHN5bnRheC5cclxuICpcclxuICogRXgsIHdoZW4gcHJvdmlkZWQgYSAndW5pZm9ybScgcXVhbGlmaWVyLCB0aGUgZGVjbGFyYXRpb246XHJcbiAqXHJcbiAqICAgICd1bmlmb3JtIGhpZ2hwIHZlYzMgdVNwZWN1bGFyQ29sb3I7J1xyXG4gKlxyXG4gKiBXb3VsZCBiZSBwYXJzZWQgdG86XHJcbiAqICAgIHtcclxuICogICAgICAgIHF1YWxpZmllcjogJ3VuaWZvcm0nLFxyXG4gKiAgICAgICAgdHlwZTogJ3ZlYzMnXHJcbiAqICAgICAgICBuYW1lOiAndVNwZWN1bGFyQ29sb3InLFxyXG4gKiAgICAgICAgY291bnQ6IDFcclxuICogICAgfVxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIC0gVGhlIHNoYWRlciBnbHNsIHNvdXJjZXMuXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHF1YWxpZmllcnMgLSBUaGUgcXVhbGlmaWVycyB0byBleHRyYWN0LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBxdWFsaWZpZXIgZGVjbGFyYXRpb24gc3RhdGVtZW50cy5cclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc291cmNlcyA9IFtdLCBxdWFsaWZpZXJzID0gW10pIHtcclxuXHQvLyBpZiBubyBzb3VyY2VzIG9yIHF1YWxpZmllcnMgYXJlIHByb3ZpZGVkLCByZXR1cm4gZW1wdHkgYXJyYXlcclxuXHRpZiAoc291cmNlcy5sZW5ndGggPT09IDAgfHwgcXVhbGlmaWVycy5sZW5ndGggPT09IDApIHtcclxuXHRcdHJldHVybiBbXTtcclxuXHR9XHJcblx0c291cmNlcyA9IEFycmF5LmlzQXJyYXkoc291cmNlcykgPyBzb3VyY2VzIDogW3NvdXJjZXNdO1xyXG5cdHF1YWxpZmllcnMgPSBBcnJheS5pc0FycmF5KHF1YWxpZmllcnMpID8gcXVhbGlmaWVycyA6IFtxdWFsaWZpZXJzXTtcclxuXHQvLyBwYXJzZSBvdXQgdGFyZ2V0dGVkIGRlY2xhcmF0aW9uc1xyXG5cdGxldCBkZWNsYXJhdGlvbnMgPSBbXTtcclxuXHRzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHtcclxuXHRcdC8vIHJlbW92ZSBjb21tZW50c1xyXG5cdFx0c291cmNlID0gc3RyaXBDb21tZW50cyhzb3VyY2UpO1xyXG5cdFx0Ly8gcnVuIHByZXByb2Nlc3NvclxyXG5cdFx0c291cmNlID0gcHJlcHJvY2Vzcyhzb3VyY2UpO1xyXG5cdFx0Ly8gcmVtb3ZlIHByZWNpc2lvbiBzdGF0ZW1lbnRzXHJcblx0XHRzb3VyY2UgPSBzdHJpcFByZWNpc2lvbihzb3VyY2UpO1xyXG5cdFx0Ly8gZmluYWxseSwgbm9ybWFsaXplIHRoZSB3aGl0ZXNwYWNlXHJcblx0XHRzb3VyY2UgPSBub3JtYWxpemVXaGl0ZXNwYWNlKHNvdXJjZSk7XHJcblx0XHQvLyBwYXJzZSBvdXQgZGVjbGFyYXRpb25zXHJcblx0XHRkZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnMuY29uY2F0KHBhcnNlU291cmNlKHNvdXJjZSwgcXVhbGlmaWVycykpO1xyXG5cdH0pO1xyXG5cdC8vIHJlbW92ZSBkdXBsaWNhdGVzIGFuZCByZXR1cm5cclxuXHRyZXR1cm4gZmlsdGVyRHVwbGljYXRlc0J5TmFtZShkZWNsYXJhdGlvbnMpO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBERUZJTkVEID0gJ19fREVGSU5FRF9fJztcclxuXHJcbmNvbnN0IERFRklORV9SRUdFWCA9IC8jZGVmaW5lXFxiL2k7XHJcbmNvbnN0IFVOREVGX1JFR0VYID0gLyN1bmRlZlxcYi9pO1xyXG5jb25zdCBJRl9SRUdFWCA9IC8jaWZcXGIvaTtcclxuY29uc3QgSUZERUZfUkVHRVggPSAvI2lmZGVmXFxiL2k7XHJcbmNvbnN0IElGTkRFRl9SRUdFWCA9IC8jaWZuZGVmXFxiL2k7XHJcbmNvbnN0IEVMU0VfUkVHRVggPSAvI2Vsc2VcXGIvaTtcclxuY29uc3QgRUxJRl9SRUdFWCA9IC8jZWxpZlxcYi9pO1xyXG5jb25zdCBFTkRJRl9SRUdFWCA9IC8jZW5kaWZcXGIvaTtcclxuXHJcbmNvbnN0IFBBUlNFX0RFRklORV9SRUdFWCA9IC8jZGVmaW5lXFxzKyhcXHcrKShcXHMoXFx3Kik/KT8vaTtcclxuY29uc3QgUEFSU0VfVU5ERUZfUkVHRVggPSAvI3VuZGVmXFxzKyhcXHcrKS9pO1xyXG5jb25zdCBQQVJTRV9JRl9SRUdFWCA9IC8jaWZcXHMrXFwoP1xccyooIT9cXHMqXFx3KylcXHMqKD09fCE9fD49fDw9fDx8Pik/XFxzKihcXHcqKVxccypcXCk/L2k7XHJcbmNvbnN0IFBBUlNFX0lGREVGX1JFR0VYID0gLyNpZmRlZlxccysoXFx3KykvaTtcclxuY29uc3QgUEFSU0VfSUZOREVGX1JFR0VYID0gLyNpZm5kZWZcXHMrKFxcdyspL2k7XHJcbmNvbnN0IFBBUlNFX0VMSUZfUkVHRVggPSAvI2VsaWZcXHMrXFwoP1xccyooIT9cXHMqXFx3KylcXHMqKD09fCE9fD49fDw9fDx8Pik/XFxzKihcXHcqKVxccypcXCk/L2k7XHJcbmNvbnN0IFJFTUFJTklOR19SRUdFWCA9IC8jKFtcXFdcXHdcXHNcXGRdKSg/Oi4qXFxcXHI/XFxuKSouKiQvZ207XHJcblxyXG5jb25zdCBldmFsSWYgPSBmdW5jdGlvbihhLCBsb2dpYywgYikge1xyXG5cdGlmIChsb2dpYyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRpZiAoYVswXSA9PT0gJyEnKSB7XHJcblx0XHRcdHJldHVybiAhKGEgPT09ICd0cnVlJyB8fCBhID49IDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGEgPT09ICd0cnVlJyB8fCBhID49IDE7XHJcblx0fVxyXG5cdHN3aXRjaCAobG9naWMpIHtcclxuXHRcdGNhc2UgJz09JzpcclxuXHRcdFx0cmV0dXJuIGEgPT09IGI7XHJcblx0XHRjYXNlICchPSc6XHJcblx0XHRcdHJldHVybiBhICE9PSBiO1xyXG5cdFx0Y2FzZSAnPic6XHJcblx0XHRcdHJldHVybiBhID4gYjtcclxuXHRcdGNhc2UgJz49JzpcclxuXHRcdFx0cmV0dXJuIGEgPj0gYjtcclxuXHRcdGNhc2UgJzwnOlxyXG5cdFx0XHRyZXR1cm4gYSA8IGI7XHJcblx0XHRjYXNlICc8PSc6XHJcblx0XHRcdHJldHVybiBhIDw9IGI7XHJcblx0fVxyXG5cdHRocm93IGBVbnJlY29nbml6ZWQgbG9naWNhbCBvcGVyYXRvciBcXGAke2xvZ2ljfVxcYGA7XHJcbn07XHJcblxyXG5jbGFzcyBDb25kaXRpb25hbCB7XHJcblx0Y29uc3RydWN0b3IodHlwZSwgY29uZGl0aW9uYWwpIHtcclxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XHJcblx0XHR0aGlzLmNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwudHJpbSgpO1xyXG5cdFx0dGhpcy5ib2R5ID0gW107XHJcblx0XHR0aGlzLmNoaWxkcmVuID0gW107XHJcblx0fVxyXG5cdGV2YWwoKSB7XHJcblx0XHRsZXQgcGFyc2VkO1xyXG5cdFx0c3dpdGNoICh0aGlzLnR5cGUpIHtcclxuXHRcdFx0Y2FzZSAnaWYnOlxyXG5cdFx0XHRcdHBhcnNlZCA9IFBBUlNFX0lGX1JFR0VYLmV4ZWModGhpcy5jb25kaXRpb25hbCk7XHJcblx0XHRcdFx0cmV0dXJuIGV2YWxJZihwYXJzZWRbMV0sIHBhcnNlZFsyXSwgcGFyc2VkWzNdKTtcclxuXHRcdFx0Y2FzZSAnaWZkZWYnOlxyXG5cdFx0XHRcdHBhcnNlZCA9IFBBUlNFX0lGREVGX1JFR0VYLmV4ZWModGhpcy5jb25kaXRpb25hbCk7XHJcblx0XHRcdFx0cmV0dXJuIHBhcnNlZFsxXSA9PT0gREVGSU5FRDtcclxuXHRcdFx0Y2FzZSAnaWZuZGVmJzpcclxuXHRcdFx0XHRwYXJzZWQgPSBQQVJTRV9JRk5ERUZfUkVHRVguZXhlYyh0aGlzLmNvbmRpdGlvbmFsKTtcclxuXHRcdFx0XHRyZXR1cm4gcGFyc2VkWzFdICE9PSBERUZJTkVEO1xyXG5cdFx0XHRjYXNlICdlbGlmJzpcclxuXHRcdFx0XHRwYXJzZWQgPSBQQVJTRV9FTElGX1JFR0VYLmV4ZWModGhpcy5jb25kaXRpb25hbCk7XHJcblx0XHRcdFx0cmV0dXJuIGV2YWxJZihwYXJzZWRbMV0sIHBhcnNlZFsyXSwgcGFyc2VkWzNdKTtcclxuXHRcdH1cclxuXHRcdHRocm93IGBVbnJlY29nbml6ZWQgY29uZGl0aW9uYWwgdHlwZSBcXGAke3RoaXMudHlwZX1cXGBgO1xyXG5cdH1cclxufVxyXG5cclxuY2xhc3MgQmxvY2sge1xyXG5cdGNvbnN0cnVjdG9yKHR5cGUsIGNvbmRpdGlvbmFsLCBsaW5lTnVtKSB7XHJcblx0XHR0aGlzLmlmID0gbmV3IENvbmRpdGlvbmFsKHR5cGUsIGNvbmRpdGlvbmFsKTtcclxuXHRcdHRoaXMuZWxpZiA9IFtdO1xyXG5cdFx0dGhpcy5lbHNlID0gbnVsbDtcclxuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHRcdHRoaXMuY3VycmVudCA9IHRoaXMuaWY7XHJcblx0XHR0aGlzLnN0YXJ0TGluZSA9IGxpbmVOdW07XHJcblx0XHR0aGlzLmVuZExpbmUgPSBudWxsO1xyXG5cdH1cclxuXHRhZGRFbHNlKGNvbmRpdGlvbmFsKSB7XHJcblx0XHR0aGlzLmN1cnJlbnQgPSBuZXcgQ29uZGl0aW9uYWwoJ2Vsc2UnLCBjb25kaXRpb25hbCk7XHJcblx0XHR0aGlzLmVsc2UgPSB0aGlzLmN1cnJlbnQ7XHJcblx0fVxyXG5cdGFkZEVsaWYoY29uZGl0aW9uYWwpIHtcclxuXHRcdHRoaXMuY3VycmVudCA9IG5ldyBDb25kaXRpb25hbCgnZWxpZicsIGNvbmRpdGlvbmFsKTtcclxuXHRcdHRoaXMuZWxpZi5wdXNoKHRoaXMuY3VycmVudCk7XHJcblx0fVxyXG5cdGFkZEJvZHkobGluZSwgbGluZU51bSkge1xyXG5cdFx0dGhpcy5jdXJyZW50LmJvZHkucHVzaCh7XHJcblx0XHRcdHN0cmluZzogbGluZS50cmltKCksXHJcblx0XHRcdGxpbmU6IGxpbmVOdW1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHRuZXN0KGJsb2NrKSB7XHJcblx0XHRibG9jay5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0dGhpcy5jdXJyZW50LmNoaWxkcmVuLnB1c2goYmxvY2spO1xyXG5cdH1cclxuXHRleHRyYWN0KCkge1xyXG5cdFx0Ly8gI2lmXHJcblx0XHRsZXQgYm9keSA9IFtdO1xyXG5cdFx0aWYgKHRoaXMuaWYuZXZhbCgpKSB7XHJcblx0XHRcdGJvZHkgPSBib2R5LmNvbmNhdCh0aGlzLmlmLmJvZHkpO1xyXG5cdFx0XHR0aGlzLmlmLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xyXG5cdFx0XHRcdGJvZHkgPSBib2R5LmNvbmNhdChjaGlsZC5leHRyYWN0KCkpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIGJvZHk7XHJcblx0XHR9XHJcblx0XHQvLyAjZWxpZlxyXG5cdFx0Zm9yIChsZXQgaT0wOyBpPHRoaXMuZWxpZi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjb25zdCBlbGlmID0gdGhpcy5lbGlmW2ldO1xyXG5cdFx0XHRpZiAoZWxpZi5ldmFsKCkpIHtcclxuXHRcdFx0XHRib2R5ID0gYm9keS5jb25jYXQoZWxpZi5ib2R5KTtcclxuXHRcdFx0XHRmb3IgKGxldCBqPTA7IGo8ZWxpZi5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0Y29uc3QgY2hpbGQgPSBlbGlmLmNoaWxkcmVuW2pdO1xyXG5cdFx0XHRcdFx0Ym9keSA9IGJvZHkuY29uY2F0KGNoaWxkLmV4dHJhY3QoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBib2R5O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyAjZWxzZVxyXG5cdFx0aWYgKHRoaXMuZWxzZSkge1xyXG5cdFx0XHRib2R5ID0gYm9keS5jb25jYXQodGhpcy5lbHNlLmJvZHkpO1xyXG5cdFx0XHR0aGlzLmVsc2UuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XHJcblx0XHRcdFx0Ym9keSA9IGJvZHkuY29uY2F0KGNoaWxkLmV4dHJhY3QoKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gYm9keTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBbXTtcclxuXHR9XHJcblx0ZXZhbCgpIHtcclxuXHRcdC8vIGVuc3VyZSBleHRyYWN0IHRleHQgaXMgb3JkZXJlZCBjb3JyZWN0bHlcclxuXHRcdHJldHVybiB0aGlzLmV4dHJhY3QoKS5zb3J0KChhLCBiKSA9PiB7XHJcblx0XHRcdHJldHVybiBhLmxpbmUgLSBiLmxpbmU7XHJcblx0XHR9KS5tYXAoYXJnID0+IHtcclxuXHRcdFx0cmV0dXJuIGFyZy5zdHJpbmc7XHJcblx0XHR9KS5qb2luKCdcXG4nKTtcclxuXHR9XHJcbn1cclxuXHJcbmNvbnN0IHBhcnNlTGluZXMgPSBmdW5jdGlvbihsaW5lcykge1xyXG5cclxuXHRjb25zdCBibG9ja3MgPSBbXTtcclxuXHRsZXQgY3VycmVudCA9IG51bGw7XHJcblxyXG5cdGxpbmVzLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XHJcblxyXG5cdFx0aWYgKGxpbmUubWF0Y2goSUZfUkVHRVgpKSB7XHJcblx0XHRcdC8vICNpZlxyXG5cdFx0XHRjb25zdCBibG9jayA9IG5ldyBCbG9jaygnaWYnLCBsaW5lLCBpbmRleCk7XHJcblx0XHRcdGlmICghY3VycmVudCkge1xyXG5cdFx0XHRcdGJsb2Nrcy5wdXNoKGJsb2NrKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjdXJyZW50Lm5lc3QoYmxvY2spO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN1cnJlbnQgPSBibG9jaztcclxuXHJcblx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goSUZERUZfUkVHRVgpKSB7XHJcblx0XHRcdC8vICNpZmRlZlxyXG5cdFx0XHRjb25zdCBibG9jayA9IG5ldyBCbG9jaygnaWZkZWYnLCBsaW5lLCBpbmRleCk7XHJcblx0XHRcdGlmICghY3VycmVudCkge1xyXG5cdFx0XHRcdGJsb2Nrcy5wdXNoKGJsb2NrKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjdXJyZW50Lm5lc3QoYmxvY2spO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN1cnJlbnQgPSBibG9jaztcclxuXHJcblx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goSUZOREVGX1JFR0VYKSkge1xyXG5cdFx0XHQvLyAjaWZuZGVmXHJcblx0XHRcdGNvbnN0IGJsb2NrID0gbmV3IEJsb2NrKCdpZm5kZWYnLCBsaW5lLCBpbmRleCk7XHJcblx0XHRcdGlmICghY3VycmVudCkge1xyXG5cdFx0XHRcdGJsb2Nrcy5wdXNoKGJsb2NrKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjdXJyZW50Lm5lc3QoYmxvY2spO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN1cnJlbnQgPSBibG9jaztcclxuXHJcblx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goRUxJRl9SRUdFWCkpIHtcclxuXHRcdFx0Ly8gI2VsaWZcclxuXHRcdFx0aWYgKCFjdXJyZW50KSB7XHJcblx0XHRcdFx0dGhyb3cgJ0ludmFsaWQgcHJlcHJvY2Vzc29yIHN5bnRheCwgdW5leHBlY3RlZCBgI2VsaWZgJztcclxuXHRcdFx0fVxyXG5cdFx0XHRjdXJyZW50LmFkZEVsaWYobGluZSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChsaW5lLm1hdGNoKEVMU0VfUkVHRVgpKSB7XHJcblx0XHRcdC8vICNlbHNlXHJcblx0XHRcdGlmICghY3VycmVudCkge1xyXG5cdFx0XHRcdHRocm93ICdJbnZhbGlkIHByZXByb2Nlc3NvciBzeW50YXgsIHVuZXhwZWN0ZWQgYCNlbHNlYCc7XHJcblx0XHRcdH1cclxuXHRcdFx0Y3VycmVudC5hZGRFbHNlKGxpbmUpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAobGluZS5tYXRjaChFTkRJRl9SRUdFWCkpIHtcclxuXHRcdFx0Ly8gI2VuZGlmXHJcblx0XHRcdGlmICghY3VycmVudCkge1xyXG5cdFx0XHRcdHRocm93ICdJbnZhbGlkIHByZXByb2Nlc3NvciBzeW50YXgsIHVuZXhwZWN0ZWQgYCNlbmRpZmAnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGN1cnJlbnQuZW5kTGluZSA9IGluZGV4O1xyXG5cdFx0XHRjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gb3RoZXJcclxuXHRcdFx0aWYgKGN1cnJlbnQpIHtcclxuXHRcdFx0XHRjdXJyZW50LmFkZEJvZHkobGluZSwgaW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGlmIChjdXJyZW50KSB7XHJcblx0XHR0aHJvdyAnSW52YWxpZCBwcmVwcm9jZXNzb3Igc3ludGF4LCBtaXNzaW5nIGV4cGVjdGVkIGAjZW5kaWZgJztcclxuXHR9XHJcblxyXG5cdHJldHVybiBibG9ja3M7XHJcbn07XHJcblxyXG5jb25zdCByZXBsYWNlRGVmaW5lcyA9IGZ1bmN0aW9uKGxpbmVzKSB7XHJcblx0Y29uc3QgZGVmaW5lcyA9IG5ldyBNYXAoKTtcclxuXHRjb25zdCByZXBsYWNlZCA9IFtdO1xyXG5cdGxpbmVzLmZvckVhY2gobGluZSA9PiB7XHJcblx0XHRpZiAobGluZS5tYXRjaChERUZJTkVfUkVHRVgpKSB7XHJcblx0XHRcdC8vICNkZWZpbmVcclxuXHRcdFx0Y29uc3QgcGFyc2VkID0gUEFSU0VfREVGSU5FX1JFR0VYLmV4ZWMobGluZSk7XHJcblx0XHRcdGRlZmluZXMuc2V0KHBhcnNlZFsxXSwgcGFyc2VkWzJdIHx8IERFRklORUQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAobGluZS5tYXRjaChVTkRFRl9SRUdFWCkpIHtcclxuXHRcdFx0Ly8gI3VuZGVmXHJcblx0XHRcdGNvbnN0IHBhcnNlZCA9IFBBUlNFX1VOREVGX1JFR0VYLmV4ZWMobGluZSk7XHJcblx0XHRcdGRlZmluZXMuZGVsZXRlKHBhcnNlZFsxXSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChsaW5lLm1hdGNoKElGREVGX1JFR0VYKSkge1xyXG5cdFx0XHQvLyAjaWZkZWZcclxuXHRcdFx0Y29uc3QgcGFyc2VkID0gUEFSU0VfSUZERUZfUkVHRVguZXhlYyhsaW5lKTtcclxuXHRcdFx0aWYgKGRlZmluZXMuaGFzKHBhcnNlZFsxXSkpIHtcclxuXHRcdFx0XHRsaW5lID0gbGluZS5yZXBsYWNlKHBhcnNlZFsxXSwgREVGSU5FRCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmVwbGFjZWQucHVzaChsaW5lKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goSUZOREVGX1JFR0VYKSkge1xyXG5cdFx0XHQvLyAjaWZuZGVmXHJcblx0XHRcdGNvbnN0IHBhcnNlZCA9IFBBUlNFX0lGTkRFRl9SRUdFWC5leGVjKGxpbmUpO1xyXG5cdFx0XHRpZiAoZGVmaW5lcy5oYXMocGFyc2VkWzFdKSkge1xyXG5cdFx0XHRcdGxpbmUgPSBsaW5lLnJlcGxhY2UocGFyc2VkWzFdLCBERUZJTkVEKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXBsYWNlZC5wdXNoKGxpbmUpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHN3YXAgZGVmaW5lc1xyXG5cdFx0XHRkZWZpbmVzLmZvckVhY2goKHZhbCwgZGVmaW5lKSA9PiB7XHJcblx0XHRcdFx0bGluZSA9IGxpbmUucmVwbGFjZShkZWZpbmUsIHZhbCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXBsYWNlZC5wdXNoKGxpbmUpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHJldHVybiByZXBsYWNlZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFdmFsdWF0ZXMgR0xTTCBwcmVwcm9jZXNzb3Igc3RhdGVtZW50cy5cclxuICogTk9URTogYXNzdW1lcyBjb21tZW50cyBoYXZlIGJlZW4gc3RyaXBwZWQsIGFuZCBwcmVwcm9jZXNzb3JzIGFyZSB2YWxpZC5cclxuICpcclxuICogICAgIFN1cHBvcnRlZDpcclxuICpcclxuICogICAgICAgICAjZGVmaW5lIChzdWJzdGl0dXRpb25zIG9ubHkpXHJcbiAqICAgICAgICAgI3VuZGVmXHJcbiAqICAgICAgICAgI2lmICg9PSBhbmQgIT0gY29tcGFyaXNvbnMgb25seSlcclxuICogICAgICAgICAjaWZkZWZcclxuICogICAgICAgICAjaWZuZGVmXHJcbiAqICAgICAgICAgI2VsaWZcclxuICogICAgICAgICAjZWxzZVxyXG4gKiAgICAgICAgICNlbmRpZlxyXG4gKlxyXG4gKiAgICAgTm90IFN1cHBvcnRlZDpcclxuICpcclxuICogICAgICAgICAjZGVmaW5lIChtYWNyb3MpXHJcbiAqICAgICAgICAgI2lmICgmJiBhbmQgfHwgb3BlcmF0b3JzLCBkZWZpbmVkKCkgcHJlZGljYXRlKVxyXG4gKiAgICAgICAgICNlcnJvclxyXG4gKiAgICAgICAgICNwcmFnbWFcclxuICogICAgICAgICAjZXh0ZW5zaW9uXHJcbiAqICAgICAgICAgI3ZlcnNpb25cclxuICogICAgICAgICAjbGluZVxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2xzbCAtIFRoZSBnbHNsIHNvdXJjZSBjb2RlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcHJvY2Vzc2VkIGdsc2wgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdsc2wpIHtcclxuXHQvLyBzcGxpdCBsaW5lc1xyXG5cdGxldCBsaW5lcyA9IGdsc2wuc3BsaXQoJ1xcbicpO1xyXG5cdC8vIHJlcGxhY2UgYW55IGRlZmluZXMgd2l0aCB0aGVpciB2YWx1ZXNcclxuXHRsaW5lcyA9IHJlcGxhY2VEZWZpbmVzKGxpbmVzKTtcclxuXHQvLyBwYXJzZSB0aGVtXHJcblx0Y29uc3QgYmxvY2tzID0gcGFyc2VMaW5lcyhsaW5lcyk7XHJcblx0Ly8gcmVtb3ZlIGJsb2NrcyBpbiByZXZlcnNlIG9yZGVyIHRvIHByZXNlcnZlIGxpbmUgbnVtYmVyc1xyXG5cdGZvciAobGV0IGk9YmxvY2tzLmxlbmd0aCAtIDE7IGk+PTA7IGktLSkge1xyXG5cdFx0Y29uc3QgYmxvY2sgPSBibG9ja3NbaV07XHJcblx0XHRjb25zdCByZXBsYWNlbWVudCA9IGJsb2NrLmV2YWwoKTtcclxuXHRcdGlmIChyZXBsYWNlbWVudC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdGxpbmVzLnNwbGljZShibG9jay5zdGFydExpbmUsIGJsb2NrLmVuZExpbmUgLSBibG9jay5zdGFydExpbmUgKyAxLCByZXBsYWNlbWVudCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsaW5lcy5zcGxpY2UoYmxvY2suc3RhcnRMaW5lLCBibG9jay5lbmRMaW5lIC0gYmxvY2suc3RhcnRMaW5lICsgMSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIHN0cmlwIHJlbWFpbmluZyB1bnN1cHBvcnRlZCBwcmVwcm9jZXNzb3Igc3RhdGVtZW50c1xyXG5cdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKS5yZXBsYWNlKFJFTUFJTklOR19SRUdFWCwgJycpO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgdGV4dHVyZS5cclxuICovXHJcbmNsYXNzIFRleHR1cmUge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYSBUZXh0dXJlIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBXZWJHTCBjb250ZXh0LlxyXG5cdCAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8Q2FudmFzRWxlbWVudH0gc3JjIC0gVGhlIGRhdGEgdG8gYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHRleHR1cmUgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5oZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZvcm1hdCAtIFRoZSB0ZXh0dXJlIHBpeGVsIGZvcm1hdC5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50eXBlIC0gVGhlIHRleHR1cmUgcGl4ZWwgY29tcG9uZW50IHR5cGUuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy53cmFwIC0gVGhlIHdyYXBwaW5nIHR5cGUgb3ZlciBib3RoIFMgYW5kIFQgZGltZW5zaW9uLlxyXG5cdCAqIEBwYXJhbSB7Ym9vbH0gb3B0aW9ucy5pbnZlcnRZIC0gV2hldGhlciBvciBub3QgaW52ZXJ0LXkgaXMgZW5hYmxlZC5cclxuXHQgKiBAcGFyYW0ge2Jvb2x9IG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYSAtIFdoZXRoZXIgb3Igbm90IGFscGhhIHByZW11bHRpcGx5aW5nIGlzIGVuYWJsZWQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZ2wsIHNyYyA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0dGhpcy5nbCA9IGdsO1xyXG5cdFx0dGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cdFx0Ly8gc2V0IHRleHR1cmUgcHJvcGVydGllc1xyXG5cdFx0dGhpcy5mb3JtYXQgPSBkZWZhdWx0VG8ob3B0aW9ucy5mb3JtYXQsICdSR0JBJyk7XHJcblx0XHR0aGlzLnR5cGUgPSBkZWZhdWx0VG8ob3B0aW9ucy50eXBlLCAnVU5TSUdORURfQllURScpO1xyXG5cdFx0dGhpcy5maWx0ZXIgPSBkZWZhdWx0VG8ob3B0aW9ucy5maWx0ZXIsICdMSU5FQVInKTtcclxuXHRcdHRoaXMud3JhcCA9IGRlZmF1bHRUbyhvcHRpb25zLndyYXAsICdDTEFNUF9UT19FREdFJyk7XHJcblx0XHR0aGlzLmludmVydFkgPSBkZWZhdWx0VG8ob3B0aW9ucy5pbnZlcnRZLCBmYWxzZSk7XHJcblx0XHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBkZWZhdWx0VG8ob3B0aW9ucy5wcmVtdWx0aXBseUFscGhhLCBmYWxzZSk7XHJcblx0XHQvLyBidWZmZXIgdGhlIGRhdGFcclxuXHRcdHRoaXMuYnVmZmVyRGF0YShzcmMsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0KTtcclxuXHRcdC8vIHNldCBwYXJhbWV0ZXJzXHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbFt0aGlzLndyYXBdKTtcclxuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsW3RoaXMud3JhcF0pO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsW3RoaXMuZmlsdGVyXSk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xbdGhpcy5maWx0ZXJdKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEJpbmRzIHRoZSB0ZXh0dXJlIG9iamVjdCB0byB0aGUgcHJvdmlkZWQgdGV4dHVyZSB1bml0IGxvY2F0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxvY2F0aW9uIC0gVGhlIHRleHR1cmUgdW5pdCBsb2NhdGlvbiBpbmRleC4gT3B0aW9uYWwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGV4dHVyZX0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0YmluZChsb2NhdGlvbiA9IDApIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2xbYFRFWFRVUkUke2xvY2F0aW9ufWBdKTtcclxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuYmluZHMgdGhlIHRleHR1cmUgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RleHR1cmV9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHVuYmluZCgpIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBCdWZmZXIgZGF0YSBpbnRvIHRoZSB0ZXh0dXJlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlclZpZXd8bnVsbH0gZGF0YSAtIFRoZSBkYXRhIGFycmF5IHRvIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGRhdGEuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGRhdGEuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGV4dHVyZX0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0YnVmZmVyRGF0YShkYXRhLCB3aWR0aCwgaGVpZ2h0KSB7XHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblx0XHQvLyBiaW5kIHRleHR1cmVcclxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0aGlzLmludmVydFkpO1xyXG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLnByZW11bHRpcGx5QWxwaGEpO1xyXG5cdFx0Ly8gYnVmZmVyIHRoZSBkYXRhXHJcblx0XHRpZiAoZGF0YSAmJiBkYXRhLndpZHRoICYmIGRhdGEuaGVpZ2h0KSB7XHJcblx0XHRcdC8vIHN0b3JlIHdpZHRoIGFuZCBoZWlnaHRcclxuXHRcdFx0dGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XHJcblx0XHRcdHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XHJcblx0XHRcdC8vIGJ1ZmZlciB0aGUgdGV4dHVyZVxyXG5cdFx0XHRnbC50ZXhJbWFnZTJEKFxyXG5cdFx0XHRcdGdsLlRFWFRVUkVfMkQsXHJcblx0XHRcdFx0MCwgLy8gbWlwLW1hcCBsZXZlbFxyXG5cdFx0XHRcdGdsW3RoaXMuZm9ybWF0XSwgLy8gd2ViZ2wgcmVxdWlyZXMgZm9ybWF0ID09PSBpbnRlcm5hbEZvcm1hdFxyXG5cdFx0XHRcdGdsW3RoaXMuZm9ybWF0XSxcclxuXHRcdFx0XHRnbFt0aGlzLnR5cGVdLFxyXG5cdFx0XHRcdGRhdGEpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gc3RvcmUgd2lkdGggYW5kIGhlaWdodFxyXG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aDtcclxuXHRcdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQ7XHJcblx0XHRcdC8vIGJ1ZmZlciB0aGUgdGV4dHVyZSBkYXRhXHJcblx0XHRcdGdsLnRleEltYWdlMkQoXHJcblx0XHRcdFx0Z2wuVEVYVFVSRV8yRCxcclxuXHRcdFx0XHQwLCAvLyBtaXAtbWFwIGxldmVsXHJcblx0XHRcdFx0Z2xbdGhpcy5mb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XHJcblx0XHRcdFx0dGhpcy53aWR0aCxcclxuXHRcdFx0XHR0aGlzLmhlaWdodCxcclxuXHRcdFx0XHQwLCAvLyBib3JkZXIsIG11c3QgYmUgMFxyXG5cdFx0XHRcdGdsW3RoaXMuZm9ybWF0XSxcclxuXHRcdFx0XHRnbFt0aGlzLnR5cGVdLFxyXG5cdFx0XHRcdGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBCdWZmZXIgcGFydGlhbCBkYXRhIGludG8gdGhlIHRleHR1cmUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyVmlld3xudWxsfSBkYXRhIC0gVGhlIGRhdGEgYXJyYXkgdG8gYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4T2Zmc2V0IC0gVGhlIHggb2Zmc2V0IGF0IHdoaWNoIHRvIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0geU9mZnNldCAtIFRoZSB5IG9mZnNldCBhdCB3aGljaCB0byBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBkYXRhLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBkYXRhLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RleHR1cmV9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGJ1ZmZlclN1YkRhdGEoZGF0YSwgeE9mZnNldCA9IDAsIHlPZmZzZXQgPSAwLCB3aWR0aCA9IHVuZGVmaW5lZCwgaGVpZ2h0ID0gdW5kZWZpbmVkKSB7XHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblx0XHQvLyBiaW5kIHRleHR1cmVcclxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0aGlzLmludmVydFkpO1xyXG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLnByZW11bHRpcGx5QWxwaGEpO1xyXG5cdFx0Ly8gYnVmZmVyIHRoZSBkYXRhXHJcblx0XHRpZiAoZGF0YS53aWR0aCAmJiBkYXRhLmhlaWdodCkge1xyXG5cdFx0XHQvLyBidWZmZXIgdGhlIHRleHR1cmVcclxuXHRcdFx0Z2wudGV4U3ViSW1hZ2UyRChcclxuXHRcdFx0XHRnbC5URVhUVVJFXzJELFxyXG5cdFx0XHRcdDAsIC8vIG1pcC1tYXAgbGV2ZWxcclxuXHRcdFx0XHR4T2Zmc2V0LFxyXG5cdFx0XHRcdHlPZmZzZXQsXHJcblx0XHRcdFx0Z2xbdGhpcy5mb3JtYXRdLFxyXG5cdFx0XHRcdGdsW3RoaXMudHlwZV0sXHJcblx0XHRcdFx0ZGF0YSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBidWZmZXIgdGhlIHRleHR1cmUgZGF0YVxyXG5cdFx0XHRnbC50ZXhTdWJJbWFnZTJEKFxyXG5cdFx0XHRcdGdsLlRFWFRVUkVfMkQsXHJcblx0XHRcdFx0MCwgLy8gbWlwLW1hcCBsZXZlbFxyXG5cdFx0XHRcdHhPZmZzZXQsXHJcblx0XHRcdFx0eU9mZnNldCxcclxuXHRcdFx0XHR3aWR0aCxcclxuXHRcdFx0XHRoZWlnaHQsXHJcblx0XHRcdFx0Z2xbdGhpcy5mb3JtYXRdLFxyXG5cdFx0XHRcdGdsW3RoaXMudHlwZV0sXHJcblx0XHRcdFx0ZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc2l6ZSB0aGUgdW5kZXJseWluZyB0ZXh0dXJlLiBUaGlzIGNsZWFycyB0aGUgdGV4dHVyZSBkYXRhLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VGV4dHVyZX0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0cmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHRcdHRoaXMuYnVmZmVyRGF0YShudWxsLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XHJcblxyXG4vLyBQcml2YXRlIE1ldGhvZHNcclxuXHJcbmNvbnN0IGNyZWF0ZVRleHR1cmUgPSBmdW5jdGlvbihnbCwgZm9ybWF0LCBzaXplLCB0eXBlLCBmaWx0ZXIsIHdyYXAsIGludmVydFksIHByZW11bHRpcGx5QWxwaGEpIHtcclxuXHRjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGludmVydFkpO1xyXG5cdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgcHJlbXVsdGlwbHlBbHBoYSk7XHJcblx0Ly8gYnVmZmVyIHRoZSBkYXRhXHJcblx0Z2wudGV4SW1hZ2UyRChcclxuXHRcdGdsLlRFWFRVUkVfMkQsXHJcblx0XHQwLCAvLyBtaXAtbWFwIGxldmVsXHJcblx0XHRnbFtmb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XHJcblx0XHRzaXplLFxyXG5cdFx0c2l6ZSxcclxuXHRcdDAsIC8vIGJvcmRlciwgbXVzdCBiZSAwXHJcblx0XHRnbFtmb3JtYXRdLFxyXG5cdFx0Z2xbdHlwZV0sXHJcblx0XHRudWxsKTtcclxuXHQvLyBzZXQgcGFyYW1ldGVyc1xyXG5cdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsW3dyYXBdKTtcclxuXHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbFt3cmFwXSk7XHJcblx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsW2ZpbHRlcl0pO1xyXG5cdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbFtmaWx0ZXJdKTtcclxuXHRyZXR1cm4gdGV4dHVyZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB0ZXh0dXJlIGFycmF5LlxyXG4gKi9cclxuY2xhc3MgVGV4dHVyZUFycmF5IHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFRleHR1cmVBcnJheSBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBOT1RFOiB3ZSB1c2UgYSB0ZXh0dXJlIGFycmF5IHJhdGhlciB0aGFuIGEgdGV4dHVyZSBhdGxhcyBiZWNhdXNlIG9mXHJcblx0ICogdGhlIHN1Yi1waXhlbCBibGVlZGluZyB0aGF0IG9jY3VycyBpbiB0aGUgYXRsYXMgd2hlbiB0ZXh0dXJlcyBhcmVcclxuXHQgKiBub3QgcGFkZGVkLiBEdWUgdG8gdGhlIG92ZXJoZWFkIG9mIHBhZGRpbmcgY2xpZW50c2lkZSwgdGhlXHJcblx0ICogZnJlcXVlbmN5IG9mIGxvYWQgbG9hZCBldmVudHMsIGFuZCB0aGUgYXZlcmFnZSBudW1iZXIgb2YgdGlsZXMgb25cclxuXHQgKiB0aGUgc2NyZWVuIGF0IGFueSBvbmUgdGltZSwgYmluZGluZyBpbmRpdmlkdWFsIHRpbGUgdGV4dHVyZXNcclxuXHQgKiBwcm92aWRlcyBhIGxlc3Mgdm9sYXRpbGUgZnJhbWUgcmF0ZSBjb21wYXJlZCB0byBwYWRkaW5nIHRleHR1cmVzIGFuZFxyXG5cdCAqIHVzaW5nIGFuIGF0bGFzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSB0ZXh0dXJlIHBhcmFtZXRlcnMuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mb3JtYXQgLSBUaGUgdGV4dHVyZSBwaXhlbCBmb3JtYXQuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy50eXBlIC0gVGhlIHRleHR1cmUgcGl4ZWwgY29tcG9uZW50IHR5cGUuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5maWx0ZXIgLSBUaGUgbWluIC8gbWFnIGZpbHRlciB1c2VkIGR1cmluZyBzY2FsaW5nLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cclxuXHQgKiBAcGFyYW0ge2Jvb2x9IHBhcmFtcy5pbnZlcnRZIC0gV2hldGhlciBvciBub3QgaW52ZXJ0LXkgaXMgZW5hYmxlZC5cclxuXHQgKiBAcGFyYW0ge2Jvb2x9IHBhcmFtcy5wcmVtdWx0aXBseUFscGhhIC0gV2hldGhlciBvciBub3QgYWxwaGEgcHJlbXVsdGlwbHlpbmcgaXMgZW5hYmxlZC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSB0ZXh0dXJlIGFycmF5IG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2h1bmtTaXplIC0gVGhlIGRpbWVuc2lvbiBvZiBlYWNoIHRleHR1cmUsIGluIHBpeGVscy5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5udW1DaHVua3MgLSBUaGUgc2l6ZSBvZiB0aGUgYXJyYXksIGluIHRpbGVzLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGdsLCBwYXJhbXMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XHJcblx0XHR0aGlzLmdsID0gZ2w7XHJcblx0XHQvLyBzZXQgYXJyYXkgcHJvcGVydGllc1xyXG5cdFx0dGhpcy5jaHVua1NpemUgPSBkZWZhdWx0VG8ob3B0aW9ucy5jaHVua1NpemUsIDI1Nik7XHJcblx0XHR0aGlzLm51bUNodW5rcyA9IGRlZmF1bHRUbyhvcHRpb25zLm51bUNodW5rcywgMjU2KTtcclxuXHRcdC8vIHNldCB0ZXh0dXJlIHBhcmFtZXRlcnNcclxuXHRcdHRoaXMuZm9ybWF0ID0gZGVmYXVsdFRvKHBhcmFtcy5mb3JtYXQsICdSR0JBJyk7XHJcblx0XHR0aGlzLnR5cGUgPSBkZWZhdWx0VG8ocGFyYW1zLnR5cGUsICdVTlNJR05FRF9CWVRFJyk7XHJcblx0XHR0aGlzLmZpbHRlciA9IGRlZmF1bHRUbyhwYXJhbXMuZmlsdGVyLCAnTElORUFSJyk7XHJcblx0XHR0aGlzLndyYXAgPSBkZWZhdWx0VG8ocGFyYW1zLndyYXAsICdDTEFNUF9UT19FREdFJyk7XHJcblx0XHR0aGlzLmludmVydFkgPSBkZWZhdWx0VG8ocGFyYW1zLmludmVydFksIGZhbHNlKTtcclxuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGRlZmF1bHRUbyhwYXJhbXMucHJlbXVsdGlwbHlBbHBoYSwgZmFsc2UpO1xyXG5cdFx0Ly8gY3JlYXRlIHRleHR1cmVzXHJcblx0XHR0aGlzLmF2YWlsYWJsZSA9IG5ldyBBcnJheSh0aGlzLm51bUNodW5rcyk7XHJcblx0XHRmb3IgKGxldCBpPTA7IGk8dGhpcy5udW1DaHVua3M7IGkrKykge1xyXG5cdFx0XHR0aGlzLmF2YWlsYWJsZVtpXSA9IHtcclxuXHRcdFx0XHR0ZXh0dXJlOiBjcmVhdGVUZXh0dXJlKFxyXG5cdFx0XHRcdFx0dGhpcy5nbCxcclxuXHRcdFx0XHRcdHRoaXMuZm9ybWF0LFxyXG5cdFx0XHRcdFx0dGhpcy5jaHVua1NpemUsXHJcblx0XHRcdFx0XHR0aGlzLnR5cGUsXHJcblx0XHRcdFx0XHR0aGlzLmZpbHRlcixcclxuXHRcdFx0XHRcdHRoaXMud3JhcCxcclxuXHRcdFx0XHRcdHRoaXMuaW52ZXJ0WSxcclxuXHRcdFx0XHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSlcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdC8vIGNyZWF0ZSB1c2VkIGNodW5rIG1hcFxyXG5cdFx0dGhpcy51c2VkID0gbmV3IE1hcCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGVzdCB3aGV0aGVyIG9yIG5vdCBhIGtleSBpcyBoZWxkIGluIHRoZSBhcnJheS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHRlc3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGNvb3JkIGV4aXN0cyBpbiB0aGUgcHlyYW1pZC5cclxuXHQgKi9cclxuXHRoYXMoa2V5KSB7XHJcblx0XHRyZXR1cm4gdGhpcy51c2VkLmhhcyhrZXkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY2h1bmsgbWF0Y2hpbmcgdGhlIHByb3ZpZGVkIGtleS4gSWYgdGhlIGNodW5rIGRvZXMgbm90XHJcblx0ICogZXhpc3QsIHJldHVybnMgdW5kZWZpbmVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGNodW5rIHRvIHJldHVybi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjaHVuayBvYmplY3QuXHJcblx0ICovXHJcblx0Z2V0KGtleSkge1xyXG5cdFx0cmV0dXJuIHRoaXMudXNlZC5nZXQoa2V5KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgdGV4dHVyZSBkYXRhIGZvciB0aGUgcHJvdmlkZWQga2V5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHRleHR1cmUgZGF0YS5cclxuXHQgKiBAcGFyYW0ge0FycmF5QnVmZmVyfEhUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9IGRhdGEgLSBUaGUgdGV4dHVyZSBkYXRhLlxyXG5cdCAqL1xyXG5cdHNldChrZXksIGRhdGEpIHtcclxuXHRcdGlmICh0aGlzLmhhcyhrZXkpKSB7XHJcblx0XHRcdHRocm93IGBUaWxlIG9mIGNvb3JkICR7a2V5fSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgYXJyYXlgO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuYXZhaWxhYmxlLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHR0aHJvdyAnTm8gYXZhaWxhYmxlIHRleHR1cmUgY2h1bmtzIGluIGFycmF5JztcclxuXHRcdH1cclxuXHRcdC8vIGdldCBhbiBhdmFpbGFibGUgY2h1bmtcclxuXHRcdGNvbnN0IGNodW5rID0gdGhpcy5hdmFpbGFibGUucG9wKCk7XHJcblx0XHQvLyBidWZmZXIgdGhlIGRhdGFcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGNodW5rLnRleHR1cmUpO1xyXG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGhpcy5pbnZlcnRZKTtcclxuXHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5wcmVtdWx0aXBseUFscGhhKTtcclxuXHRcdGlmIChkYXRhLndpZHRoICYmIGRhdGEuaGVpZ2h0KSB7XHJcblx0XHRcdC8vIGNhbnZhcyB0eXBlXHJcblx0XHRcdGdsLnRleEltYWdlMkQoXHJcblx0XHRcdFx0Z2wuVEVYVFVSRV8yRCxcclxuXHRcdFx0XHQwLCAvLyBtaXAtbWFwIGxldmVsXHJcblx0XHRcdFx0Z2xbdGhpcy5mb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XHJcblx0XHRcdFx0Z2xbdGhpcy5mb3JtYXRdLFxyXG5cdFx0XHRcdGdsW3RoaXMudHlwZV0sXHJcblx0XHRcdFx0ZGF0YSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBhcnJheWJ1ZmZlciB0eXBlXHJcblx0XHRcdGdsLnRleEltYWdlMkQoXHJcblx0XHRcdFx0Z2wuVEVYVFVSRV8yRCxcclxuXHRcdFx0XHQwLCAvLyBtaXAtbWFwIGxldmVsXHJcblx0XHRcdFx0Z2xbdGhpcy5mb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XHJcblx0XHRcdFx0dGhpcy5jaHVua1NpemUsXHJcblx0XHRcdFx0dGhpcy5jaHVua1NpemUsXHJcblx0XHRcdFx0MCwgLy8gYm9yZGVyLCBtdXN0IGJlIDBcclxuXHRcdFx0XHRnbFt0aGlzLmZvcm1hdF0sXHJcblx0XHRcdFx0Z2xbdGhpcy50eXBlXSxcclxuXHRcdFx0XHRkYXRhKTtcclxuXHRcdH1cclxuXHRcdC8vIGFkZCB0byB1c2VkXHJcblx0XHR0aGlzLnVzZWQuc2V0KGtleSwgY2h1bmspO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRmxhZ3MgdGhlIGNodW5rIG1hdGNoaW5nIHRoZSBwcm92aWRlZCBrZXkgYXMgdW51c2VkIGluIHRoZSBhcnJheS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjaHVuayB0byBmcmVlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1RleHR1cmVBcnJheX0gVGhlIFRleHR1cmVBcnJheSBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRkZWxldGUoa2V5KSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzKGtleSkpIHtcclxuXHRcdFx0dGhyb3cgYFRpbGUgb2YgY29vcmQgJHtrZXl9IGRvZXMgbm90IGV4aXN0IGluIHRoZSBhcnJheWA7XHJcblx0XHR9XHJcblx0XHQvLyBnZXQgY2h1bmtcclxuXHRcdGNvbnN0IGNodW5rID0gdGhpcy51c2VkLmdldChrZXkpO1xyXG5cdFx0Ly8gcmVtb3ZlIGZyb20gdXNlZFxyXG5cdFx0dGhpcy51c2VkLmRlbGV0ZShrZXkpO1xyXG5cdFx0Ly8gYWRkIHRvIGF2YWlsYWJsZVxyXG5cdFx0dGhpcy5hdmFpbGFibGUucHVzaChjaHVuayk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEJpbmRzIHRoZSB0ZXh0dXJlIGFycmF5IHRvIHRoZSBwcm92aWRlZCB0ZXh0dXJlIHVuaXQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY2h1bmsgdG8gYmluZC5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gLSBUaGUgdGV4dHVyZSB1bml0IHRvIGFjdGl2YXRlLiBPcHRpb25hbC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUZXh0dXJlQXJyYXl9IFRoZSBUZXh0dXJlQXJyYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0YmluZChrZXksIGxvY2F0aW9uID0gMCkge1xyXG5cdFx0aWYgKCF0aGlzLmhhcyhrZXkpKSB7XHJcblx0XHRcdHRocm93IGBUaWxlIG9mIGNvb3JkICR7a2V5fSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgYXJyYXlgO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnVzZWQuZ2V0KGtleSk7XHJcblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsW2BURVhUVVJFJHtsb2NhdGlvbn1gXSk7XHJcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBjaHVuay50ZXh0dXJlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVW5iaW5kcyB0aGUgdGV4dHVyZSBhcnJheS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtUZXh0dXJlQXJyYXl9IFRoZSBUZXh0dXJlQXJyYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0dW5iaW5kKCkge1xyXG5cdFx0Ly8gbm8tb3BcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlQXJyYXk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gaW5kZXggYnVmZmVyLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhCdWZmZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0YW50aWF0ZXMgYW4gSW5kZXhCdWZmZXIgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQuXHJcblx0ICogQHBhcmFtIHtXZWJHTEJ1ZmZlcnxBcnJheUJ1ZmZlcnxudW1iZXJ9IGFyZyAtIFRoZSBpbmRleCBkYXRhIHRvIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50eXBlIC0gVGhlIGJ1ZmZlciBjb21wb25lbnQgdHlwZS5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tb2RlIC0gVGhlIGRyYXcgbW9kZSAvIHByaW1pdGl2ZSB0eXBlLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ5dGVPZmZzZXQgLSBUaGUgYnl0ZSBvZmZzZXQgaW50byB0aGUgZHJhd24gYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNvdW50IC0gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyB0byBkcmF3LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGdsLCBhcmcsIG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0dGhpcy5nbCA9IGdsO1xyXG5cdFx0dGhpcy50eXBlID0gZGVmYXVsdFRvKG9wdGlvbnMudHlwZSwgJ1VOU0lHTkVEX1NIT1JUJyk7XHJcblx0XHR0aGlzLm1vZGUgPSBkZWZhdWx0VG8ob3B0aW9ucy5tb2RlLCAnVFJJQU5HTEVTJyk7XHJcblx0XHR0aGlzLmNvdW50ID0gZGVmYXVsdFRvKG9wdGlvbnMuY291bnQsIDApO1xyXG5cdFx0dGhpcy5ieXRlT2Zmc2V0ID0gZGVmYXVsdFRvKG9wdGlvbnMuYnl0ZU9mZnNldCwgMCk7XHJcblx0XHQvLyBjcmVhdGUgYnVmZmVyXHJcblx0XHRpZiAoYXJnIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpIHtcclxuXHRcdFx0dGhpcy5idWZmZXIgPSBhcmc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0XHRpZiAoYXJnKSB7XHJcblx0XHRcdFx0Ly8gYnVmZmVyIHRoZSBkYXRhXHJcblx0XHRcdFx0dGhpcy5idWZmZXJEYXRhKGFyZyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwbG9hZCBpbmRleCBkYXRhIHRvIHRoZSBHUFUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5QnVmZmVyfG51bWJlcn0gYXJnIC0gVGhlIGFycmF5IG9mIGRhdGEgdG8gYnVmZmVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge0luZGV4QnVmZmVyfSBUaGUgaW5kZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGJ1ZmZlckRhdGEoYXJnKSB7XHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XHJcblx0XHRnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhcmcsIGdsLlNUQVRJQ19EUkFXKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwbG9hZCBwYXJ0aWFsIGluZGV4IGRhdGEgdG8gdGhlIEdQVS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5IC0gVGhlIGFycmF5IG9mIGRhdGEgdG8gYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IGF0IHdoaWNoIHRvIGJ1ZmZlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtJbmRleEJ1ZmZlcn0gVGhlIGluZGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRidWZmZXJTdWJEYXRhKGFycmF5LCBieXRlT2Zmc2V0ID0gMCkge1xyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG5cdFx0Z2wuYnVmZmVyU3ViRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnl0ZU9mZnNldCwgYXJyYXkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlIHRoZSBkcmF3IGNvbW1hbmQgZm9yIHRoZSBib3VuZCBidWZmZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7SW5kZXhCdWZmZXJ9IFRoZSBpbmRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZHJhdygpIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuXHRcdGdsLmRyYXdFbGVtZW50cyhnbFt0aGlzLm1vZGVdLCB0aGlzLmNvdW50LCBnbFt0aGlzLnR5cGVdLCB0aGlzLmJ5dGVPZmZzZXQpO1xyXG5cdFx0Ly8gbm8gbmVlZCB0byB1bmJpbmRcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmRleEJ1ZmZlcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xyXG5jb25zdCBmb3JJbiA9IHJlcXVpcmUoJ2xvZGFzaC9mb3JJbicpO1xyXG5cclxuLy8gQ29uc3RhbnRzXHJcblxyXG5jb25zdCBCWVRFU19QRVJfVFlQRSA9IHtcclxuXHRCWVRFOiAxLFxyXG5cdFVOU0lHTkVEX0JZVEU6IDEsXHJcblx0U0hPUlQ6IDIsXHJcblx0VU5TSUdORURfU0hPUlQ6IDIsXHJcblx0RklYRUQ6IDQsXHJcblx0RkxPQVQ6IDRcclxufTtcclxuXHJcbi8vIFByaXZhdGUgTWV0aG9kc1xyXG5cclxuY29uc3QgY2FsY0NodW5rQnl0ZVNpemUgPSBmdW5jdGlvbihwb2ludGVycywgY2h1bmtTaXplKSB7XHJcblx0bGV0IGJ5dGVTaXplID0gMDtcclxuXHRwb2ludGVycy5mb3JFYWNoKHBvaW50ZXIgPT4ge1xyXG5cdFx0Ynl0ZVNpemUgKz0gQllURVNfUEVSX1RZUEVbcG9pbnRlci50eXBlXSAqIHBvaW50ZXIuc2l6ZSAqIGNodW5rU2l6ZTtcclxuXHR9KTtcclxuXHRyZXR1cm4gYnl0ZVNpemU7XHJcbn07XHJcblxyXG5jb25zdCBjYWxjQnl0ZU9mZnNldHMgPSBmdW5jdGlvbihjaHVuaywgcG9pbnRlcnMsIGNodW5rQnl0ZU9mZnNldCkge1xyXG5cdGxldCBieXRlT2Zmc2V0ID0gMDtcclxuXHRwb2ludGVycy5mb3JFYWNoKChwb2ludGVyLCBsb2NhdGlvbikgPT4ge1xyXG5cdFx0Y2h1bmsuYnl0ZU9mZnNldHNbbG9jYXRpb25dID0gY2h1bmtCeXRlT2Zmc2V0ICsgYnl0ZU9mZnNldDtcclxuXHRcdGJ5dGVPZmZzZXQgKz0gQllURVNfUEVSX1RZUEVbcG9pbnRlci50eXBlXSAqIHBvaW50ZXIuc2l6ZTtcclxuXHR9KTtcclxufTtcclxuXHJcbmNvbnN0IGNhbGNTdHJpZGUgPSBmdW5jdGlvbihwb2ludGVycykge1xyXG5cdGxldCBzdHJpZGUgPSAwO1xyXG5cdHBvaW50ZXJzLmZvckVhY2gocG9pbnRlciA9PiB7XHJcblx0XHRzdHJpZGUgKz0gcG9pbnRlci5zaXplO1xyXG5cdH0pO1xyXG5cdHJldHVybiBzdHJpZGU7XHJcbn07XHJcblxyXG5jb25zdCBwYXJzZUF0dHJpYnV0ZVBvaW50ZXJzID0gZnVuY3Rpb24ocG9pbnRlcnMpIHtcclxuXHRjb25zdCBhdHRyaWJ1dGVQb2ludGVycyA9IG5ldyBNYXAoKTtcclxuXHRsZXQgYnl0ZU9mZnNldCA9IDA7XHJcblx0Ly8gY29udmVydCB0byBtYXBcclxuXHRmb3JJbihwb2ludGVycywgKHBvaW50ZXIsIGluZGV4KSA9PiB7XHJcblx0XHRhdHRyaWJ1dGVQb2ludGVycy5zZXQoaW5kZXgsIHtcclxuXHRcdFx0dHlwZTogcG9pbnRlci50eXBlLFxyXG5cdFx0XHRzaXplOiBwb2ludGVyLnNpemUsXHJcblx0XHRcdGJ5dGVPZmZzZXQ6IGJ5dGVPZmZzZXQsXHJcblx0XHRcdGJ5dGVTdHJpZGU6IDBcclxuXHRcdH0pO1xyXG5cdFx0Ynl0ZU9mZnNldCArPSBCWVRFU19QRVJfVFlQRVtwb2ludGVyLnR5cGVdICogcG9pbnRlci5zaXplO1xyXG5cdH0pO1xyXG5cdC8vIGFkZCBieXRlIHN0cmlkZVxyXG5cdGF0dHJpYnV0ZVBvaW50ZXJzLmZvckVhY2gocG9pbnRlciA9PiB7XHJcblx0XHRwb2ludGVyLmJ5dGVTdHJpZGUgPSBieXRlT2Zmc2V0O1xyXG5cdH0pO1xyXG5cdHJldHVybiBhdHRyaWJ1dGVQb2ludGVycztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB2ZXJ0ZXggYXRsYXMuXHJcbiAqL1xyXG5jbGFzcyBWZXJ0ZXhBdGxhcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBWZXJ0ZXhBdGxhcyBvYmplY3QuXHJcblx0ICogTk9URTogQXNzdW1lcyBpbnRlcmxlYXZlZCB2ZXJ0ZXggZm9ybWF0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJzIC0gVGhlIHZlcnRleCBhdHRyaWJ1dGUgcG9pbnRlcnMuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgdmVydGV4IGF0bGFzIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2h1bmtTaXplIC0gVGhlIHNpemUgb2YgYSBzaW5nbGUgY2h1bmssIGluIHZlcnRpY2VzLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm51bUNodW5rcyAtIFRoZSBzaXplIG9mIHRoZSBhdGxhcywgaW4gdGlsZXMuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZ2wsIHBvaW50ZXJzLCBvcHRpb25zID0ge30pIHtcclxuXHRcdC8vIGdldCBjb250ZXh0XHJcblx0XHR0aGlzLmdsID0gZ2w7XHJcblx0XHQvLyBnZXQgdGhlIGV4dGVuc2lvbiBmb3IgaGFyZHdhcmUgaW5zdGFuY2luZ1xyXG5cdFx0dGhpcy5leHQgPSBnbC5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcclxuXHRcdGlmICghdGhpcy5leHQpIHtcclxuXHRcdFx0dGhyb3cgJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMgV2ViR0wgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQnO1xyXG5cdFx0fVxyXG5cdFx0Ly8gc2V0IGF0bGFzIHByb3BlcnRpZXNcclxuXHRcdHRoaXMuY2h1bmtTaXplID0gZGVmYXVsdFRvKG9wdGlvbnMuY2h1bmtTaXplLCAxMjggKiAxMjgpO1xyXG5cdFx0dGhpcy5udW1DaHVua3MgPSBkZWZhdWx0VG8ob3B0aW9ucy5udW1DaHVua3MsIDI1Nik7XHJcblx0XHQvLyBzZXQgdGhlIHBvaW50ZXJzIG9mIHRoZSBhdGxhc1xyXG5cdFx0aWYgKCFwb2ludGVycykge1xyXG5cdFx0XHR0aHJvdyAnTm8gYXR0cmlidXRlIHBvaW50ZXJzIHByb3ZpZGVkJztcclxuXHRcdH1cclxuXHRcdHRoaXMucG9pbnRlcnMgPSBwYXJzZUF0dHJpYnV0ZVBvaW50ZXJzKHBvaW50ZXJzKTtcclxuXHRcdC8vIGNhbGMgc3RyaWRlIG9mIHRoZSBhdGxhc1xyXG5cdFx0dGhpcy5zdHJpZGUgPSBjYWxjU3RyaWRlKHRoaXMucG9pbnRlcnMpO1xyXG5cdFx0Ly8gY3JlYXRlIGF2YWlsYWJsZSBjaHVua3NcclxuXHRcdHRoaXMuYXZhaWxhYmxlID0gbmV3IEFycmF5KHRoaXMubnVtQ2h1bmtzKTtcclxuXHRcdC8vIGNhbGMgdGhlIGNodW5rIGJ5dGUgc2l6ZVxyXG5cdFx0Y29uc3QgY2h1bmtCeXRlU2l6ZSA9IGNhbGNDaHVua0J5dGVTaXplKFxyXG5cdFx0XHR0aGlzLnBvaW50ZXJzLFxyXG5cdFx0XHR0aGlzLmNodW5rU2l6ZSk7XHJcblx0XHQvLyBmb3IgZWFjaCBjaHVua1xyXG5cdFx0Zm9yIChsZXQgaT0wOyBpPHRoaXMubnVtQ2h1bmtzOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgY2h1bmtPZmZzZXQgPSBpICogdGhpcy5jaHVua1NpemU7XHJcblx0XHRcdGNvbnN0IGNodW5rQnl0ZU9mZnNldCA9IGkgKiBjaHVua0J5dGVTaXplO1xyXG5cdFx0XHRjb25zdCBhdmFpbGFibGUgPSB7XHJcblx0XHRcdFx0Y291bnQ6IDAsXHJcblx0XHRcdFx0Y2h1bmtPZmZzZXQ6IGNodW5rT2Zmc2V0LFxyXG5cdFx0XHRcdGNodW5rQnl0ZU9mZnNldDogY2h1bmtCeXRlT2Zmc2V0LFxyXG5cdFx0XHRcdGJ5dGVPZmZzZXRzOiB7fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHQvLyBjYWxjdWxhdGUgaW50ZXJsZWF2ZWQgb2Zmc2V0cyAvIHN0cmlkZSwgdGhpcyBvbmx5IG5lZWRzXHJcblx0XHRcdC8vIHRvIGJlIGRvbmUgb25jZVxyXG5cdFx0XHRjYWxjQnl0ZU9mZnNldHMoXHJcblx0XHRcdFx0YXZhaWxhYmxlLFxyXG5cdFx0XHRcdHRoaXMucG9pbnRlcnMsXHJcblx0XHRcdFx0Y2h1bmtCeXRlT2Zmc2V0KTtcclxuXHRcdFx0Ly8gYWRkIGNodW5rXHJcblx0XHRcdHRoaXMuYXZhaWxhYmxlW2ldID0gYXZhaWxhYmxlO1xyXG5cdFx0fVxyXG5cdFx0Ly8gY3JlYXRlIHVzZWQgY2h1bmsgbWFwXHJcblx0XHR0aGlzLnVzZWQgPSBuZXcgTWFwKCk7XHJcblx0XHQvLyBjcmVhdGUgYnVmZmVyXHJcblx0XHR0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Ly8gY2FsYyB0b3RhbCBzaXplIG9mIHRoZSBidWZmZXJcclxuXHRcdGNvbnN0IGJ5dGVTaXplID0gY2h1bmtCeXRlU2l6ZSAqIHRoaXMubnVtQ2h1bmtzO1xyXG5cdFx0Ly8gYnVmZmVyIHRoZSBkYXRhXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGJ5dGVTaXplLCBnbC5EWU5BTUlDX0RSQVcpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGVzdCB3aGV0aGVyIG9yIG5vdCBhIGtleSBpcyBoZWxkIGluIHRoZSBhdGxhcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHRlc3QuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGNvb3JkIGV4aXN0cyBpbiB0aGUgcHlyYW1pZC5cclxuXHQgKi9cclxuXHRoYXMoa2V5KSB7XHJcblx0XHRyZXR1cm4gdGhpcy51c2VkLmhhcyhrZXkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY2h1bmsgbWF0Y2hpbmcgdGhlIHByb3ZpZGVkIGtleS4gSWYgdGhlIGNodW5rIGRvZXMgbm90XHJcblx0ICogZXhpc3QsIHJldHVybnMgdW5kZWZpbmVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGNodW5rIHRvIHJldHVybi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjaHVuayBvYmplY3QuXHJcblx0ICovXHJcblx0Z2V0KGtleSkge1xyXG5cdFx0cmV0dXJuIHRoaXMudXNlZC5nZXQoa2V5KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgdmVydGV4IGRhdGEgZm9yIHRoZSBwcm92aWRlZCBrZXkuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgdmVydGV4IGRhdGEuXHJcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSAtIFRoZSB2ZXJ0ZXggZGF0YS5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBUaGUgY291bnQgb2YgdmVydGljZXMgYWRkZWQuXHJcblx0ICovXHJcblx0c2V0KGtleSwgZGF0YSwgY291bnQpIHtcclxuXHRcdGlmICh0aGlzLmhhcyhrZXkpKSB7XHJcblx0XHRcdHRocm93IGBUaWxlIG9mIGNvb3JkICR7a2V5fSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgYXRsYXNgO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuYXZhaWxhYmxlLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHR0aHJvdyAnTm8gYXZhaWxhYmxlIHZlcnRleCBjaHVua3MgaW4gYXRsYXMnO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvdW50ID4gdGhpcy5jaHVua1NpemUpIHtcclxuXHRcdFx0dGhyb3cgYERhdGEgY291bnQgb2YgJHtjb3VudH0gaXMgZ3JlYXRlciB0aGF0IGFsbG9jYXRlZCBzaXplIG9mICR7dGhpcy5jaHVua1NpemV9YDtcclxuXHRcdH1cclxuXHRcdC8vIGdldCBhbiBhdmFpbGFibGUgY2h1bmtcclxuXHRcdGNvbnN0IGNodW5rID0gdGhpcy5hdmFpbGFibGUucG9wKCk7XHJcblx0XHQvLyB1cGRhdGUgY2h1bmsgY291bnRcclxuXHRcdGNodW5rLmNvdW50ID0gY291bnQ7XHJcblx0XHQvLyBvbmx5IGFjdHVhbGx5IGJ1ZmZlciB0aGUgZGF0YSBpZiB0aGVyZSBpcyAgZGF0YVxyXG5cdFx0aWYgKGNvdW50ID4gMCkge1xyXG5cdFx0XHQvLyBidWZmZXIgdGhlIGRhdGFcclxuXHRcdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgY2h1bmsuY2h1bmtCeXRlT2Zmc2V0LCBkYXRhKTtcclxuXHRcdH1cclxuXHRcdC8vIGFkZCB0byB1c2VkXHJcblx0XHR0aGlzLnVzZWQuc2V0KGtleSwgY2h1bmspO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRmxhZ3MgdGhlIGNodW5rIG1hdGNoaW5nIHRoZSBwcm92aWRlZCBrZXkgYXMgdW51c2VkIGluIHRoZSBhdGxhcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjaHVuayB0byBmcmVlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1ZlcnRleEF0bGFzfSBUaGUgVmVydGV4QXRsYXMgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZGVsZXRlKGtleSkge1xyXG5cdFx0aWYgKCF0aGlzLmhhcyhrZXkpKSB7XHJcblx0XHRcdHRocm93IGBUaWxlIG9mIGNvb3JkICR7a2V5fSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgYXRsYXNgO1xyXG5cdFx0fVxyXG5cdFx0Ly8gZ2V0IGNodW5rXHJcblx0XHRjb25zdCBjaHVuayA9IHRoaXMudXNlZC5nZXQoa2V5KTtcclxuXHRcdC8vIHJlbW92ZSBmcm9tIHVzZWRcclxuXHRcdHRoaXMudXNlZC5kZWxldGUoa2V5KTtcclxuXHRcdC8vIGFkZCB0byBhdmFpbGFibGVcclxuXHRcdHRoaXMuYXZhaWxhYmxlLnB1c2goY2h1bmspO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBCaW5kcyB0aGUgdmVydGV4IGF0bGFzIGFuZCBhY3RpdmF0ZXMgdGhlIGF0dHJpYnV0ZSBhcnJheXMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VmVydGV4QXRsYXN9IFRoZSBWZXJ0ZXhBdGxhcyBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRiaW5kKCkge1xyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Ly8gYmluZCB0aGUgYnVmZmVyXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG5cdFx0Ly8gZm9yIGVhY2ggYXR0cmlidXRlIHBvaW50ZXJcclxuXHRcdHRoaXMucG9pbnRlcnMuZm9yRWFjaCgocG9pbnRlciwgaW5kZXgpID0+IHtcclxuXHRcdFx0Ly8gZW5hYmxlIGF0dHJpYnV0ZSBpbmRleFxyXG5cdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XHJcblx0XHRcdC8vIHNldCBhdHRyaWJ1dGUgcG9pbnRlclxyXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG5cdFx0XHRcdGluZGV4LFxyXG5cdFx0XHRcdHBvaW50ZXIuc2l6ZSxcclxuXHRcdFx0XHRnbFtwb2ludGVyLnR5cGVdLFxyXG5cdFx0XHRcdGZhbHNlLFxyXG5cdFx0XHRcdHBvaW50ZXIuYnl0ZVN0cmlkZSxcclxuXHRcdFx0XHRwb2ludGVyLmJ5dGVPZmZzZXQpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEJpbmRzIHRoZSB2ZXJ0ZXggYXRsYXMgYW5kIGFjdGl2YXRlcyB0aGUgYXR0cmlidXRlIGFycmF5cyBmb3JcclxuXHQgKiBpbnN0YW5jaW5nLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1ZlcnRleEF0bGFzfSBUaGUgVmVydGV4QXRsYXMgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0YmluZEluc3RhbmNlZCgpIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGNvbnN0IGV4dCA9IHRoaXMuZXh0O1xyXG5cdFx0Ly8gYmluZCB0aGUgYnVmZmVyXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG5cdFx0Ly8gZm9yIGVhY2ggYXR0cmlidXRlIHBvaW50ZXJcclxuXHRcdHRoaXMucG9pbnRlcnMuZm9yRWFjaCgocG9pbnRlciwgaW5kZXgpID0+IHtcclxuXHRcdFx0Ly8gZW5hYmxlIGF0dHJpYnV0ZSBpbmRleFxyXG5cdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XHJcblx0XHRcdC8vIGVuYWJsZSBpbnN0YW5jaW5nIHRoaXMgYXR0cmlidXRlXHJcblx0XHRcdGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaW5kZXgsIDEpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuYmluZHMgdGhlIHZlcnRleCBhdGxhcyBhbmQgZGlzYWJsZXMgdGhlIHZlcnRleCBhcnJheXMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VmVydGV4QXRsYXN9IFRoZSBWZXJ0ZXhBdGxhcyBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHR1bmJpbmQoKSB7XHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblx0XHQvLyBmb3IgZWFjaCBhdHRyaWJ1dGUgcG9pbnRlclxyXG5cdFx0dGhpcy5wb2ludGVycy5mb3JFYWNoKChwb2ludGVyLCBpbmRleCkgPT4ge1xyXG5cdFx0XHQvLyBkaXNhYmxlIGF0dHJpYnV0ZSBpbmRleFxyXG5cdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuYmluZHMgdGhlIHZlcnRleCBhdGxhcyBhbmQgZGlzYWJsZXMgdGhlIHZlcnRleCBhcnJheXMgZm9yXHJcblx0ICogaW5zdGFuY2luZy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhBdGxhc30gVGhlIFZlcnRleEF0bGFzIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHVuYmluZEluc3RhbmNlZCgpIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGNvbnN0IGV4dCA9IHRoaXMuZXh0O1xyXG5cdFx0Ly8gZm9yIGVhY2ggYXR0cmlidXRlIHBvaW50ZXJcclxuXHRcdHRoaXMucG9pbnRlcnMuZm9yRWFjaCgocG9pbnRlciwgaW5kZXgpID0+IHtcclxuXHRcdFx0Ly8gZGlzYWJsZSBhdHRyaWJ1dGUgaW5kZXhcclxuXHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcclxuXHRcdFx0Ly8gZGlzYWJsZSBpbnN0YW5jaW5nIHRoaXMgYXR0cmlidXRlXHJcblx0XHRcdGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaW5kZXgsIDApO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4ZWN1dGUgdGhlIGRyYXcgY29tbWFuZCBhdCB0aGUgY29ycmVjdCBvZmZzZXQgYW5kIGNvdW50IHdpdGhpbiB0aGVcclxuXHQgKiBhdGxhcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjaHVuayB0byBkcmF3LlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gVGhlIHByaW1pdGl2ZSBkcmF3aW5nIG1vZGUgdG8gdXNlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGludG8gdGhlIGNodW5rLiBPcHRpb25hbC5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBUaGUgY291bnQgb2YgcHJpbWl0aXZlcyB0byByZW5kZXIuIE9wdGlvbmFsLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0ZHJhdyhrZXksIG1vZGUsIG9mZnNldCA9IDAsIGNvdW50ID0gMCkge1xyXG5cdFx0aWYgKCF0aGlzLmhhcyhrZXkpKSB7XHJcblx0XHRcdHRocm93IGBUaWxlIG9mIGNvb3JkICR7a2V5fSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgYXRsYXNgO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnVzZWQuZ2V0KGtleSk7XHJcblx0XHQvLyBvbmx5IGFjdHVhbGx5IGRyYXcgaWYgY291bnQgPiAwXHJcblx0XHRpZiAoY2h1bmsuY291bnQgPiAwKSB7XHJcblx0XHRcdC8vIGRyYXcgdGhlIGNodW5rXHJcblx0XHRcdGdsLmRyYXdBcnJheXMoZ2xbbW9kZV0sIGNodW5rLmNodW5rT2Zmc2V0ICsgb2Zmc2V0LCBjb3VudCA/IGNvdW50IDogY2h1bmsuY291bnQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZSB0aGUgaW5zdGFuY2VkIGRyYXcgY29tbWFuZCBhdCB0aGUgY29ycmVjdCBvZmZzZXQgYW5kIGNvdW50IHdpdGhpblxyXG5cdCAqIHRoZSBhdGxhcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjaHVuayB0byBkcmF3LlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gVGhlIHByaW1pdGl2ZSBkcmF3aW5nIG1vZGUgdG8gdXNlLlxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBjb3VudCBvZiBwcmltaXRpdmVzIHRvIHJlbmRlci4gT3B0aW9uYWwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VmVydGV4QnVmZmVyfSBUaGUgdmVydGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRkcmF3SW5zdGFuY2VkKGtleSwgbW9kZSwgY291bnQpIHtcclxuXHRcdGlmICghdGhpcy5oYXMoa2V5KSkge1xyXG5cdFx0XHR0aHJvdyBgVGlsZSBvZiBjb29yZCAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gdGhlIGF0bGFzYDtcclxuXHRcdH1cclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGNvbnN0IGV4dCA9IHRoaXMuZXh0O1xyXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnVzZWQuZ2V0KGtleSk7XHJcblx0XHQvLyBmb3IgZWFjaCBhdHRyaWJ1dGUgcG9pbnRlclxyXG5cdFx0dGhpcy5wb2ludGVycy5mb3JFYWNoKChwb2ludGVyLCBpbmRleCkgPT4ge1xyXG5cdFx0XHQvLyBzZXQgYXR0cmlidXRlIHBvaW50ZXJcclxuXHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuXHRcdFx0XHRpbmRleCxcclxuXHRcdFx0XHRwb2ludGVyLnNpemUsXHJcblx0XHRcdFx0Z2xbcG9pbnRlci50eXBlXSxcclxuXHRcdFx0XHRmYWxzZSxcclxuXHRcdFx0XHRwb2ludGVyLmJ5dGVTdHJpZGUsXHJcblx0XHRcdFx0Y2h1bmsuYnl0ZU9mZnNldHNbaW5kZXhdKTtcclxuXHRcdH0pO1xyXG5cdFx0Ly8gb25seSBhY3R1YWxseSBkcmF3IGlmIGNvdW50ID4gMFxyXG5cdFx0aWYgKGNodW5rLmNvdW50ID4gMCkge1xyXG5cdFx0XHQvLyBkcmF3IHRoZSBib3VuZCB2ZXJ0ZXggYXJyYXlcclxuXHRcdFx0ZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShnbFttb2RlXSwgMCwgY291bnQsIGNodW5rLmNvdW50KTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmVydGV4QXRsYXM7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcclxuY29uc3QgZm9ySW4gPSByZXF1aXJlKCdsb2Rhc2gvZm9ySW4nKTtcclxuXHJcbi8vIENvbnN0YW50c1xyXG5cclxuY29uc3QgQllURVNfUEVSX1RZUEUgPSB7XHJcblx0QllURTogMSxcclxuXHRVTlNJR05FRF9CWVRFOiAxLFxyXG5cdFNIT1JUOiAyLFxyXG5cdFVOU0lHTkVEX1NIT1JUOiAyLFxyXG5cdEZJWEVEOiA0LFxyXG5cdEZMT0FUOiA0XHJcbn07XHJcblxyXG4vLyBQcml2YXRlIE1ldGhvZHNcclxuXHJcbmNvbnN0IGdldFN0cmlkZSA9IGZ1bmN0aW9uKHBvaW50ZXJzKSB7XHJcblx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXR0cmlidXRlIHBvaW50ZXIgYXNzaWduZWQgdG8gdGhpcyBidWZmZXIsXHJcblx0Ly8gdGhlcmUgaXMgbm8gbmVlZCBmb3Igc3RyaWRlLCBzZXQgdG8gZGVmYXVsdCBvZiAwXHJcblx0aWYgKHBvaW50ZXJzLnNpemUgPT09IDEpIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHRsZXQgbWF4Qnl0ZU9mZnNldCA9IDA7XHJcblx0bGV0IGJ5dGVTaXplU3VtID0gMDtcclxuXHRsZXQgYnl0ZVN0cmlkZSA9IDA7XHJcblx0cG9pbnRlcnMuZm9yRWFjaChwb2ludGVyID0+IHtcclxuXHRcdGNvbnN0IGJ5dGVPZmZzZXQgPSBwb2ludGVyLmJ5dGVPZmZzZXQ7XHJcblx0XHRjb25zdCBzaXplID0gcG9pbnRlci5zaXplO1xyXG5cdFx0Y29uc3QgdHlwZSA9IHBvaW50ZXIudHlwZTtcclxuXHRcdC8vIHRyYWNrIHRoZSBzdW0gb2YgZWFjaCBhdHRyaWJ1dGUgc2l6ZVxyXG5cdFx0Ynl0ZVNpemVTdW0gKz0gc2l6ZSAqIEJZVEVTX1BFUl9UWVBFW3R5cGVdO1xyXG5cdFx0Ly8gdHJhY2sgdGhlIGxhcmdlc3Qgb2Zmc2V0IHRvIGRldGVybWluZSB0aGUgYnl0ZSBzdHJpZGUgb2YgdGhlIGJ1ZmZlclxyXG5cdFx0aWYgKGJ5dGVPZmZzZXQgPiBtYXhCeXRlT2Zmc2V0KSB7XHJcblx0XHRcdG1heEJ5dGVPZmZzZXQgPSBieXRlT2Zmc2V0O1xyXG5cdFx0XHRieXRlU3RyaWRlID0gYnl0ZU9mZnNldCArIChzaXplICogQllURVNfUEVSX1RZUEVbdHlwZV0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdC8vIGNoZWNrIGlmIHRoZSBtYXggYnl0ZSBvZmZzZXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0aGUgc3VtXHJcblx0Ly8gb2YgdGhlIHNpemVzLiBJZiBzbyB0aGlzIGJ1ZmZlciBpcyBub3QgaW50ZXJsZWF2ZWQgYW5kIGRvZXMgbm90IG5lZWRcclxuXHQvLyBhIHN0cmlkZS5cclxuXHRpZiAobWF4Qnl0ZU9mZnNldCA+PSBieXRlU2l6ZVN1bSkge1xyXG5cdFx0Ly8gVE9ETzogdGVzdCB3aGF0IHN0cmlkZSA9PT0gMCBkb2VzIGZvciBhbiBpbnRlcmxlYXZlZCBidWZmZXIgb2ZcclxuXHRcdC8vIGxlbmd0aCA9PT0gMS5cclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHRyZXR1cm4gYnl0ZVN0cmlkZTtcclxufTtcclxuXHJcbmNvbnN0IGdldEF0dHJpYnV0ZVBvaW50ZXJzID0gZnVuY3Rpb24oYXR0cmlidXRlUG9pbnRlcnMpIHtcclxuXHQvLyBwYXJzZSBwb2ludGVycyB0byBlbnN1cmUgdGhleSBhcmUgdmFsaWRcclxuXHRjb25zdCBwb2ludGVycyA9IG5ldyBNYXAoKTtcclxuXHRmb3JJbihhdHRyaWJ1dGVQb2ludGVycywgKHBvaW50ZXIsIGtleSkgPT4ge1xyXG5cdFx0Ly8gcGFyc2UgaW5kZXggZnJvbSBzdHJpbmcgdG8gaW50XHJcblx0XHRjb25zdCBpbmRleCA9IHBhcnNlSW50KGtleSwgMTApO1xyXG5cdFx0Ly8gZW5zdXJlIGJ5dGUgb2Zmc2V0IGV4aXN0c1xyXG5cdFx0cG9pbnRlci5ieXRlT2Zmc2V0ID0gZGVmYXVsdFRvKHBvaW50ZXIuYnl0ZU9mZnNldCwgMCk7XHJcblx0XHQvLyBhZGQgdG8gbWFwXHJcblx0XHRwb2ludGVycy5zZXQoaW5kZXgsIHBvaW50ZXIpO1xyXG5cdH0pO1xyXG5cdHJldHVybiBwb2ludGVycztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB2ZXJ0ZXggYnVmZmVyLlxyXG4gKi9cclxuY2xhc3MgVmVydGV4QnVmZmVyIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW5zdGFudGlhdGVzIGFuIFZlcnRleEJ1ZmZlciBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgV2ViR0wgY29udGV4dC5cclxuXHQgKiBAcGFyYW0ge1dlYkdMQnVmZmVyfEFycmF5QnVmZmVyfG51bWJlcn0gYXJnIC0gVGhlIGJ1ZmZlciBvciBsZW5ndGggb2YgdGhlIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlcnMgLSBUaGUgYXJyYXkgcG9pbnRlciBtYXAuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgdmVydGV4IGJ1ZmZlciBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1vZGUgLSBUaGUgZHJhdyBtb2RlIC8gcHJpbWl0aXZlIHR5cGUuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaW5kZXhPZmZzZXQgLSBUaGUgaW5kZXggb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jb3VudCAtIFRoZSBudW1iZXIgb2YgaW5kaWNlcyB0byBkcmF3LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGdsLCBhcmcsIHBvaW50ZXJzID0ge30sIG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0dGhpcy5nbCA9IGdsO1xyXG5cdFx0dGhpcy5tb2RlID0gZGVmYXVsdFRvKG9wdGlvbnMubW9kZSwgJ1RSSUFOR0xFUycpO1xyXG5cdFx0dGhpcy5jb3VudCA9IGRlZmF1bHRUbyhvcHRpb25zLmNvdW50LCAwKTtcclxuXHRcdHRoaXMuaW5kZXhPZmZzZXQgPSBkZWZhdWx0VG8ob3B0aW9ucy5pbmRleE9mZnNldCwgMCk7XHJcblx0XHQvLyBmaXJzdCwgc2V0IHRoZSBhdHRyaWJ1dGUgcG9pbnRlcnNcclxuXHRcdHRoaXMucG9pbnRlcnMgPSBnZXRBdHRyaWJ1dGVQb2ludGVycyhwb2ludGVycyk7XHJcblx0XHQvLyBzZXQgdGhlIGJ5dGUgc3RyaWRlXHJcblx0XHR0aGlzLmJ5dGVTdHJpZGUgPSBnZXRTdHJpZGUodGhpcy5wb2ludGVycyk7XHJcblx0XHQvLyBjcmVhdGUgYnVmZmVyXHJcblx0XHRpZiAoYXJnIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpIHtcclxuXHRcdFx0dGhpcy5idWZmZXIgPSBhcmc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0XHRpZiAoYXJnKSB7XHJcblx0XHRcdFx0Ly8gYnVmZmVyIHRoZSBkYXRhXHJcblx0XHRcdFx0dGhpcy5idWZmZXJEYXRhKGFyZyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwbG9hZCB2ZXJ0ZXggZGF0YSB0byB0aGUgR1BVLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxudW1iZXJ9IGFyZyAtIFRoZSBhcnJheSBvZiBkYXRhIHRvIGJ1ZmZlciwgb3Igc2l6ZSBvZiB0aGUgYnVmZmVyIGluIGJ5dGVzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybnMge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXHJcblx0ICovXHJcblx0YnVmZmVyRGF0YShhcmcpIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XHJcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJnLCBnbC5TVEFUSUNfRFJBVyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwbG9hZCBwYXJ0aWFsIHZlcnRleCBkYXRhIHRvIHRoZSBHUFUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheSAtIFRoZSBhcnJheSBvZiBkYXRhIHRvIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBieXRlIG9mZnNldCBhdCB3aGljaCB0byBidWZmZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VmVydGV4QnVmZmVyfSBUaGUgdmVydGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRidWZmZXJTdWJEYXRhKGFycmF5LCBieXRlT2Zmc2V0ID0gMCkge1xyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuXHRcdGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBieXRlT2Zmc2V0LCBhcnJheSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEJpbmRzIHRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhCdWZmZXJ9IFRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdGJpbmQoKSB7XHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblx0XHQvLyBiaW5kIGJ1ZmZlclxyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuXHRcdC8vIGZvciBlYWNoIGF0dHJpYnV0ZSBwb2ludGVyXHJcblx0XHR0aGlzLnBvaW50ZXJzLmZvckVhY2goKHBvaW50ZXIsIGluZGV4KSA9PiB7XHJcblx0XHRcdC8vIHNldCBhdHRyaWJ1dGUgcG9pbnRlclxyXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG5cdFx0XHRcdGluZGV4LFxyXG5cdFx0XHRcdHBvaW50ZXIuc2l6ZSxcclxuXHRcdFx0XHRnbFtwb2ludGVyLnR5cGVdLFxyXG5cdFx0XHRcdGZhbHNlLFxyXG5cdFx0XHRcdHRoaXMuYnl0ZVN0cmlkZSxcclxuXHRcdFx0XHRwb2ludGVyLmJ5dGVPZmZzZXQpO1xyXG5cdFx0XHQvLyBlbmFibGUgYXR0cmlidXRlIGluZGV4XHJcblx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVbmJpbmRzIHRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhCdWZmZXJ9IFRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxyXG5cdCAqL1xyXG5cdHVuYmluZCgpIHtcclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdHRoaXMucG9pbnRlcnMuZm9yRWFjaCgocG9pbnRlciwgaW5kZXgpID0+IHtcclxuXHRcdFx0Ly8gZGlzYWJsZSBhdHRyaWJ1dGUgaW5kZXhcclxuXHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlIHRoZSBkcmF3IGNvbW1hbmQgZm9yIHRoZSBib3VuZCBidWZmZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7VmVydGV4QnVmZmVyfSBUaGUgdmVydGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cclxuXHQgKi9cclxuXHRkcmF3KCkge1xyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cdFx0Z2wuZHJhd0FycmF5cyhnbFt0aGlzLm1vZGVdLCB0aGlzLmluZGV4T2Zmc2V0LCB0aGlzLmNvdW50KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBWZXJ0ZXhCdWZmZXI7XHJcbiJdfQ==
